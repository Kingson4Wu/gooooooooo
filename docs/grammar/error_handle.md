错误和异常从Golang机制上讲，就是error和panic的区别。很多其他语言也一样，比如C++/Java，没有error但有errno，没有panic但有throw。

Golang错误和异常是可以互相转换的：

错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。
异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。


什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。

在这个启示下，我们给出异常处理的作用域（场景）：

空指针引用
下标越界
除数为0
不应该出现的分支，比如default
输入不应该引起函数错误


说明： Golang错误处理方式一直是很多人诟病的地方，有些人吐槽说一半的代码都是"if err != nil { / 打印 && 错误处理 / }"，严重影响正常的处理逻辑。当我们区分错误和异常，根据规则设计函数，就会大大提高可读性和可维护性。


### 错误处理的正确姿势
姿势一：失败的原因只有一个时，不使用error
姿势二：没有失败时，不使用error
姿势三：error应放在返回值类型列表的最后
姿势四：错误值统一定义，而不是跟着感觉走
姿势五：错误逐层传递时，层层都加日志?(不一定，日志打得太多了)
姿势六：错误处理使用defer
姿势七：当尝试几次可以避免失败时，不要立即返回错误
姿势八：当上层函数不关心错误时，建议不返回error
姿势九：当发生错误时，不忽略有用的返回值




当Golang的代码执行时，如果遇到defer的闭包调用，则压入堆栈。当函数返回时，会按照后进先出的顺序调用闭包。
对于闭包的参数是值传递，而对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值。

### 异常处理的正确姿势
姿势一：在程序开发阶段，坚持速错
最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复
姿势二：在程序部署后，应恢复异常避免程序终止
在Golang中，虽然有类似Erlang进程的Goroutine，但需要强调的是Erlang的挂，只是Erlang进程的异常退出，不会导致整个Erlang节点退出，所以它挂的影响层面比较低，而Goroutine如果panic了，并且没有recover，那么整个Golang进程（类似Erlang节点）就会异常退出。所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。
姿势三：对于不应该出现的分支，使用异常处理
姿势四：针对入参不应该有问题的函数，使用panic设计



作者：_张晓龙_
链接：https://www.jianshu.com/p/f30da01eea97
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。