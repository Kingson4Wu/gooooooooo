+ 这是一篇实践者对 Go 语言的微吐槽:<https://mp.weixin.qq.com/s/UP_Rf-x1HekU-nl7BneVyg>
    - 零初始化：不注意可能导致0值参数导致不合理的配置
    - 过度 linting：go1.8已经不会强制错误
    - 返回错误：发生错误时，它们无需为非错误返回值提供一个值。？？
    - nil 切片和 JSON：
    - Go 模块和 Gitlab：1.第一个问题是 Gitlab 允许用户拥有递归项目组；2.由于我们的 Gitlab 实例是私有的，并且 Go 尝试通过 https 下载 git 存储库，因此当我们尝试下载未经任何身份验证的 Go 模块时，会收到 401 错误。使用我们的 Gitlab 密码进行身份验证是不切实际的选择，尤其是在涉及 CI/CD 的情况下。我们找到的解决方案是在使用这个.gitconfig 发出 https 请求时，强制 git 使用 ssh。
    - 日期格式 API：须使用“2006-01-02”格式的字符串（我也觉得特别恶心。。）


   + Go语言真的在设计上是一个糟糕的语言吗？：<https://www.zhihu.com/question/310386573/answer/852786886>
    - Go差一步就可以有一个相当不错的范型系统的，可惜最后一步走错了路，结果做出了interface这个令人迷惑而且不伦不类的东西。

 
---

+ Golang中常用的代码优化点:<https://mp.weixin.qq.com/s/QONfbKioFf6VqJE2OwP7Kw>

+ 在初始化slice的时候尽量补全cap
growslice的作用就是扩充slice的容量大小
growsslice的操作是一个比较复杂的操作，它的表现和复杂度会高于最基本的初始化make方法。对追求性能的程序来说，应该能避免尽量避免。
具体对growsslice函数具体实现同学有兴趣的可以参考源码src的 runtime/slice.go
我们并不是每次都能在slice初始化的时候就能准确预估到最终的使用容量的。所以这里使用了一个“尽量”。明白是否设置slice容量的区别，我们在能预估容量的时候，请尽量使用方法2那种预估容量后的slice初始化方式

+ 初始化一个类的时候，如果类的构造参数较多，尽量使用Option写法 
```go
type Foo struct {
 name string
 id int
 age int

 db interface{}
}

// FooOption 代表可选参数
type FooOption func(foo *Foo)

// WithName 代表Name为可选参数
func WithName(name string) FooOption {
   return func(foo *Foo) {
      foo.name = name
   }
}

// WithAge 代表age为可选参数
func WithAge(age int) FooOption {
   return func(foo *Foo) {
      foo.age = age
   }
}

// WithDB 代表db为可选参数
func WithDB(db interface{}) FooOption {
   return func(foo *Foo) {
      foo.db = db
   }
}

// NewFoo 代表初始化
func NewFoo(id int, options ...FooOption) *Foo {
   foo := &Foo{
      name: "default",
      id:   id,
      age:  10,
      db:   nil,
   }
   for _, option := range options {
      option(foo)
   }
   return foo
}

// 具体使用NewFoo的函数
func Bar() {
   foo := NewFoo(1, WithAge(15), WithName("foo"))
   fmt.Println(foo)
}

```


+ 巧用大括号控制变量作用域
    - 在golang写的过程中，你一定有过为 := 和 = 烦恼的时刻。一个变量，到写的时候，我还要记得前面是否已经定义过了，如果没有定义过，使用 := ，如果已经定义过，使用 =。
```go
var name string
var folder string
var mod string
...
{
   prompt := &survey.Input{
      Message: "请输入目录名称：",
   }
   err := survey.AskOne(prompt, &name)
   if err != nil {
      return err
   }

   ...
}
{
   prompt := &survey.Input{
      Message: "请输入模块名称(go.mod中的module, 默认为文件夹名称)：",
   }
   err := survey.AskOne(prompt, &mod)
   if err != nil {
      return err
   }
   ...
}
{
   // 获取hade的版本
   client := github.NewClient(nil)
   prompt := &survey.Input{
      Message: "请输入版本名称(参考 https://github.com/gohade/hade/releases，默认为最新版本)：",
   }
   err := survey.AskOne(prompt, &version)
   if err != nil {
      return err
   }
   ...
}
```
+ 首先我将最终解析出来的最终变量在最开始做定义，然后使用三个大括号，分别将 name, mod, version 三个变量的解析逻辑封装在里面。而在每个大括号里面，err变量的作用域就完全局限在括号中了，每次都可以直接使用 := 来创建一个新的 err并处理它，不需要额外思考这个err 变量是否前面已经创建过了。
+ 如果你自己观察，大括号在代码语义上还有一个好处，就是归类和展示。归类的意思是，这个大括号里面的变量和逻辑是一个完整的部分，他们内部创建的变量不会泄漏到外部。这个等于等于告诉后续的阅读者，你在阅读的时候，如果对这个逻辑不感兴趣，不阅读里面的内容，而如果你感兴趣的话，可以进入里面进行阅读。基本上所有IDE都支持对大括号封装的内容进行压缩，我使用Goland，压缩后，我的命令行的主体逻辑就更清晰了。
+ 所以使用大括号，结合IDE，你的代码的可读性能得到很大的提升。



---

+ 一定记住，Go 中不要犯这 5 个错误:<https://mp.weixin.qq.com/s/ZJvGqPYbudzjd8KcAozA_A>
+ 1、循环内部
    - 1.1、循环迭代器变量中使用引用
    - 1.2、在循环中调用 WaitGroup.Wait
    - 1.3、循环内使用 defer
+ 2、channel 堵塞
    - 解决办法是将 ch 从无缓冲的通道改为有缓冲的通道，因此子goroutine 即使在父 goroutine 退出后也始终可以发送结果。
    - ????? 缓存区为1，发完1个没接收还不是会继续阻塞？？？？？
+ 3、不使用接口
    - 接口可以使代码更灵活。这是在代码中引入多态的一种方法。接口允许你定义一组行为而不是特定类型。不使用接口可能不会导致任何错误，但是会导致代码简单性，灵活性和扩展性降低。
    - 你应该知道的重要注意事项是，始终关注行为。在上面的示例中，虽然 io.ReadWriteCloser 也可以使用，但你只需要 Write 方法。接口越大，抽象性越弱。在 Go 中，通常提倡小接口。
+ 4、不注意结构体字段顺序
    - 这个问题不会导致程序错误，但是可能会占用更多内存。
    - 看起来这两个类型都占用的空间都是 21字节，但是结果却不是这样。我们使用 GOARCH=amd64 编译代码，发现 BadOrderedPerson 类型占用 32 个字节，而  OrderedPerson 类型只占用 24 个字节。为什么？原因是数据结构对齐[1]。在 64 位体系结构中，内存分配连续的 8 字节数据。
    - 当你使用大型常用类型时，可能会导致性能问题。但是不用担心，你不必手动处理所有结构。这工具可以轻松的解决此类问题：https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment。 ！！！！！
- 5、测试中不使用 race 探测器 !!!!
    - 数据争用会导致莫名的故障，通常是在代码已部署到线上很久之后才出现。因此，它们是并发系统中最常见且最难调试的错误类型。为了帮助区分此类错误，Go 1.1 引入了内置的数据争用检测器（race detector）。可以简单地添加 -race flag 来使用。
    ```shell
    $ go test -race pkg    # to test the package
        $ go run -race pkg.go  # to run the source file
        $ go build -race       # to build the package
        $ go install -race pkg # to install the package
    ```         
    - 启用数据争用检测器后，编译器将记录在代码中何时以及如何访问内存，而  runtime 监控对共享变量的非同步访问。
    找到数据竞争后，竞争检测器将打印一份报告，其中包含用于冲突访问的堆栈跟踪。      



1.1、循环迭代器变量中使用引用
出于效率考虑，经常使用单个变量来循环迭代器。由于在每次循环迭代中会有不同的值，有些时候这会导致未知的行为。例如：

in := []int{1, 2, 3}

var out []*int
for  _, v := range in {
 out = append(out, &v)
}

fmt.Println("Values:", *out[0], *out[1], *out[2])
fmt.Println("Addresses:", out[0], out[1], out[2])
输出结果：

Values: 3 3 3
Addresses: 0xc000014188 0xc000014188 0xc000014188
是不是很惊讶？在 out 这个 slice 中的元素都是 3。实际上很容易解释为什么会这样：在每次迭代中，我们都将 v append 到 out 切片中。因为 v 是单个变量（内存地址不变），每次迭代都采用新值。在输出的第二行证明了地址是相同的，并且它们都指向相同的值。

简单的解决方法是将循环迭代器变量复制到新变量中：

in := []int{1, 2, 3}

var out []*int
for  _, v := range in {
 v := v
 out = append(out, &v)
}

fmt.Println("Values:", *out[0], *out[1], *out[2])
fmt.Println("Addresses:", out[0], out[1], out[2])
新的输出：

Values: 1 2 3
Addresses: 0xc0000b6010 0xc0000b6018 0xc0000b6020
在 goroutine 中使用循环迭代变量会有相同的问题。

list := []int{1, 2, 3}

for _, v := range list {
 go func() {
  fmt.Printf("%d ", v)
 }()
}
输出将是：

3 3 3
可以使用上述完全相同的解决方案进行修复。请注意，如果不使用 goroutine 运行该函数，则代码将按预期运行。

这个错误犯错率是很高的，要特别注意！！

所以，使用匿名函数的时候go func的时候要时刻注意循环变量的Scope, 该传参传参，该重新定义重新定义。好在 Goland 最新版本已经会提示i存在Scope问题了。但是好像没几个人会注意IDE警告，所以，习惯很重要，不要写出IDE警告的代码也是一个不错的编程理念。

----

+ 哦，原来是这么回事：Golang 中的一些常识:<https://mp.weixin.qq.com/s/-l9R_QblXr1_JHGtjldoQw>

for _, i := range ss， ss 中的元素是 copy 到 变量i 的

现象

for range 的时候 slice 中的元素是copy给 变量i的，并且下次for循环，变量i会被直接覆盖。并不是把 n号元素的地址给了i，i 是第 n 号元素的 copy。


要更改生效也很简单，主要有两种方案，一种是使用切片指针 []*User，这样对于i的修改会被自动寻址到数字元素上。另一种是使用下标 主动寻址如 users[idx].Uid = 2 。


这个问题看似简单，如果将其使用go关键字并发将会发生巨大威力，造成血淋淋的事故。
其实用go的公司经常听到这样的事故：
* 某公司发运营push全部发给了同一个uid
* 某研发发运营消息发短信发给了同一个uid (如果通道商不限制，我相信用户哭了，哄不好的那种)
* 批量发优惠券，给同一个uid发了几百张
* ....
闭包问题一点都不新鲜，就是由于在go func里边使用for了循环的变量i了，然后因为函数体并没在go的时候立即执行需要申请资源挂载然后由M进行运行需要一些时间，所以一般for循环执行一段时间之后go func才会执行，这时候 内部函数取到的值就得听天命了。


+ []T 还是 []*T

现象

一般来说[]T 会比较高效一些，但是如果T比较大，在For循环时存在Copy开销，个人觉得[]*T也是可以的。


+ `[]interface{}`并不能接收[]T类型

现象

很多时候我们都以为interface可以传递任意类型，凡事总有例外，他就不能接收 []T 类型, 如果你需要进行赋值，那你要将T转成interface{}
理解

因为一个[]interface{}的空间是一定的，但是 []T 不是，因为占用空间不一致，编译器觉得有些代价，并没有进行转换.


+ Send on closed chan 会Panic，但是 Receive from closed chan 不会

现象

往已经关闭的channel 再send数据会触发runtime panic，但是receive从已经关闭的channel中消费不会触发.
理解

很多人有误区，认为chan关闭了就不能再操作了，但是send进chan的数据总归要消费完的，不然就丢了，你品。

+ Goroutine 之间不能 Recover painc

现象

goroutine没有父子关系（创建应该不算父子吧），不能在一个go中 recover 另一个 go 的 panic
理解

GPM模型在go的调度时没有上下级关系, 也没有跨goroutine的异常捕获机制。


----

+ 腾讯发布了Go语言代码安全指南 - 知乎:<https://zhuanlan.zhihu.com/p/400078436?utm_source=wechat_session&utm_medium=social&utm_oi=35352332992512&utm_campaign=shareopn>
+  https://github.com/Tencent/secguide !!!!!
    - 1.1.1切片长度校验
    - 1.1.2nil指针判断
    - 1.1.3整数安全
    - 1.1.4make分配长度验证 : `ifsize>64*1024*1024{returnnil,errors.New("value too large")`
    - 1.1.5禁止SetFinalizer和指针循环引用同时使用
    - 1.1.6禁止重复释放channel
    - 1.1.7确保每个协程都能退出
    - 1.1.8不使用unsafe包
    - 1.1.9不使用slice作为函数入参: slice是引用类型，在作为函数入参时采用的是地址传递，对slice的修改也会影响原始数据
    - 1.2.1 路径穿越检查
    - 1.2.2 文件访问权限
    - 1.3.1命令执行检查
    - 1.4.1网络通信采用TLS方式
    - 1.4.2TLS启用证书验证
    - 1.9.1禁止在闭包中直接调用循环变量: 在循环中启动协程，当协程中使用到了循环的索引值，由于多个协程同时使用同一个变量会产生数据竞争，造成执行结果异常。
    - 1.9.2禁止并发写map


---

+ Golang 编程思维和工程实战：<https://mp.weixin.qq.com/s/llmE9QpnrvA02AtvfHtqJQ> TODO !!!


### 一 Golang 编程思维
要理解 Golang 编程思维，首先要理解 Golang 这门语言的创始初衷，初衷就是为了解决好 Google 内部大规模高并发服务的问题，主要核心就是围绕高并发来开展；并且同时又不想引入面向对象那种很复杂的继承关系。首先，就是可以方便的解决好并发问题（包括高并发），那么就需要有并发思维，能够并发处理就通过并发来进行任务分配

这个就是涉及到了 context、 goroutine、channel（select）；
创建大量 goroutine， 但是需要能通过 context、 channel 建立 "父子"关系，保证子任务可以能够被回收、被主动控制（如 杀死）。
再者，面向对象编程思想，利用好 interface、 struct 来实现继承、多态的用法：

struct 匿名组合来实现继承；
terface 和 struct 来实现多态；
interface 定义接口，尽可能的保持里面的方法定义简单，然后多个 interface 进行组合。
然后，理解 Golang 语言本身的一些特性: - 强类型，语法上要注意处理；- GC，实际中要观察 GC 日志并分析；- 注意语法语义尽可能的简单、保持各种类型定义尽可能精简。

最后，从 Golang 社区的一些最佳实践来看，Golang 的各种组件需要尽可能的精简。

Golang 中用好的一些开源组件库，都是比较轻量级的，然后可以各自随意组合来达到最佳实践。
我们自己进行组件封装、模块封装的时候，也是保持这个原则，尽可能的精简，然后使用方进行组合。

### 二、Golang 高级编码技巧
+ 1 优雅的实现构造函数编程思想
+ 2 优雅的实现继承编程思想
+ 3 优雅的实现虚多态编程思想
+ 4 Golang 的 model service 模型【类 MVC 模型】
+ 5 Golang 单例模式
+ 6 Golang layout
<pre>
Golang 工程 Layout 规范，网上有较多探讨，每个人的理解也会不一致，但是有些基础的理解是可以保持统一的：

cmd

main 函数文件目录，这个目录下面，每个文件在编译之后都会生成一个可执行的文件。如果只有一个 app 文件，那就是 main.go。这里面的代码尽可能简单。
conf

配置文件，如 toml、yaml 等文件
config

配置文件的解析
docs

文档
pkg

底层各种实现，每一种实现封装一个文件夹
业界知名开源项目如 Kubernetes、Istio 都是这样的姿势
build

编译脚本
CI 脚本
上下线脚本
vendor

依赖库

$ tree  -d  -L 2
├── build
├── cmd
│   ├── apply
│   └── check
├── conf
├── config
├── docs
├── pkg
│   ├── apply
│   ├── check
│   ├── files
│   ├── k8s
│   └── options
└── vendor
</pre>

+ 7 cmd & command & flag


-----

+ Go 高性能编程技法:<https://mp.weixin.qq.com/s/Lv2XTD-SPnxT2vnPNeREbg> !!! 写得很好

### 常用数据结构
+ 1.1 优先使用 strconv 而不是 fmt
基本数据类型与字符串之间的转换，优先使用 strconv 而不是 fmt，因为前者性能更佳。
+ 1.2 少量的重复不比反射差
`go test -bench=. -benchmem main/reflect `
+ 1.3 慎用 binary.Read 和 binary.Write
binary.Read 和 binary.Write 使用反射并且很慢。如果有需要用到这两个函数的地方，我们应该手动实现这两个函数的相关功能，而不是直接去使用它们。

+ 2.避免重复的字符串到字节切片的转换
不要反复从固定字符串创建字节 slice，因为重复的切片初始化会带来性能损耗。相反，请执行一次转换并捕获结果。
+ 3.指定容器容量
+ 3.1 指定 map 容量提示
+ 3.2 指定切片容量
+ 4.字符串拼接方式的选择
+ 4.1 行内拼接字符串推荐使用运算符+
行内字符串的拼接，主要追求的是代码的简洁可读。fmt.Sprintf() 能够接收不同类型的入参，通过格式化输出完成字符串的拼接，使用非常方便。但因其底层实现使用了反射，性能上会有所损耗。

运算符 + 只能简单地完成字符串之间的拼接，非字符串类型的变量需要单独做类型转换。行内拼接字符串不会产生内存分配，也不涉及类型地动态转换，所以性能上优于fmt.Sprintf()。

从性能出发，兼顾易用可读，如果待拼接的变量不涉及类型转换且数量较少（<=5），行内拼接字符串推荐使用运算符 +，反之使用 fmt.Sprintf()。

+ 4.2 非行内拼接字符串推荐使用 strings.Builder
字符串拼接还有其他的方式，比如strings.Join()、strings.Builder、bytes.Buffer和byte[]，这几种不适合行内使用。当待拼接字符串数量较多时可考虑使用。
综合易用性和性能，一般推荐使用strings.Builder来拼接字符串。
+ 5.遍历 []struct{} 使用下标而不是 range
两种通过 index 遍历 []struct 性能没有差别，但是 range 遍历 []struct 中元素时，性能非常差。

range 只遍历 []struct 下标时，性能比 range 遍历  []struct 值好很多。从这里我们应该能够知道二者性能差别之大的原因。

Item 是一个结构体类型 ，Item 由两个字段构成，一个类型是 int，一个是类型是 [1024]byte，如果每次遍历 []Item，都会进行一次值拷贝，所以带来了性能损耗。

此外，因为 range 时获取的是值拷贝的副本，所以对副本的修改，是不会影响到原切片。

切片元素从结构体 Item 替换为指针 *Item 后，for 和 range 的性能几乎是一样的。而且使用指针还有另一个好处，可以直接修改指针对应的结构体的值。
+ 5.4 小结
range 在迭代过程中返回的是元素的拷贝，index 则不存在拷贝。

如果 range 迭代的元素较小，那么 index 和 range 的性能几乎一样，如基本类型的切片 []int。但如果迭代的元素较大，如一个包含很多属性的 struct 结构体，那么 index 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 index。如果使用 range，建议只迭代下标，通过下标访问元素，这种使用方式和 index 就没有区别了。如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。

### 内存管理
+ 1.使用空结构体节省内存
+ 1.1 不占内存空间
在 Go 中，我们可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数。
Go 中空结构体 struct{} 是不占用内存空间，不像 C/C++ 中空结构体仍占用 1 字节。
+ 1.2 用法
因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符，达到的代码即注释的效果。
+ 1.2.1 实现集合（Set）
Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间。

因此呢，将 map 作为集合（Set）使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。
+ 1.2.2 不发送数据的信道
有时候使用 channel 不需要发送任何的数据，只用来通知子协程（goroutine）执行任务，或只用来控制协程的并发。这种情况下，使用空结构体作为占位符就非常合适了。
+ 1.2.3 仅包含方法的结构体
在部分场景下，结构体只包含方法，不包含任何的字段。例如上面例子中的 Door，在这种情况下，Door 事实上可以用任何的数据结构替代。
+ 2.struct 布局要考虑内存对齐
+ 2.1 为什么需要内存对齐
简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。
+ 2.2 Go 内存对齐规则
编译器一般为了减少 CPU 访存指令周期，提高内存的访问效率，会对变量进行内存对齐。Go 作为一门追求高性能的后台编程语言，当然也不例外。
Go Language Specification 中 Size and alignment guarantees 描述了内存对齐的规则。
+ 2.3 合理的 struct 布局
因为内存对齐的存在，合理的 struct 布局可以减少内存占用，提高程序性能。
因此，在对内存特别敏感的结构体的设计上，我们可以通过调整字段的顺序，将字段宽度从小到大由上到下排列，来减少内存的占用。
+ 2.4 空结构与空数组对内存对齐的影响
空结构与空数组在 Go 中比较特殊。没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0。
+ 3.减少逃逸，将变量限制在栈上
变量逃逸一般发生在如下几种情况：

变量较大
变量大小不确定
变量类型不确定
返回指针
返回引用
闭包
知道变量逃逸的原因后，我们可以有意识的控制变量不发生逃逸，将其控制在栈上，减少堆变量的分配，降低 GC 成本，提高程序性能。
+ 3.1 小的拷贝好过引用
我们都知道 Go 里面的 Array 以 pass-by-value 方式传递后，再加上其长度不可扩展，考虑到性能我们一般很少使用它。实际上，凡事无绝对。有时使用数组进行拷贝传递，比使用切片要好。
+ 3.2 返回值 VS 返回指针
值传递会拷贝整个对象，而指针传递只会拷贝地址，指向的对象是同一个。返回指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择返回指针。对于只读的占用内存较小的结构体，直接返回值能够获得更好的性能。
+ 3.3 返回值使用确定的类型
如果变量类型不确定，那么将会逃逸到堆上。所以，函数返回值如果能确定的类型，就不要使用 interface{}。
+ 4.sync.Pool 复用对象
+ 4.1 简介
sync.Pool 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”。个人觉得它的名字有一定的误导性，因为 Pool 里装的对象可以被无通知地被回收，可能 sync.Cache 是一个更合适的名字。
+ sync.Pool 是可伸缩的，同时也是并发安全的，其容量仅受限于内存的大小。存放在池中的对象如果不活跃了会被自动清理。
+ 4.2 作用
对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。
一句话总结：用来保存和复用临时对象，减少内存分配，降低 GC 压力。
+ 4.3 如何使用
sync.Pool 的使用方式非常简单，只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。
+ 4.4 性能差异
我们以 bytes.Buffer 字节缓冲器为例，利用 sync.Pool 复用 bytes.Buffer 对象，避免重复创建与回收内存，来看看对性能的提升效果。
从测试结果也可以看出，使用了 Pool 复用对象，每次操作不再有内存分配。
+ 4.5 在标准库中的应用
Go 标准库也大量使用了 sync.Pool，例如 fmt 和 encoding/json。以 fmt 包为例，我们看下其是如何使用 sync.Pool 的。
fmt.Printf() 的调用是非常频繁的，利用 sync.Pool 复用 pp 对象能够极大地提升性能，减少内存占用，同时降低 GC 压力。

### 并发编程
+ 1.关于锁
+ 1.1 无锁化
无锁化主要有两种实现，无锁数据结构和串行无锁。
+ 1.1.1 无锁数据结构
+ 1.1.2 串行无锁
串行无锁是一种思想，就是避免对共享资源的并发访问，改为每个并发操作访问自己独占的资源，达到串行访问资源的效果，来避免使用锁。不同的场景有不同的实现方式。比如网络 I/O 场景下将单 Reactor 多线程模型改为主从 Reactor 多线程模型，避免对同一个消息队列锁读取。
+ 1.2 减少锁竞争
+ 1.3 优先使用共享锁而非互斥锁
如果并发无法做到无锁化，优先使用共享锁而非互斥锁。

所谓互斥锁，指锁只能被一个 Goroutine 获得。共享锁指可以同时被多个 Goroutine 获得的锁。

Go 标准库 sync 提供了两种锁，互斥锁（sync.Mutex）和读写锁（sync.RWMutex），读写锁便是共享锁的一种具体实现。
+ 1.3.1 sync.Mutex
+ 1.3.2 sync.RWMutex
+ 1.3.3 性能对比
大部分业务场景是读多写少，所以使用读写锁可有效提高对共享数据的访问效率。最坏的情况，只有写请求，那么读写锁顶多退化成互斥锁。所以优先使用读写锁而非互斥锁，可以提高程序的并发性能。
可见读多写少的场景，使用读写锁并发性能会更优。可以预见的是如果写占比更低，那么读写锁带的并发效果会更优。
+ 2.限制协程数量
+ 2.1 协程数过多的问题
+ 2.1.1 程序崩溃
Go 程（goroutine）是由 Go 运行时管理的轻量级线程。通过它我们可以轻松实现并发编程。但是当我们无限开辟协程时，将会遇到致命的问题。
每个协程至少需要消耗 2KB 的空间，那么假设计算机的内存是 4GB，那么至多允许 4GB/2KB = 1M 个协程同时存在。那如果协程中还存在着其他需要分配内存的操作，那么允许并发执行的协程将会数量级地减少。
+ 2.1.2 协程的代价
Go 的开销主要是三个方面：创建（占用内存）、调度（增加调度器负担）和删除（增加 GC 压力）。

内存开销
空间上，一个 Go 程占用约 2K 的内存，在源码 src/runtime/runtime2.go里面，我们可以找到 Go 程的结构定义type g struct。

调度开销
时间上，协程调度也会有 CPU 开销。我们可以利用runntime.Gosched()让当前协程主动让出 CPU 去执行另外一个协程，下面看一下协程之间切换的耗时。
可见一次协程的切换，耗时大概在 100ns，相对于线程的微秒级耗时切换，性能表现非常优秀，但是仍有开销。
GC 开销 创建 Go 程到运行结束，占用的内存资源是需要由 GC 来回收，如果无休止地创建大量 Go 程后，势必会造成对 GC 的压力。

+ 2.2 限制协程数量
可以利用信道 channel 的缓冲区大小来实现。
```go
func main() {
 var wg sync.WaitGroup
 ch := make(chan struct{}, 3)
 for i := 0; i < 10; i++ {
  ch <- struct{}{}
  wg.Add(1)
  go func(i int) {
   defer wg.Done()
   log.Println(i)
   time.Sleep(time.Second)
   <-ch
  }(i)
 }
 wg.Wait()
}
```
+ 2.3 协程池化
上面的例子只是简单地限制了协程开辟的数量。在此基础之上，基于对象复用的思想，我们可以重复利用已开辟的协程，避免协程的重复创建销毁，达到池化的效果。

协程池化，我们可以自己写一个协程池，但不推荐这么做。因为已经有成熟的开源库可供使用，无需再重复造轮子。目前有很多第三方库实现了协程池，可以很方便地用来控制协程的并发数量，比较受欢迎的有：

Jeffail/tunny
panjf2000/ants
下面以 panjf2000/ants 为例，简单介绍其使用。

ants 是一个简单易用的高性能 Goroutine 池，实现了对大规模 Goroutine 的调度管理和复用，允许使用者在开发并发程序的时候限制 Goroutine 数量，复用协程，达到更高效执行任务的效果。

+ 2.4 小结
Golang 为并发而生。Goroutine 是由 Go 运行时管理的轻量级线程，通过它我们可以轻松实现并发编程。Go 虽然轻量，但天下没有免费的午餐，无休止地开辟大量 Go 程势必会带来性能影响，甚至程序崩溃。所以，我们应尽可能的控制协程数量，如果有需要，请复用它。

+ 3.使用 sync.Once 避免重复执行
+ 3.1 简介
sync.Once 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。
init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。
sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。
在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写满足如下三个条件：

当且仅当第一次访问某个变量时，进行初始化（写）；
变量初始化过程中，所有读都被阻塞，直到初始化完成；
变量仅初始化一次，初始化完成后驻留在内存里。
+ 3.2 原理
sync.Once 用来保证函数只执行一次。要达到这个效果，需要做到两点：

计数器，统计函数执行次数；
线程安全，保障在多 Go 程的情况下，函数仍然只执行一次，比如锁。
+ 3.2.1 源码
下面看一下 sync.Once 结构，其有两个变量。使用 done 统计函数执行次数，使用锁 m 实现线程安全。
+ 3.2.2  done 为什么是第一个字段
+ 3.3 性能差异
使用 sync.Once 保证函数只会被执行一次和多次执行，二者的性能差异。
sync.Once 中保证了 Config 初始化函数仅执行了一次，避免了多次重复初始化，在并发环境下很有用。
+ 4.使用 sync.Cond 通知协程 ！！！！
+ 4.1 简介
sync.Cond 是基于互斥锁/读写锁实现的条件变量，用来协调想要访问共享资源的那些 Goroutine，当共享资源的状态发生变化的时候，sync.Cond 可以用来通知等待条件发生而阻塞的 Goroutine。

sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么呢？

互斥锁 sync.Mutex 通常用来保护共享的临界资源，条件变量 sync.Cond 用来协调想要访问共享资源的 Goroutine。当共享资源的状态发生变化时，sync.Cond 可以用来通知被阻塞的 Goroutine。
+ 4.2 使用场景
sync.Cond 经常用在多个 Goroutine 等待，一个 Goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了。


我们想象一个非常简单的场景：

有一个协程在异步地接收数据，剩下的多个协程必须等待这个协程接收完数据，才能读取到正确的数据。在这种情况下，如果单纯使用 chan 或互斥锁，那么只能有一个协程可以等待，并读取到数据，没办法通知其他的协程也读取数据。

这个时候，就需要有个全局的变量来标志第一个协程数据是否接受完毕，剩下的协程，反复检查该变量的值，直到满足要求。或者创建多个 channel，每个协程阻塞在一个 channel 上，由接收数据的协程在数据接收完毕后，逐个通知。总之，需要额外的复杂度来完成这件事。

Go 语言在标准库 sync 中内置一个 sync.Cond 用来解决这类问题。

channel+select 的组合，是比较优雅的通知？？？

+ 4.3 原理
sync.Cond 内部维护了一个等待队列，队列中存放的是所有在等待这个 sync.Cond 的 Go 程，即保存了一个通知列表。sync.Cond 可以用来唤醒一个或所有因等待条件变量而阻塞的 Go 程，以此来实现多个 Go 程间的同步。
+ 4.4 使用示例
我们实现一个简单的例子，三个协程调用 Wait() 等待，另一个协程调用 Broadcast() 唤醒所有等待的协程。
```go
var done = false

func read(name string, c *sync.Cond) {
 c.L.Lock()
 for !done {
  c.Wait()
 }
 log.Println(name, "starts reading")
 c.L.Unlock()
}

func write(name string, c *sync.Cond) {
 log.Println(name, "starts writing")
 time.Sleep(time.Second)
 done = true
 log.Println(name, "wakes all")
 c.Broadcast()
}

func main() {
 cond := sync.NewCond(&sync.Mutex{})

 go read("reader1", cond)
 go read("reader2", cond)
 go read("reader3", cond)
 write("writer", cond)

 time.Sleep(time.Second * 3)
}
```
+ 4.5 注意事项
sync.Cond 不能被复制
唤醒顺序
从等待队列中按照顺序唤醒，先进入等待队列，先被唤醒。
调用 Wait() 前要加锁
调用 Wait() 函数前，需要先获得条件变量的成员锁，原因是需要互斥地变更条件变量的等待队列。在 Wait() 返回前，会重新上锁。

---


+ 万字详文阐释程序员修炼之道:<https://mp.weixin.qq.com/s/XIwfj_AdZqX_vHM4VIq9EA> ！！！！！！！

## 综述
我写过一篇《Code Review 我都 CR 些什么》，讲解了 Code Review 对团队有什么价值，我认为 CR 最重要的原则有哪些。最近我在团队工作中还发现了：

原则不清晰。对于代码架构的原则，编码的追求，我的骨干员工对它的认识也不是很全面。当前还是在 review 过程中我对他们口口相传，总有遗漏。
从知道到会做需要时间。我需要反复跟他们补充 review 他们漏掉的点，他们才能完成吸收、内化，在后续的 review 过程中，能自己提出这些 review 的点。
过度文档化是有害的，当过多的内容需要被阅读，工程师们最终就会选择不去读，读了也仅仅能吸收很少一部分。在 google，对于代码细节的理解，更多还是口口相传，在实践中去感受和理解。但是，适当的文档、文字宣传，是必要的。特此，我就又输出了这一篇文章，尝试从'知名架构原则'、'工程师的自我修养'、'不能上升到原则的几个常见案例'三大模块，把我个人的经验系统地输出，供其他团队参考。

## 知名架构原则
### 把代码和文档绑在一起(自解释原则)
+ 写文档是个好习惯。但是写一个别人需要咨询老开发者才能找到的文档，是个坏习惯。这个坏习惯甚至会给工程师们带来伤害。
+ 总结起来就是，解释信息必须离被解释的东西，越近越好。代码能做到自解释，是最棒的。
### ETC 价值观(easy to change)
### DRY 原则(don not repeat yourself)
+ 不要重复！不要重复！不要重复！
### 正交性原则(全局变量的危害)
+ 大家可能并不是不明白正交性的价值，只是不知道怎么去正交。手段有很多，但是首先我就要批判一下 OOP。它的核心是多态，多态需要通过派生/继承来实现。继承树一旦写出来，就变得很难 change，你不得不为了使用一小段代码而去做继承，让代码耦合。

+ 你应该多使用组合，而不是继承。以及，应该多使用 DIP(Dependence Inversion Principle)，依赖倒置原则。换个说法，就是面向 interface 编程，面向契约编程，面向切面编程，他们都是 DIP 的一种衍生。写 golang 的同学就更不陌生了，我们要把一个 struct 作为一个 interface 来使用，不需要显式 implement/extend，仅仅需要持有对应 interface 定义了的函数。这种 duck interface 的做法，让 DIP 来得更简单。AB 两个模块可以独立编码，他们仅仅需要一个依赖一个 interface 签名，一个刚好实现该 interface 签名。并不需要显式知道对方 interface 签名的两个模块就可以在需要的模块、场景下被组合起来使用。代码在需要被组合使用的时候才产生了一点关系，同时，它们依然保持着独立。
+ 说个正交性的典型案例。全局变量是不正交的！没有充分的理由，禁止使用全局变量。全局变量让依赖了该全局变量的代码段互相耦合，不再正交。特别是一个 pkg 提供一个全局变量给其他模块修改，这个做法会让 pkg 之间的耦合变得复杂、隐秘、难以定位。
### 单例就是全局变量
+ 可以通过管道、消息机制来替代共享状态/使用全局变量/使用单例。仅仅能获取此刻最新的状态，通过消息变更状态。要拿到最新的状态，需要重新获取。在必要的时候，引入锁机制。
### 可逆性原则
+ 可逆性原则是很少被提及的一个原则。可逆性，就是你做出的判断，最好都是可以被逆转的。再换一个容易懂的说法，你最好尽量少认为什么东西是一定的、不变的。
### 依赖倒置原则(DIP)
“上层模块不应该依赖底层模块，它们都应该依赖于抽象。”，在最开始的设计中，高层模块PizzaStroe直接依赖低层模块（各种具体的Pizaa）,调整设计后，高层模块和低层模块都依赖于抽象（Pizza）
https://www.jianshu.com/p/c3ce6762257c
### 将知识用纯文本来保存
+ 这也是一个生僻的原则。指代码操作的数据和方案设计文稿，如果没有充分的必要使用特定的方案，就应该使用人类可读的文本来保存、交互。对于方案设计文稿，你能不使用 office 格式，就不使用(office 能极大提升效率，才用)，最好是原始 text。这是《Unix 编程艺术》也提到了的 Unix 系产生的设计信条。简而言之一句话，当需要确保有一个所有各方都能使用的公共标准，才能实现交互沟通时，纯文本就是这个标准。它是一个接受度最高的通行标准。如果没有必要的理由，我们就应该使用纯文本。
### 契约式设计
+ 代码是否不多不少刚好完成它宣称要做的事情，可以使用契约加以校验和文档化。TDD 就是全程在不断调整和履行着契约。TDD(Test-Driven Development)是自底向上地编码过程，其实会耗费大量的精力，并且对于一个良好的层级架构没有帮助。TDD 不是强推的规范，但是同学们可以用一用，感受一下。TDD 方法论实现的接口、函数，自我解释能力一般来说比较强，因为它就是一个实现契约的过程。
### 尽早崩溃
+ Erlang 和 Elixir 语言信奉这种哲学。乔-阿姆斯特朗，Erlang 的发明者，《Erlang 程序设计》的作者，有一句反复被引用的话: "防御式编程是在浪费时间，让它崩溃"。

尽早崩溃不是说不容错，而是程序应该被设计成允许出故障，有适当的故障监管程序和代码，及时告警，告知工程师，哪里出问题了，而不是尝试掩盖问题，不让程序员知道。当最后程序员知道程序出故障的时候，已经找不到问题出现在哪里了。

特别是一些 recover 之后什么都不做的代码，这种代码简直是毒瘤！当然，崩溃，可以是早一些向上传递 error，不一定就是 panic。同时，我要求大家不要在没有充分的必要性的时候 panic，应该更多地使用向上传递 error，做好 metrics 监控。合格的 golang 程序员，都不会在没有必要的时候无视 error，会妥善地做好 error 处理、向上传递、监控。一个死掉的程序，通常比一个瘫痪的程序，造成的损害要小得多。

崩溃但是不告警,或者没有补救的办法,不可取.尽早崩溃的题外话是,要在问题出现的时候做合理的告警,有预案,不能掩盖,不能没有预案

### 解耦代码让改变容易
这个原则，显而易见，大家自己也常常提，其他原则或多或少都和它有关系。但是我也再提一提。我主要是描述一下它的症状，让同学们更好地警示自己'我这两块代码是不是耦合太重，需要额外引入解耦的设计了'。症状如下:

不相关的 pkg 之间古怪的依赖关系
对一个模块进行的'简单'修改，会传播到系统中不相关的模块里，或是破坏了系统中的其他部分
开发人员害怕修改代码，因为他们不确定会造成什么影响
会议要求每个人都必须参加，因为没有人能确定谁会受到变化的影响

### 只管命令不要询问
+ 最好的那一段代码，就是只管给每个 struct 发送命令，要求大家做事儿。怎么做，就内聚在和 struct 关联的方法里，其他人不要去操心。一旦其他人操心了，当需要做修改的时候，就要操心了这个细节的人都一起参与进修改过程。
### 不要链式调用方法
+  当某个函数需要这个 struct 的成员的时候，我们把整个 struct 都作为参数传递进去。应该仅仅传递函数关心的最小集合。传进去的一整条调用链对函数来说，都是无关的耦合，只会让代码更 hard to change，让工程师惧怕去修改。
### 继承税(多用组合)
+ 继承就是耦合。不仅子类耦合到父类，以及父类的父类等，而且使用子类的代码也耦合到所有祖先类。 有些人认为继承是定义新类型的一种方式。他们喜欢设计图表，会展示出类的层次结构。他们看待问题的方式，与维多利亚时代的绅士科学家们看待自然的方式是一样的，即将自然视为须分解到不同类别的综合体。 不幸的是，这些图表很快就会为了表示类之间的细微差别而逐层添加，最终可怕地爬满墙壁。由此增加的复杂性，可能使应用程序更加脆弱，因为变更可能在许多层次之间上下波动。 因为一些值得商榷的词义消歧方面的原因，C++在20世纪90年代玷污了多重继承的名声。结果，许多当下的OO语言都没有提供这种功能。
+ Java 下一切都是类。C++里不使用类还不如使用 C。写 Python、PHP，我们也肯定要时髦地写一些类。写类可以，当你要去继承，你就得考虑清楚了。
+ 在 golang 下，继承税的烦恼被减轻了，golang 从来说自己不是 OO 的语言，但是你 OO 的事情，我都能轻松地做到。
+ 面向过程，面向对象，函数式编程。三种编程结构的核心区别，是在不同的方向限制程序员，来做到好的代码结构(引自《架构整洁之道》):

结构化编程是对程序控制权的直接转移的限制。
面向对象是对程序控制权的间接转移的限制。
函数式编程是对程序中赋值操作的限制。
+ SOLID 原则(单一功能、开闭原则、里氏替换、接口隔离、依赖反转，后面会讲到)是 OOP 编程的最经典的原则。其中 D 是指依赖倒置原则(Dependence Inversion Principle)，我认为，是 SOLID 里最重要的原则。J2EE 的 container 就是围绕 DIP 原则设计的。DIP 能用于避免构建复杂的继承树，DIP 就是'限制控制权的间接转移'能继续发挥积极作用的最大保障。合理使用 DIP 的 OOP 代码才可能是高质量的代码。
+ golang 的 interface 是 duck interface，把 DIP 原则更进一步，不需要显式 implement/extend interface，就能做到 DIP。golang 使用结构化编程范式，却有面向对象编程范式的核心优点，甚至简化了。这是一个基于高度抽象理解的极度精巧的设计。google 把 abstraction 这个设计理念发挥到了极致。曾经，J2EE 的 container(EJB, Java Bean)设计是国内 Java 程序员引以为傲'架构设计'、'厉害的设计'。
+ 在 golang 里，它被分析、解构，以更简单、灵活、统一、易懂的方式呈现出来。写了多年垃圾 C++代码的腾讯后端工程师们，是你们再次审视 OOP 的时候了。我大学一年级的时候看的 C++教材，终归给我描述了一个美好却无法抵达的世界。目标我没有放弃，但我不再用 OOP，而是更多地使用组合(Mixin)。写 golang 的同学，应该对 DIP 和组合都不陌生，这里我不再赘述。如果有人自傲地说他在 golang 下搞起了继承，我只能说，'同志，你现在站在了广大 gopher 的对立面'。现在，你站在哲学的云端，鸟瞰了 Structured Programming 和 OOP。
### 共享状态是不正确的状态 ！！！
+ 你坐在最喜欢的餐厅。吃完主菜，问男服务员还有没有苹果派。他回头一看-陈列柜里还有一个，就告诉你"还有"。点到了苹果派，你心满意足地长出了一口气。与此同时，在餐厅的另一边，还有一个顾客也问了女服务员同样的问题。她也看了看，确认有一个，让顾客点了单。总有一个顾客会失望的。

问题出在共享状态。餐厅里的每一个服务员都查看了陈列柜，却没有考虑到其他服务员。你们可以通过加互斥锁来解决正确性的问题，但是，两个顾客有一个会失望或者很久都得不到答案，这是肯定的。

所谓共享状态，换个说法，就是: 由多个人查看和修改状态。这么一说，更好的解决方案就浮出水面了: 将状态改为集中控制。预定苹果派，不再是先查询，再下单。而是有一个餐厅经理负责和服务员沟通，服务员只管发送下单的命令/消息，经理看情况能不能满足服务员的命令。

这种解决方案，换一个说法，也可以说成"用角色实现并发性时不必共享状态"。对，上面，我们引入了餐厅经理这个角色，赋予了他职责。当然，我们仅仅应该给这个角色发送命令，不应该去询问他。前面讲过了，'只管命令不要询问'，你还记得么。

同时，这个原则就是 golang 里大家耳熟能详的谚语: "不要通过共享内存来通信，而应该通过通信来共享内存"。作为并发性问题的根源，内存的共享备受关注。但实际上，在应用程序代码共享可变资源(文件、数据库、外部服务)的任何地方，问题都有可能冒出来。当代码的两个或多个实例可以同时访问某些资源时，就会出现潜在的问题。
### 缄默原则
+ 如果一个程序没什么好说，就保持沉默。过多的正常日志，会掩盖错误信息。过多的信息，会让人根本不再关注新出现的信息，'更多信息'变成了'没有信息'。每人添加一点信息，就变成了输出很多信息，最后等于没有任何信息。

不要在正常 case 下打印日志。
不要在单元测试里使用 fmt 标准输出，至少不要提交到 master。
不打不必要的日志。当错误出现的时候，会非常明显，我们能第一时间反应过来并处理。
让调试的日志停留在调试阶段，或者使用较低的日志级别，你的调试信息，对其他人根本没有价值。
即使低级别日志，也不能泛滥。不然，日志打开与否都没有差别，日志变得毫无价值。

### 错误传递原则
+ 我不喜欢 Java 和 C++的 exception 特性，它容易被滥用，它具有传染性(如果代码 throw 了 excepttion, 你就得 handle 它，不 handle 它，你就崩溃了。可能你不希望崩溃，你仅仅希望报警)。但是 exception(在 golang 下是 panic)是有价值的，参考微软的文章:

Exceptions are preferred in modern C++ for the following reasons:

* An exception forces calling code to recognize an error condition and handle it. Unhandled exceptions stop program execution.
* An exception jumps to the point in the call stack that can handle the error. Intermediate functions can let the exception propagate. They don't have to coordinate with other layers.
* The exception stack-unwinding mechanism destroys all objects in scope after an exception is thrown, according to well-defined rules.
* An exception enables a clean separation between the code that detects the error and the code that handles the error.
Google 的 C++规范在常规情况禁用 exception，理由包含如下内容：

Because most existing C++ code at Google is not prepared to deal with exceptions, it is comparatively difficult to adopt new code that generates exceptions.
从 google 和微软的文章中，我们不难总结出以下几点衍生的结论:

在必要的时候抛出 exception。使用者必须具备'必要性'的判断能力。
exception 能一路把底层的异常往上传递到高函数层级，信息被向上传递，并且在上级被妥善处理。可以让异常和关心具体异常的处理函数在高层级和低层级遥相呼应，中间层级什么都不需要做，仅仅向上传递。
exception 传染性很强。当代码由多人协作，使用 A 模块的代码都必须要了解它可能抛出的异常，做出合理的处理。不然，就都写一个丑陋的 catch，catch 所有异常，然后做一个没有针对性的处理。每次 catch 都需要加深一个代码层级，代码常常写得很丑。
我们看到了异常的优缺点。上面第二点提到的信息传递，是很有价值的一点。golang 在 1.13 版本中拓展了标准库，支持了Error Wrapping也是承认了 error 传递的价值。

所以，我们认为错误处理，应该具备跨层级的错误信息传递能力，中间层级如果不关心，就把 error 加上本层的信息向上透传(有时候可以直接透传)，应该使用 Error Wrapping。exception/panic 具有传染性。大量使用，会让代码变得丑陋，同时容易滋生可读性问题。我们应该多使用 Error Wrapping，在必要的时候，才使用 exception/panic。每一次使用 exception/panic，都应该被认真审核。需要 panic 的地方，不去 panic，也是有问题的。参考本文的'尽早崩溃'。

额外说一点，注意不要把整个链路的错误信息带到公司外，带到用户的浏览器、native 客户端。至少不能直接展示给用户看到。

### SOLID
SOLID 原则，是由以下几个原则的集合体:

SRP: 单一职责原则
OCP: 开闭原则
LSP: 里氏替换原则
ISP: 接口隔离原则
DIP: 依赖反转原则


这些年来，这几个设计原则在很多不同的出版物里都有过详细描述。它们太出名了，我这里就不更多地做详解了。我这里想说的是，这 5 个原则环环相扣，前 4 个原则，要么就是同时做到，要么就是都没做到，很少有说，做到其中一点其他三点都不满足。ISP 就是做到 LSP 的常用手段。ISP 也是做到 DIP 的基础。只是，它刚被提出来的时候，是主要针对'设计继承树'这个目的的。现在，它们已经被更广泛地使用在模块、领域、组件这种更大的概念上。

SOLI 都显而易见，DIP 原则是最值得注意的一点，我在其他原则里也多次提到了它。如果你还不清楚什么是 DIP，一定去看明白。这是工程师最基础、必备的知识点之一了。

要做到 OCP 开闭原则，其实，就是要大家要通过后面讲到的'不要面向需求编程'才能做好。如果你还是面向需求、面向 UI、交互编程，你永远做不到开闭，并且不知道如何才能做到开闭。

### 一个函数不要出现多个层级的代码

想象一下，我们没有把细节收归进 checkCookie()、getRelationship()等函数，而是展开在这里，但是总函数行数没有到 80 行，表面上符合规范。但是实际上，阅读代码的同学不再能轻松掌握业务逻辑，而是同时在阅读功能细节和业务流程。阅读代码变成了每个时刻心智负担都很重的事情。

显而易见，单个函数里应该只保留某一个层级(layer)的代码，更细化的细节应该被抽象到下一个 layer 去，成为子函数。
### Unix 哲学基础
模块原则: 使用简洁的接口拼合简单的部件
清晰原则: 清晰胜于技巧
组合原则: 设计时考虑拼接组合
分离原则: 策略同机制分离，接口同引擎分离
简洁原则: 设计要简洁，复杂度能低则低
吝啬原则: 除非确无它法，不要编写庞大的程序
透明性原则: 设计要可见，以便审查和调试
健壮原则: 健壮源于透明与简洁
表示原则: 把知识叠入数据以求逻辑质朴而健壮
通俗原则: 接口设计避免标新立异
缄默原则: 如果一个程序没什么好说，就保持沉默
补救原则: 出现异常时，马上退出并给出足量错误信息
经济原则: 宁花机器一分，不花程序员一秒
生成原则: 避免手工 hack，尽量编写程序去生成程序
优化原则: 雕琢前先得有原型，跑之前先学会走
多样原则: 绝不相信所谓"不二法门"的断言
扩展原则: 设计着眼未来，未来总比预想快

## 工程师的自我修养
### 偏执
+ 对代码细节偏执的观念，是我自己提出的新观点。在当下研发质量不高的腾讯，是很有必要普遍存在的一个观念。在一个系统不完善、时间安排荒谬、工具可笑、需求不可能实现的世界里，让我们安全行事吧。就像伍迪-艾伦说的:"当所有人都真的在给你找麻烦的时候，偏执就是一个好主意。"
对于一个方案，一个实现，请不要说出"好像这样也可以"。你一定要选出一个更好的做法，并且一直坚持这个做法，并且要求别人也这样做。既然他来让你 review 了，你就要有自己的偏执，你一定要他按照你觉得合适的方式去做。当然，你得有说服得了自己，也说服得了他人的理由。即使，只有一点点。偏执会让你的世界变得简单，你的团队的协作变得简单。特别当你身处一个编码质量低下的团队的时候。你至少能说，我是一个务实的程序员。

理性状态罢了。实际上也要看公司氛围，队友的素质等！！！！！

### 控制软件的熵是软件工程的重要任务之一
熵是个物理学概念，大家可能看过诺兰的电影《信条》。简单来说，熵可以理解为'混乱程度'。我们的项目，在刚开始的几千行代码，是很简洁的。但是，为什么到了 100w 行，我们常常就感觉'太复杂了'？比如 QQ 客户端，最近终于在做大面积重构，但是发现无数 crash。其中一个重要原因，就是'混乱程度'太高了。'混乱程度'，理解起来还是比较抽象，它有很多其他名字。'hard code 很多'、'特殊逻辑很多'、'定制化逻辑很多'。再换另一个抽象的说法，'我们面对一类问题，采取了过多的范式和特殊逻辑细节去实现它'。

熵，是一点点堆叠起来的，在一个需求的 2000 行代码更改中，你可能就引入了一个不同的范式，打破了之前的通用范式。在微观来看，你觉得你的代码是'整洁干净'的。就像一个已经穿着好看的红色风衣的人，你隔一天让他接着穿上一条绿色的裤子，这还干净整洁么？熵，在不断增加，我们需要做到以下几点，不然你的团队将在希望通过重构来降低项目的熵的时候尝到恶果，甚至放弃重构，让熵不断增长下去。

如果没有充分的理由，始终使用项目规范的范式对每一类问题做出解决方案。
如果业务发展发现老的解决方案不再优秀，做整体重构。
项目级主干开发，对重构很友好，让重构变得可行。(客户端很容易实现主干开发)。
务实地讲，重构已经不可能了。那么，你们可以谨慎地提出新的一整套范式。重建它。
禁止 hardcode，特殊逻辑。如果你发现特殊逻辑容易实现需求，否则很难。那么，你的架构已经出现问题了，你和你的团队应该深入思考这个问题，而不是轻易加上一个特殊逻辑。

### 为测试做设计
现在我们在做'测试左移'，让工程师编写自动化测试来保证质量。测试工程师的工作更多的是类似 google SET(Software Engineer In Test, 参考《google 软件测试之道》)的工作。工作重心在于测试编码规范、测试编码流程、测试编码工具、测试平台的思考和建设。测试代码，还是得工程师来做。

为方法写一个测试的考虑过程，使我们得以从外部看待这个方法，这让我们看起来是代码的客户，而不是代码的作者。很多同学，就感觉很难受。对，这是必然的。因为你的代码设计的时候，并没有把'容易测试'考虑进去，可测试性不强。如果工程师在开发逻辑的过程中，就同时思考着这段代码怎样才能轻松地被测试。那么，这段写就的代码，同时可读性、简单性都会得到保障，经过了良好的设计，而不仅仅是'能工作'。

我觉得，测试获得的主要好处发生在你考虑测试及编写测试的时候，而不是在运行测试的时候！在编码的时候同时让思考怎么测试的思维存在，会让编写高质量的代码变得简单，在编码时就更多地考虑边界条件、异常条件，并且妥善处理。仅仅是抱有这个思维，不去真地编写自动化测试，就能让代码的质量上升，代码架构的能力得到提升。

硬件工程出 bug 很难查，bug 造成的成本很高，每次都要重新做一套模具、做模具的工具。所以硬件工程往往有层层测试，极早发现问题，尽量保证简单且质量高。我们可以在软件上做同样的事情。与硬件工程师一样，从一开始就在软件中构建可测试性，并且尝试将每个部分连接在一起之前，对他们进行彻底的测试。

这个时候，有人就说，TDD 就是这样，让你同时思考编码架构和测试架构。我对 TDD 的态度是: 它不一定就是最好的。测试对开发的驱动，绝对有帮助。但是，就像每次驱动汽车一样，除非心里有一个目的地，否则就可能会兜圈子。TDD 是一种自底向上的编程方法。但是，适当的时候使用自顶向下设计，才能获得一个最好的整体架构。很多人处理不好自顶向下和自底向上的关系，结果在使用 TDD 的时候发现举步维艰、收效甚微。

以及，如果没有强大的外部驱动力，"以后再测"实际上意味着"永远不测"。大家，务实一点，在编码时就考虑怎么测试。不然，你永远没有机会考虑了。当面对着测试性低的代码，需要编写自动化测试的时候，你会感觉很难受

### 尽早测试, 经常测试, 自动测试
一旦代码写出来，就要尽早开始测试。这些小鱼的恶心之处在于，它们很快就会变成巨大的食人鲨，而捕捉鲨鱼则相当困难。所以我们要写单元测试，写很多单元测试。

事实上，好项目的测试代码可能会比产品代码更多。生成这些测试代码所花费的时间是值得的。从长远来看，最终的成本会低得多，而且你实际上有机会生产出几乎没有缺陷的产品。

另外，知道通过了测试，可以让你对代码已经"完成"产生高度信心。

### 项目中使用统一的术语
如果用户和开发者使用不同的名称来称呼相同的事物，或者更糟糕的是，使用相同的名称来代指不同的事物，那么项目就很难取得成功。

DDD(Domain-Driven Design)把'项目中使用统一的术语'做到了极致，要求项目把目标系统分解为不同的领域(也可以称作上下文)。在不同的上下文中，同一个术语名字意义可能不同，但是要项目内统一认识。比如证券这个词，是个多种经济权益凭证的统称，在股票、债券、权证市场，意义和规则是完全不同的。当你第一次听说'涡轮(港股特有金融衍生品，是一种股权)'的时候，是不是瞬间蒙圈，搞不清它和证券的关系了。买'涡轮'是在买什么鬼证劵？

在软件领域是一样的。你需要对股票、债券、权证市场建模，你就得有不同的领域，在每个领域里有一套词汇表(实体、值对象)，在不同的领域之间，同一个概念可能会换一个名字，需要映射。如果你们既不区分领域，甚至在同一个领域还对同一个实体给出不同的名字。那，你们怎么确保自己沟通到位了？写成代码，别人如何知道你现在写的'证券'这个 struct 具体是指的什么？

### 不要面向需求编程
需求不是架构；需求无关设计，也非用户界面；需求就是需要的东西。需要的东西是经常变化的，是不断被探索，不断被加深认识的。产品经理的说辞是经常变化的。当你面向需求编程，你就是在依赖一个认识每一秒都在改变的女/男朋友。你将身心俱疲。

我们应该面向业务模型编程。我在《Code Review 我都 CR 些什么》里也提到了这一点，但是我当时并没有给出应该怎么去设计业务模型的指导。我的潜台词就是，你还是仅仅能凭借自己的智力和经验，没有很多方法论工具。

现在，我给你推荐一个工具，DDD(Domain-Driven Design)，面向领域驱动设计。它能让你对业务更好地建模，让对业务建模变成一个可拆解的执行步骤，仅仅需要少得多的智力和经验。区分好领域上下文，思考明白它们之间的关系，找到领域下的实体和值对象，找到和模型贴合的架构方案。这些任务，让业务建模变得简单。

当我们面向业务模型编程，变更的需求就变成了--提供给用户他所需要的业务模型的不同部分。我们不再是在不断地 change 代码，而是在不断地 extend 代码，逐渐做完一个业务模型的填空题。

### 写代码要有对于'美'的追求
google 的很多同学说(至少 hankzheng 这么说)，软件工程=科学+艺术。当前腾讯，很多人，不讲科学。工程学，计算机科学，都不管。就喜欢搞'巧合式编程'。刚好能工作了，打完收工，交付需求。绝大多数人，根本不追求编码、设计的艺术。对细节的好看，毫无感觉。对于一个空格、空行的使用，毫无逻辑，毫无美感。用代码和其他人沟通，连基本的整洁、合理都不讲。根本没想过，别人会看我的代码，我要给代码'梳妆打扮'一下，整洁大方，美丽动人，还极有内涵。'窈窕淑女，君子好逑'，我们应该对别人慷慨一点，你总是得阅读别人的代码的。大家都对美有一点追求，就是互相都慷慨一些。

很无奈，我把对美的追求说得这么'卑微'。必须要由'务实的需要'来构建必要性。而不是每个工程师发自内心的，像对待漂亮的异性、好的音乐、好的电影一样的发自内心的需要它。认为代码也是取悦别人、取悦自己的东西。

如果我们想做一个有尊严、有格调的工程师，我们就应该把自己的代码、劳动的产物，当成一件艺术品去雕琢。务实地追求效率，同时也追求美感。效率产出价值，美感取悦自己。不仅仅是为了一口饭，同时也把工程师的工作当成自己一个快乐的源头。工作不再是 overhead，而是 happiness。此刻，你做不到，但是应该有这样的追求。当我们都有了这样的追求，有一天，我们会能像 google 一样做到的 。

### 应用程序框架是实现细节
DIP 大发神威。我觉得核心做法就是:

核心代码应该通过 DIP 来让它不要和具体框架绑定！它应该使用 DIP(比如代理类)，抽象出一个防腐层，让自己的核心代码免于腐坏。
选择一个框架，你不去做防腐层(主要通过 DIP)，你就是单方面领了结婚证，你只有义务，没有权利。同学们要想明白。同学们应该对框架本身是否优秀，是否足够组件化，它本身能否在项目里做到可插拔，做出思考和设计。
trpc-go 对于插件化这事儿，做得还不错，大家会积极地使用它。trpc-cpp 离插件化非常远，它自己根本就成不了一个插件，而是有一种要强暴你的感觉，你能凭直觉明显地感觉到不愿意和它订终身。例如，trpc-cpp 甚至强暴了你构建、编译项目的方式。当然，这很多时候是 c++语言本身的问题。

‘解耦’、'插件化’就是 golang 语言的关键词。

### 一切都应该是代码(通过代码去显式组合)
Unix 编程哲学告诉我们: 如果有一些参数是可变的，我们应该使用配置，而不是把参数写死在代码里。在腾讯，这一点做得很好。但是，大人，现在时代又变了。

J2EE 框架让我们看到，组件也可以是通过配置 Java Bean 的形式注入到框架里的。J2EE 实现了把组件也配置化的壮举。但是，时代变了！你下载一个 golang 编译器，你进入你下载的文件里去看，会发现你找不到任何配置文件。这是为什么？两个简单，但是很多年都被人们忽略的道理:

配置即隐性耦合。配置只有和使用配置的代码组合使用，它才能完成它的工作。它是通过把'一个事情分开两个步骤'来换取动态性。换句话说，它让两个相隔十万八千里的地方产生了耦合！作为工程师，你一开始就要理解双倍的复杂度。配置如何使用、配置的处理程序会如何解读配置。
代码能够有很强的自解释能力，工程师们更愿意阅读可读性强的代码，而不是编写得很烂的配置文档。配置只能通过厚重的配置说明书去解释。当你缺乏完备的配置说明书，配置变成了地狱。
golang 的编译器是怎么做的呢？它会在代码里给你设定一个通用性较强的默认配置项。同时，配置项都是集中管理的，就像管理配置文件一样。你可以通过额外配置一个配置文件或者命令行参数，来改变编译器的行为。这就变成了，代码解释了每一个配置项是用来做什么的。只有当你需要的时候，你会先看懂代码，然后，当你有需求的时候，通过额外的配置去改变一个你有预期的行为。

逻辑变成了。一开始，所有事情都是解耦的。一件事情都只看一块代码就能明白。代码有较好的自解释性和注解，不再需要费劲地编写撇脚的文档。当你明白之后，你需要不一样的行为，就通过额外的配置来实现。关于怎么配置，代码里也讲明白了。

对于 trpc-go 框架，以及一众插件，优先考虑配置，然后才是代码去指定，部分功能还只能通过配置去指定，我就很难受。我接受它，就得把一个事情放在两个地方去完成:

需要在代码里 import 插件包。
需要在配置文件里配置插件参数。
既然不能消灭第一步，为什么不能是显式 import，同时通过代码+其他自定义配置管理方案去完成插件的配置？当然，插件，直接不需要任何配置，提供代码 Option 去改变插件的行为，是最香的。这个时候，我就真的能把 trpc 框架本身也当成一个插件来使用了。

### 封装不一定是好的组织形式
封装(Encapsulation)，是我上学时刚接触 OOP，惊为天人的思想方法。但是，我工作了一些年头了，看过了不知道多少腐烂的代码。其中一部分还需要我来维护。我看到了很多莫名其妙的封装，让我难受至极。封装，经常被滥用。封装的时候，我们一定要让自己的代码，自己就能解释自己是按照下面的哪一种套路在做封装:

按层封装
按功能封装
按领域封装
按组件封装
或者，其他能被命名到某种有价值的类型的封装。你要能说出为什么你的封装是必要的，有价值的。必要的时候，你必须要封装。比如，当你的 golang 函数达到了 80 行，你就应该对逻辑分组，或者把一块过于细节化却功能单一的较长的代码独立到一个函数。同时，你又不能胡乱封装，或者过度封装。是否过度，取决于大家的共识，要 reviwer 能认可你这个封装是有价值的。当然，你也会成为 reviewer，别人也需要获得你的认可。缺乏意图设计的封装，是破坏性的。这会使其他人在面对这段代码时，畏首畏尾，不敢修改它。形成一个腐烂的肉块，并且，这种腐烂会逐渐蔓延开来。

所以，所有细节都是关键的。每一块砖头都被精心设计，才能构建一个漂亮的项目！

### 所有细节都应该被显式处理

这是一个显而易见的道理。但是很多同学却毫无知觉。我为需要深入阅读他们编写的代码的同学默哀一秒。当有一个函数 func F() error，我仅仅是用 F()，没有用变量接收它的返回值。你阅读代码的时候，你就会想，第一开发者是忘记了 error handling 了，还是他思考过了，他决定不关注这个返回值？他是设计如此，还是这里是个 bug？他人即地狱，维护代码的苦难又多了一分。

我们对于自己的代码可能会给别人带来困扰的地方，都应该显式地去处理。就像写了一篇不会有歧义的文章。如果就是想要忽略错误，'_ = F()'搞定。我将来再处理错误逻辑，'_ = F() // TODO 这里需要更好地处理错误'。在代码里，把事情讲明白，所有人都能快速理解他人的代码，就能快速做出修改的决策。'猜测他人代码的逻辑用意'是很难受且困难的，他人的代码也会在这种场景下，产生被误读。

## 不能上升到原则的一些常见案例
### 合理注释一些并不'通俗'的逻辑和数值
和'所有细节都应该被显式处理'一脉相承。所有他人可能要花较多时间猜测原因的细节，都应该在代码里提前清楚地讲明白。
### 习惯留下 TODO
要这么做的道理很简单。便于所有人能接着你开发。极有可能就是你自己接着自己开发。如果没有标注 TODO 把没有做完的事情标示出来。可能，你自己都会搞忘自己有事儿没做完了。留下 TODO 是很简单的事情，我们为什么不做呢？

### 不要丢弃错误信息
即'错误传递原则'。这里给它换个名字--你不应该主动把很多有用的信息给丢弃了。
### 自动化测试要快
在 google，自动化测试是硬性要求在限定时间内跑完的。这从细节上保障了自动化测试的速度，进而保障了自动化测试的价值和可用性。你真的需要 sleep 这么久？应该认真考量。考量清楚了把原因写下来。当大家发现总时长太长的时候，可以选择其中最不必要的部分做优化。
### 历史有问题的代码, 发现了问题要及时 push 相关人主动解决
这是'控制软件的熵是软件工程的重要任务之一'的表现之一。我们是团队作战，不是无组织无记录的部队。发现了问题，就及时抛出和解决。让伤痛更少，跑得更快。

### less is more
### 如果打了错误日志, 有效信息必须充足, 且不过多
### 注释要把问题讲清楚, 讲不清楚的日志等于没有
### MR 要自己先 review, 不要浪费 reviewer 的时间
你也会成为 reviewer，节省他人的时间，他人也节省你的时间。缩短交互次数，提升 review 的愉悦感。让他人提的 comment 都是'言之有物'的东西，而不是一些反反复复的最基础的细节。会让他人更愉悦，自己在看 comment 的时候，也更愉悦，更愿意去讨论、沟通。让 code review 成为一个技术交流的平台。
### 要寻找合适的定语
### 不要出现特定 IP,或者把什么可变的东西写死
### 使用定语, 不要 1、2、3、4
### 有必要才使用 init
### 要关注 shadow write
### 能不耦合接收器就别耦合
### 空实现需要注明空实现就是实现
### 看错题集没多少有用, 我们需要教练和传承
上面我列了很多例子。是我能列出来的例子中的九牛一毛。但是，我列一个非常庞大的错题集没有任何用。我也不再例举更多。只有当大家信奉了敏捷工程的美。认可好的代码架构对于业务的价值，才能真正地做到举一反三，理解无数例子，能对更多的 case 自己做出合理的判断。同时，把好的判断传播起来，做到"群体免疫"，最终做好 review，做好代码质量。
### 展望
希望本文能帮助到需要做好 CR、做好编码，需要培养更多 reviwer 的团队。让你门看到很多原则，吸收这些原则和理念。去理解、相信这些理念。在 CR 中把这些理念、原则传播出去。成为别人的临时教练，让大家都成为合格的 reviwer。加强对于代码的交流，飞轮效应，让团队构建好的人才梯度和工程文化。

写到最后，我发现，我上面写的这些东西都不那么重要了。你有想把代码写得更利于团队协作的价值观和态度，反而是最重要的事情。上面讲的都仅仅是写高质量代码的手段和思想方法。当你认可了'应该编写利于团队协作的高质量代码'，并且拥有对'不利于团队代码质量的代码'嫉恶如仇的态度。你总能找到高质量代码的写法。没有我帮你总结，你也总会掌握！
### 拾遗
如果你深入了解 DDD，就会了解到'六边形架构'、'CQRS(Command Query Responsibility Segregation，查询职责分离)架构'、'事件驱动架构'等关键词。这是 DDD 构建自己体系的基石，这些架构及是细节又是顶层设计，也值得了解一下。


---

+ 如何更酷地实现 Go 程序热开关功能:<https://mp.weixin.qq.com/s/Vk-rmlA_rC4SxP313UQSZw>
   - 通过linux信号通知程序

+ 在Go中如何正确重试请求：<https://mp.weixin.qq.com/s/GKggVplX_ZzoXJDuWf5ctA> !!

+ Go中的HTTP debug技能 了解一下:<https://mp.weixin.qq.com/s/lHPK8Mtxf-7z81VEJxrplw>
   - 1.将包含钩子函数的 httptrace.ClientTrace 放入request的context中进行跟踪；
   - 2.对http.Client进行跟踪，使用 http.RoundTripper wrapper 来标识当前的请求


----

+ test/goweb/09.advanced-middleware/middleware.go


-----


在 Go 的标准库中，`sync.Map` 提供了一种并发安全的 Map，不会在写入时阻塞读取操作。它是 Go 1.9 版本引入的，适用于高度并发的读写场景。

`sync.Map` 内部实现了一种特殊的并发安全算法，可以在写入时不阻塞读取操作，从而避免了传统的互斥锁带来的性能问题。

使用 `sync.Map` 的示例代码如下：

```go
import (
	"sync"
)

var myMap sync.Map

// 并发安全的读取map
func safeRead(key string) int {
	val, _ := myMap.Load(key)
	if v, ok := val.(int); ok {
		return v
	}
	return 0
}

// 并发安全的写入map
func safeWrite(key string, value int) {
	myMap.Store(key, value)
}
```

在 `sync.Map` 中，`Load()` 用于读取键值对，`Store()` 用于存储键值对。在写入时，不会阻塞并发读取操作，因此可以实现在写入时不阻塞读取的需求。

需要注意的是，`sync.Map` 并不支持直接遍历所有键值对，也没有提供类似 `len()` 方法来获取元素数量。因此，如果需要遍历所有元素或者获取元素数量，可能需要使用其他数据结构。但对于纯粹的读写操作，`sync.Map` 是一个非常高效和方便的并发安全 Map 实现。


对map写时，读不加锁会导致什么问题吗

当在写入`map`时，不对读操作进行加锁可能会导致数据不一致或者产生未定义的行为。这种情况下，通常会发生以下两种问题：

1. 数据竞争：多个goroutine同时对`map`进行读写操作，没有同步控制，可能导致数据竞争。数据竞争会导致`map`中的值变得不可预测，可能导致程序崩溃或产生错误的结果。

2. 内存不一致：在写入操作期间，可能只写了`map`的部分数据，而其他goroutine可能会在此期间进行读取操作，导致读取到不一致的数据。这可能会使得读取的数据不完整或者包含错误的信息。

因此，为了保证数据的一致性和并发安全，对于存在并发读写的`map`，需要使用互斥锁（如`sync.Mutex`或`sync.RWMutex`）来进行读写操作的同步控制。在写入时加锁，以确保写操作的原子性和数据完整性；在读取时加锁（读写锁中的读锁），以确保在写入时不会读取到不一致的数据。

在使用`sync.Map`时，内部已经实现了并发安全的读写机制，所以不需要手动加锁。但对于普通的`map`，需要自己处理并发读写的同步控制，以避免上述问题。

-----

