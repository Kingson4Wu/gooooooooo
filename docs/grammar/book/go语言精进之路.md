# 一部分 熟知Go语言的一切

## 3条 理解Go语言的设计哲学

### 3.1　追求简单，少即是多
正如Go语言之父Rob Pike所说：“Go语言实际上是复杂的，但只是让大家感觉很简单。”这句话背后的深意就是“简单”选择的背后是Go语言自身实现层面的复杂性，而这种复杂性被Go语言的设计者“隐藏”起来了。比如并发是复杂的，但我们通过一个简单的关键字“go”就可以实现。这种简单其实是Go开发团队缜密设计和持续付出的结果。

### 3.2　偏好组合，正交解耦
Go语言本质上就不属于经典OO语言范畴。针对这种情况，很多人会问：那Go语言是如何将程序的各个部分有机地耦合在一起的呢？就像上面引述的Douglas McIlroy那句话中的浇水软管那样，Go语言遵从的设计哲学也是组合。
Go采用了组合的方式，也是唯一的方式。

Go语言提供的最为直观的组合的语法元素是类型嵌入（type embedding）。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。这种方式有些类似经典OO语言中的继承机制，但在原理上与其完全不同，这是一种Go设计者们精心设计的语法糖。被嵌入的类型和新类型之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典OO语言中的那种父类、子类的关系以及向上、向下转型（type casting）。在通过新类型实例调用方法时，方法的匹配取决于方法名字，而不是类型。这种组合方式，笔者称之为“垂直组合”，即通过类型嵌入，快速让一个新类型复用其他类型已经实现的能力，实现功能的垂直扩展。


```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}
    shared  []interface{}
    Mutex
    pad     [128]byte
}
```
我们在poolLocal这个结构体类型中嵌入了类型Mutex，被嵌入的Mutex类型的方法集合会被提升到外面的类型（poolLocal）中。比如，这里的poolLocal将拥有Mutex类型的Lock和Unlock方法。但在实际调用时，方法调用会被传给poolLocal中的Mutex实例。

我们在标准库中还经常看到如下的interface类型嵌入的代码：

```go

// $GOROOT/src/io/io.go
type ReadWriter interface {
    Reader
    Writer
}
```

通过在interface的定义中嵌入interface类型来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为Go语言的一种惯用法。

interface是Go语言中真正的“魔法”，是Go语言的一个创新设计，它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的interface实现会不经意间满足依赖抽象、里氏替换、接口隔离等设计原则，这在其他语言中是需要很刻意的设计谋划才能实现的，但在Go interface看来，一切却是自然而然的。

通过interface将程序各个部分组合在一起的方法，笔者称之为“水平组合”。水平组合的模式有很多，一种常见的方法是通过接受interface类型参数的普通函数进行组合，例如下面的代码。

```go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```

函数ReadAll通过io.Reader这个接口将io.Reader的实现与ReadAll所在的包以低耦合的方式水平组合在一起了。类似的水平组合模式还有wrapper、middleware等

此外，Go语言内置的并发能力也可以通过组合的方式实现对计算能力的串联，比如通过goroutine+channel的组合实现类似Unix Pipe的能力。

综上，组合原则的应用塑造了Go程序的骨架结构。类型嵌入为类型提供垂直扩展能力，interface是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。组合也让遵循简单原则的Go语言在表现力上丝毫不逊色于复杂的主流编程语言。

### 3.3　原生并发，轻量高效
将面向多核、原生内置并发支持作为新语言的设计原则之一

Go语言原生支持并发的设计哲学体现在以下几点。
（1）Go语言采用轻量级协程并发模型，使得Go应用在面向多核硬件时更具可扩展性

提到并发执行与调度，我们首先想到的就是操作系统对进程、线程的调度。操作系统调度器会将系统中的多个线程按照一定算法调度到物理CPU上运行。传统编程语言（如C、C++等）的并发实现实际上就是基于操作系统调度的，即程序负责创建线程（一般通过pthread等函数库调用实现），操作系统负责调度。这种传统支持并发的方式主要有两大不足：复杂和难于扩展。

复杂主要体现在以下方面。
创建容易，退出难：使用C语言的开发人员都知道，创建一个线程时（比如利用pthread库）虽然参数也不少，但还可以接受。而一旦涉及线程的退出，就要考虑线程是不是分离的（detached）？是否需要父线程去通知并等待子线程退出（join）？是否需要在线程中设置取消点（cancel point）以保证进行join操作时能顺利退出？
并发单元间通信困难，易错：多个线程之间的通信虽然有多种机制可选，但用起来相当复杂；并且一旦涉及共享内存（shared memory），就会用到各种锁（lock），死锁便成为家常便饭。
线程栈大小（thread stack size）的设定：是直接使用默认的，还是设置得大一些或小一些呢？难于扩展主要体现在以下方面。

虽然线程的代价比进程小了很多，但我们依然不能大量创建线程，因为不仅每个线程占用的资源不小，操作系统调度切换线程的代价也不小。
对于很多网络服务程序，由于不能大量创建线程，就要在少量线程里做网络的多路复用，即使用epoll/kqueue/IoCompletionPort这套机制。即便有了libevent、libev这样的第三方库的帮忙，写起这样的程序也是很不容易的，存在大量回调（callback），会给程序员带来不小的心智负担。

为了解决这些问题，Go果断放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程或者说是类协程（coroutine），Go将之称为goroutine。goroutine占用的资源非常少，Go运行时默认为每个goroutine分配的栈空间仅2KB。goroutine调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，在一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是Go的运行时代码也不例外。

不过，一个Go程序对于操作系统来说只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠Go自己完成，实现Go程序内goroutine之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些goroutine按照一定算法放到CPU上执行的程序就称为goroutine调度器（goroutine scheduler）。

（2）Go语言为开发者提供的支持并发的语法元素和机制

我们先来看看那些设计并诞生于单核年代的编程语言（如C、C++、Java）在语法元素和机制层面是如何支持并发的。执行单元：线程。
创建和销毁的方式：调用库函数或调用对象方法。并发线程间的通信：多基于操作系统提供的IPC机制，比如共享内存、Socket、Pipe等，当然也会使用有并发保护的全局变量。
与上述传统语言相比，Go提供了语言层面内置的并发语法元素和机制。执行单元：goroutine

创建和销毁方式：go+函数调用；函数退出即goroutine退出。并发goroutine的通信：通过语言内置的channel传递消息或实现同步，并通过select实现多路channel的并发控制。对比来看，Go对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。

(3）并发原则对Go开发者在程序结构设计层面的影响

由于goroutine的开销很小（相对线程），Go官方鼓励大家使用goroutine来充分利用多核资源。但并不是有了goroutine就一定能充分利用多核资源，或者说即便使用Go也不一定能写出好的并发程序。

Rob Pike认为：并发是有关结构的，它是一种将一个程序分解成多个小片段并且每个小片段都可以独立执行的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作。并行是有关执行的，它表示同时进行一些计算任务。以上观点的重点是，并发是一种程序结构设计的方法，它使并行成为可能。

并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的。
除此之外，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计层面对程序进行拆解组合，再映射到程序执行层面：goroutine各自执行特定的工作，通过channel+select将goroutine组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让Go语言更适应现代计算环境。


### 3.4　面向工程，“自带电池”

软件工程指引着Go语言的设计。——Rob Pike（2012）

要想理解这条设计哲学，我们依然需要回到三位Go语言之父在设计Go语言时的初衷：面向真实世界中Google内部大规模软件开发存在的各种问题，为这些问题提供答案。主要的问题包括：

程序构建慢；
失控的依赖管理；
开发人员使用编程语言的不同子集（比如C++支持多范式，这样有些人用OO，有些人用泛型）；
代码可理解性差（代码可读性差、文档差等）；
功能重复实现；
升级更新消耗大；
实现自动化工具难度高；
版本问题；
跨语言构建问题。

很多编程语言的设计者或拥趸认为这些问题并不是编程语言应该解决的，但Go语言的设计者并不这么看，他们以更高、更广阔的视角审视软件开发领域尤其是大规模软件开发过程中遇到的各种问题，并在Go语言最初设计阶段就将解决工程问题作为Go的设计原则之一去考虑Go语法、工具链与标准库的设计，这也是Go与那些偏学院派、偏研究性编程语言在设计思路上的一个重大差异。

Go语言取得阶段性成功后，这种思路开始影响后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴Go的一些设计，比如越来越多的语言认可统一代码风格的优越之处，并开始提供官方统一的fmt工具（如Rust的rustfmt），又如Go创新提出的最小版本选择（Minimal Version Selection，MVS）被其他语言的包依赖工具所支持（比如Rust的cargo支持MVS）。

Go设计者将所有工程问题浓缩为一个词：scale（笔者总觉得将scale这个词翻译为任何中文词都无法传神地表达其含义，暂译为“规模”吧）。从Go1开始，Go的设计目标就是帮助开发者更容易、更高效地管理两类规模。

生产规模：用Go构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数量等。
开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等。
Go设计者期望Go可以游刃有余地应对生产规模和开发规模变大带来的各种复杂问题。Go语言的演进方向是优化甚至消除Go语言自身面对规模化问题时应对不好的地方，比如：Go 1.9引入类型别名（type alias）以应对大型代码仓库代码重构，Go 1.11引入go module机制以解决不完善的包依赖问题等。这种设计哲学的落地让Go语言具有广泛的规模适应性：既可以被仅有5人的初创团队用于开发终端工具，也能够满足像Google这样的巨型公司大规模团队开发大规模网络服务程序的需要。

### 小结
简单是Go语言贯穿语言设计和应用的主旨设计哲学。德国建筑大师路德维希·密斯·凡德罗将“少即是多”这一哲学理念应用到建筑设计当中后取得了非凡的成功，而Go语言则是这一哲学在编程语言领域为数不多的践行者。“少”绝不是目的，“多”才是其内涵。Go在语言层面的简单让Go收获了不逊于C++/Java等的表现力的同时，还获得了更好的可读性、更高的开发效率等在软件工程领域更为重要的元素。

“高内聚、低耦合”是软件开发领域亘古不变的管理复杂性的准则。Go在语言设计层面也将这一准则发挥到极致。Go崇尚通过组合的方式将正交的语法元素组织在一起来形成应用程序骨架，接口就是在这一哲学下诞生的语言精华。

不同于C、C++、Java等诞生于20世纪后段的面向单机的编程语言，Go语言是面向未来的。Go设计者对硬件发展趋势做出了敏锐且准确的判断——多核时代是未来主流趋势，于是将并发作为语言的“一等公民”，提供了内置于语言中的简单并发原语——go（goroutine）、channel和select，大幅降低了开发人员在云计算多核时代编写大规模并发网络服务程序时的心智负担。

Go生来就肩负着解决面向软件工程领域问题的使命，我们看到的开箱即用的标准库、语言自带原生工具链以及开放的工具链生态的建立都是这一使命落地的结果，Go在面向工程领域的探索也引领着编程语言未来发展的潮流。

## 第4条　使用Go语言原生编程思维来写Go代码

### 4.1　语言与思维——来自大师的观点
在人类自然语言学界有一个很著名的假说——“萨丕尔-沃夫假说”，这个假说的内容是这样的：“语言影响或决定人类的思维方式。”

在编程语言界，有位大师级人物也有着与“萨丕尔-沃夫假说”异曲同工的观点和认知，他就是首届图灵奖得主、著名计算机科学家艾伦·佩利（Alan J. Perlis），他从另外一个角度提出：“不能影响到你的编程思维方式的编程语言不值得学习和使用。”

### 4.2　现实中的“投影”
简单的编程问题——素数筛。
问题描述：素数是一个自然数，它具有两个截然不同的自然数除数：1和它本身。这里的问题是如何找到小于或等于给定整数n的素数。针对这个问题，我们可以采用埃拉托斯特尼素数筛算法。
算法描述：先用最小的素数2去筛，把2的倍数筛除；下一个未筛除的数就是素数（这里是3）。再用这个素数3去筛，筛除3的倍数……这样不断重复下去，直到筛完为止（算法图示见图4-1）。

（1）C语言版本

```C
// chapter1/sources/sieve.c

#include <stdio.h>

#define LIMIT  50
#define PRIMES 10

void sieve() {
    int c, i,j,numbers[LIMIT], primes[PRIMES];

    for (i=0;i<LIMIT;i++){
        numbers[i]=i+2; /*fill the array with natural numbers*/
    }
    for (i=0;i<LIMIT;i++){
        if (numbers[i]!=-1){
            for (j=2*numbers[i]-2;j<LIMIT;j+=numbers[i])
                numbers[j]=-1; /* 筛除非素数 */
        }
    }
    c = j = 0;
    for (i=0;i<LIMIT&&j<PRIMES;i++) {
        if (numbers[i]!=-1) {
            primes[j++] = numbers[i]; /*transfer the primes to their own array*/
            c++;
        }
    }
    for (i=0;i<c;i++) printf("%d\n",primes[i]);
}
```

（2）Haskell版本

```haskell
// chapter1/sources/sieve.hs

sieve [] = []
sieve (x:xs) = x : sieve (filter (\a -> not $ a `mod` x == 0) xs)

n = 100
main = print $ sieve [2..n]
```

（3）Go语言版本

```go
// chapter1/sources/sieve.go

func Generate(ch chan<- int) {
    for i := 2; ; i++ {
        ch <- i
    }
}

func Filter(in <-chan int, out chan<- int, prime int) {
    for {
        i := <-in
        if i%prime != 0 {
            out <- i
        }
    }
}

func main() {
    ch := make(chan int)
    go Generate(ch)
    for i := 0; i < 10; i++ {
        prime := <-ch
        print(prime, "\n")
        ch1 := make(chan int)
        go Filter(ch, ch1, prime)
        ch = ch1
    }
}
```

https://go.dev/play/p/9U22NfrXeq

对比上述三个语言版本的素数筛算法的实现，我们看到：
C版本的素数筛程序是一个常规实现。它定义了两个数组numbers和primes，“筛”的过程在numbers这个数组中进行（基于纯内存修改），非素数的数组元素被设置为-1，便于后续提取。Haskell版本采用了函数递归的思路，通过“filter操作集合”，用谓词（过滤条件）\a -> not $ a `mod` x == 0筛除素数的倍数，将未筛除的数的集合作为参数传递归递给下去。Go版本程序实现了一个并发素数筛，它采用的是goroutine的并发组合。程序从素数2开始，依次为每个素数建立一个goroutine，用于作为筛除该素数的倍数。ch指向当前最新输出素数所位于的筛子goroutine的源channel。这段代码来自Rob Pike的一次关于并发的分享[1]。Go版本程序的执行过程可以用图4-2立体地展现出来。

### 4.3　Go语言原生编程思维
面对同一个问题，来自不同编程语言的程序员给出了思维方式截然不同的解决方法：C的命令式思维、Haskell的函数式思维和Go的并发思维。结合“萨丕尔—沃夫假说”，我们可以得到一个未经理论证实但又确实对现实有影响的推论：编程语言影响编程思维，或者说每种编程语言都有属于自己的原生编程思维。

Go语言诞生较晚，大多数Gopher（包括笔者在内）的第一语言并不是Go，而是“半路出家”从其他语言（如C、C++、Java、Python等）转过来的。每种语言都有自己的原生编程思维。比如：C语言相信程序员，提供了指针和指针运算，让C程序员天马行空地发挥，接近底层的直接内存操作让C程序拥有很高的性能；C++支持多范式（命令式、OO和泛型），虽不强迫程序员使用某个特定的范式，但推荐使用最新代表现代语言发展特色的泛型等高级范式；Python语言更是形成了Pythonic规则来指导Python程序员写出符合Python思维或惯用法的代码。经验告诉我们，但凡属于某个编程语言的高质量范畴的代码，其必定是在这种编程语言原生思维下编写的代码。

如果用A语言的思维去编写B语言的代码（比如用OO思维写C代码，用命令式的思维写Haskell代码等），那么你写出的代码多半无法被B语言社区所认可，更难以成为高质量代码的典范。并且，如果沿着这样的方向去学习和实践B语言，那么结果只能是南辕北辙，与编写出高质量代码的目标渐行渐远。

我们的目标是编写出高质量的Go代码，这就需要我们在学习语言的同时，不断学习Go语言原生的编程思维，时刻用Go编程思维考虑Go代码的设计和实现，这是通往高质量Go代码的必经之路。


### 小结
人类在通过自然语言交流和表达观点的漫长过程中，逐渐形成了固定的语言表述方法。除此之外，人类还利用肢体动作、眼神、表情、纸笔等辅助行为或工具来帮助语言的精确表达，并且在使用这些辅助行为和工具时形成了固定的使用方法，这些以这门语言为中心的固定的表述方法、辅助行为和工具用法总称为这门语言的惯用法，它们反映的就是该语言的思维方式。

编程语言也类似，以一门编程语言为中心的，以解决工程问题为目标的编程语言用法、辅助库、工具的固定使用方法称为该门编程语言的原生编程思维。

我们学习和使用一门编程语言，目标是用这门语言的原生思维方式编写高质量代码。学习Go，就要用Go的原生编程思维而不是用其他语言的思维方式写Go代码。掌握Go原生编程思维就是我们通往高质量Go编程的学习方向和必经之路，因此本书后面将从语言、标准库、工具链、工程实践等方面来全面介绍Go语言的原生编程思维，帮助大家打好编写高质量Go代码的基础。


---

# 第二部分　项目结构、代码风格与标识符命名

## 第5条　使用得到公认且广泛使用的项目结构

### 1. Go项目结构的最小标准布局

Go语言项目的技术负责人，Russ Cox在一个开源项目的issue中给出了他关于Go项目结构的最小标准布局[1]的想法。他认为Go项目的最小标准布局应该是这样的：

<pre>
// 在Go项目仓库根路径下

- go.mod
- LICENSE
- xx.go
- yy.go
...
</pre>
或
<pre>
- go.mod
- LICENSE
- package1
        - package1.go
- package2
        - package2.go
...
</pre>

pkg、cmd、docs这些目录不应该成为Go项目标准结构的一部分，至少不是必需的。笔者认为Russ Cox给出的最小标准布局与Go一贯崇尚的“简单”哲学是一脉相承的，这个布局很灵活，可以满足各种Go项目的需求。

非官方标准的建议结构布局

### 2. 以构建二进制可执行文件为目的的Go项目结构
一个支持（在cmd下）构建二进制可执行文件的典型Go项目的结构，我们分别来看一下各个重要目录的用途。

cmd目录：存放项目要构建的可执行文件对应的main包的源文件。如果有多个可执行文件需要构建，则将每个可执行文件的main包单独放在一个子目录中，比如图中的app1、app2。cmd目录下的各app的main包将整个项目的依赖连接在一起，并且通常来说，main包应该很简洁。我们会在main包中做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。有一些Go项目将cmd这个名字改为app，但其功用并没有变。

pkg目录：存放项目自身要使用并且同样也是可执行文件对应main包要依赖的库文件。该目录下的包可以被外部项目引用，算是项目导出包的一个聚合。有些项目将pkg这个名字改为lib，但该目录的用途不变。由于Go语言项目自身在1.4版本中去掉了pkg这一层目录，因此有一些项目直接将包平铺到项目根路径下，但笔者认为对于一些规模稍大的项目，过多的包会让项目顶层目录不再简洁，显得很拥挤，因此个人建议对于复杂的Go项目保留pkg目录。

Makefile：这里的Makefile是项目构建工具所用脚本的“代表”，它可以代表任何第三方构建工具所用的脚本。Go并没有内置如make、bazel等级别的项目构建工具，对于一些规模稍大的项目而言，项目构建工具似乎不可缺少。在Go典型项目中，项目构建工具的脚本一般放在项目顶层目录下，比如这里的Makefile；对于构建脚本较多的项目，也可以建立build目录，并将构建脚本的规则属性文件、子构建脚本放入其中。

go.mod和go.sum：Go语言包依赖管理使用的配置文件。Go 1.11版本引入Go module机制，Go 1.16版本中，Go module成为默认的依赖包管理和构建机制。因此对于新的Go项目，建议基于Go module进行包依赖管理。对于没有使用Go module进行包管理的项目（可能主要是一些使用Go 1.11以前版本的Go项目），这里可以换为dep的Gopkg.toml和Gopkg.lock，或者glide的glide.yaml和glide.lock等。

vendor目录（可选）：vendor是Go 1.5版本引入的用于在项目本地缓存特定版本依赖包的机制。在引入Go module机制之前，基于vendor可以实现可重现的构建（reproducible build），保证基于同一源码构建出的可执行程序是等价的。Go module本身就可以实现可重现的构建而不需要vendor，当然Go module机制也保留了vendor目录（通过go mod vendor可以生成vendor下的依赖包；通过go build -mod=vendor可以实现基于vendor的构建），因此这里将vendor目录视为一个可选目录。一般我们仅保留项目根目录下的vendor目录，否则会造成不必要的依赖选择的复杂性。

Go 1.11引入的module是一组同属于一个版本管理单元的包的集合。Go支持在一个项目/仓库中存在多个module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。因此，如果项目结构中存在版本管理的“分歧”，比如app1和app2的发布版本并不总是同步的，那么笔者建议将项目拆分为多个项目（仓库），每个项目单独作为一个module进行版本管理和演进。

### 3. 以只构建库为目的的Go项目结构

库类型项目结构与Go项目的最小标准布局也是兼容的，但比以构建二进制可执行文件为目的的Go项目要简单一些。

去除了cmd和pkg两个子目录：由于仅构建库，没必要保留存放二进制文件main包源文件的cmd目录；由于Go库项目的初衷一般都是对外部（开源或组织内部公开）暴露API，因此也没有必要将其单独聚合到pkg目录下面了。

vendor不再是可选目录：对于库类型项目而言，不推荐在项目中放置vendor目录去缓存库自身的第三方依赖，库项目仅通过go.mod（或其他包依赖管理工具的manifest文件）明确表述出该项目依赖的模块或包以及版本要求即可。

### 4. 关于internal目录

无论是上面哪种类型的Go项目，对于不想暴露给外部引用，仅限项目内部使用的包，在项目结构上可以通过Go 1.4版本中引入的internal包机制来实现。以库项目为例，最简单的方式就是在顶层加入一个internal目录，将不想暴露到外部的包都放在该目录下，比如下面项目结构中的ilib1、ilib2

<pre>
// 带internal的Go库项目结构

$tree -F ./chapter2/sources/GoLibProj
GoLibProj
├── LICENSE
├── Makefile
├── README.md
├── go.mod
├── internal/
│  ├── ilib1/
│  └── ilib2/
├── lib.go
├── lib1/
│  └── lib1.go
└── lib2/
      └── lib2.go
</pre>

这样，根据Go internal机制的作用原理，internal目录下的ilib1、ilib2可以被以GoLibProj目录为根目录的其他目录下的代码（比如lib.go、lib1/lib1.go等）所导入和使用，但是却不可以为GoLibProj目录以外的代码所使用，从而实现选择性地暴露API包。当然internal也可以放在项目结构中的任一目录层级中，关键是项目结构设计人员明确哪些要暴露到外层代码，哪些仅用于同级目录或子目录中。

对于以构建二进制可执行文件类型为目的的项目，我们同样可以将不想暴露给外面的包聚合到项目顶层路径下的internal下，与暴露给外部的包的聚合目录pkg遥相呼应。

### 小结
以上两个针对构建二进制可执行文件类型以及库类型的项目参考结构是Go社区在多年实践后得到公认且使用较为广泛的项目结构，并且它们与Russ Cox提出的Go项目最小标准布局是兼容的，对于稍大型的Go项目来说很有参考价值。

上述参考项目结构与产品设计开发领域的最小可行产品（Minimum Viable Product，MVP）的思路异曲同工，开发者可以在这样一个最小的项目结构核心的基础上根据实际需要进行扩展。


## 第6条　提交前使用gofmt格式化源码

### 6.1　gofmt：Go语言在解决规模化问题上的最佳实践
gofmt的代码风格不是某个人的最爱，而是所有人的最爱。——Rob Pike

gofmt代码风格已经成为Go开发者的共识，融入Go语言的开发文化当中，以至于多数Go开发者可能说不出gofmt代码风格是什么样的，因为代码会被gofmt自动变成那种风格，大家已经不再关心风格。gofmt是Go语言在解决规模化问题上的一个最佳实践，并成为Go语言吸引其他语言开发者的一大亮点。很多主流语言在效仿Go语言而推出自己的格式化工具

### 6.2　使用gofmt
gofmt最大的特点是没有提供任何关于代码风格设置的命令行选项和参数，这样Go开发人员就无法通过设置命令行特定选项来定制自己喜好的风格。不过gofmt却提供了足够在工程上对代码进行按格式查找、代码重构的命令行选项。

1. 使用gofmt -s选项简化代码
后续版本语法升级、或者简单写法等
2. 使用gofmt -r执行代码“微重构”
代码重构是软件工程过程中的日常操作，Go语言曾经为了支持大规模软件的全局重构加入了类型别名（type alias）语法。gofmt除了具有格式化代码的功能外，对代码重构也具有一定的支撑能力。我们可以通过-r命令行选项对代码进行表达式级别的替换，以达到重构的目的。

```bash
$gofmt -r 'a[3:len(a)] -> a[3:]' -w chapter2/sources/gofmt_demo.go
```
上述命令中的a并不是一个具体的字符，而是代表的一个通配符。出现在'pattern -> replacement'中的小写字母都会被视为通配符

3. 使用gofmt -l按格式要求输出满足条件的文件列表

### 6.3　使用goimports
goimports在gofmt功能的基础上增加了对包导入列表的维护功能，可根据源码的最新变动自动从导入包列表中增删包。

### 6.4　将gofmt/goimports与IDE或编辑器工具集成

## 第7条　使用Go命名惯例对标识符进行命名
计算机科学中只有两件难事：缓存失效和命名。——Phil Karlton，Netscape架构师

Go的设计哲学之一就是追求简单，它在命名上一样秉承着简单的总体原则。但简单并不意味着一味地为标识符选择短小的名字，而是要选择那种可以在标识符所在上下文中保持其用途清晰明确的名字。Go及其标准库的实现是Go命名惯例形成的源头，因此如果要寻找良好命名的示范，Go标准库是一个不错的地方。本条中的示例主要来自Go标准库代码，一些结论来自对标准库代码的分析。

要想做好Go标识符的命名（包括对包的命名），至少要遵循两个原则：简单且一致；利用上下文辅助命名。

### 7.1　简单且一致

对于简单，我们最直观的理解就是“短小”，但这里的简单还包含着清晰明确这一前提。短小意味着能用一个单词命名的，就不要使用单词组合；能用单个字母（在特定上下文中）表达标识符用途的，就不用完整单词。甚至在某种情况下，Go命名惯例选择了简洁命名+注释辅助解释的方式，而不是一个长长的名字。

1. 包对于Go中的包（package），一般建议以小写形式的单个单词命名。

Go语言建议，包名应尽量与包导入路径（import path）的最后一个路径分段保持一致。比如：包导入路径golang.org/x/text/encoding的最后路径分段是encoding，该路径下包名就应该为encoding。

但在实际情况中，包名与导入路径最后分段不同的也有很多。比如：实时分布式消息队列NSQ的官方客户端包的导入路径为github.com/nsqio/go-nsq，但是该路径下面的包名却是nsq。笔者分析这主要是为了用仓库名称强调该实现是针对Go语言的，比如go-nsq的意义是这是一份Go语言实现的NSQ客户端API库，为的是与nsq-java、pynsq、rust-nsq等其他语言的客户端API进行显式区分。

那如果将NSQ的Go客户端API放入github.com/nsqio/go-nsq/nsq下是否更理想呢？显然在导入路径中出现两次“nsq”字样的这种“口吃”现象也是不被Go官方推荐的。

我们在给包命名的时候，不仅要考虑包自身的名字，还要兼顾该包导出的标识符（如变量、常量、类型、函数等）的命名。由于对这些包导出标识符的引用必须以包名为前缀，因此对包导出标识符命名时，在名字中不要再包含包名

<pre>
strings.Reader              [good]
strings.StringReader        [bad]
strings.NewReader           [good]
strings.NewStringReader     [bad]

bytes.Buffer                [good]
bytes.ByteBuffer            [bad]
bytes.NewBuffer             [good]
bytes.NewByteBuffer         [bad]
</pre>


2. 变量、类型、函数和方法
Go语言官方要求标识符命名采用驼峰命名法（CamelCase），以变量名为例，如果变量名由一个以上的词组合构成，那么这些词之间紧密相连，不使用任何连接符（如下划线）。

不过如果缩略词的首字母是大写的，那么其他字母也要保持全部大写，比如HTTP（Hypertext Transfer Protocol）

我们看到了大量单字母的标识符命名，这是Go在命名上的一个惯例。一般来说，Go标识符仍以单个单词作为命名首选。

从Go标准库代码的不完全统计结果来看，不同类别标识符的命名呈现出以下特征：
循环和条件变量多采用单个字母命名（具体见上面的统计数据）；
函数/方法的参数和返回值变量以单个单词或单个字母为主；
由于方法在调用时会绑定类型信息，因此方法的命名以单个单词为主；函
数多以多单词的复合词进行命名；类型多以多单词的复合词进行命名。
除了上述特征，还有一些在命名时常用的惯例。

Go语言中有大量单字母、单个词或缩写命名的简短命名变量。有人可能会认为简短命名变量会降低代码的可读性。Go语言建议通过保持一致性来维持可读性。一致意味着代码中相同或相似的命名所传达的含义是相同或相似的，这样便于代码阅读者或维护者猜测出变量的用途。

变量v、k、i的常用含义


```go
// 循环语句中的变量
for i, v := range s { ... }           // i为下标变量; v为元素值
for k, v := range m { ... }           // k为key变量; v为元素值
for v := range r { // channel ... }   // v为元素值

// if、switch/case分支语句中的变量
if v := mimeTypes[ext]; v != "" { }   // v: 元素值
switch v := ptr.Elem(); v.Kind() {
    ...
}

case v := <-c:                        // v: 元素值

// 反射的结果值
v := reflect.ValueOf(x)

t := time.Now()                            // 时间
t := &Timer{}                              // 定时器
if t := md.typemap[off]; t != nil { }      // 类型

b := make([]byte, n)                       // byte切片
b := new(bytes.Buffer)                     // byte缓存
```

3. 常量
在Go语言中，常量在命名方式上与变量并无较大差别，并不要求全部大写。只是考虑其含义的准确传递，常量多使用多单词组合的方式命名。
对名称本身就是全大写的特定常量使用全大写的名字，比如数学计算中的PI，或是为了与系统错误码、系统信号名称保持一致而用全大写方式命名

4. 接口
在Go语言中，对于接口类型优先以单个单词命名。对于拥有唯一方法（method）或通过多个拥有唯一方法的接口组合而成的接口，Go语言的惯例是用“方法名+er”命名。比如：

```go
// $GOROOT/src/io/io.go

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Reader interface {
    Read(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

Go语言推荐尽量定义小接口，并通过接口组合的方式构建程序 !!!

### 7.2　利用上下文环境，让最短的名字携带足够多的信息

Go在给标识符命名时还有着考虑上下文环境的惯例，即在不影响可读性的前提下，兼顾一致性原则，尽可能地用短小的名字命名标识符。这与其他一些主流语言在命名上的建议有所不同，比如Java建议遵循“见名知义”的命名原则。我们可以对比一下Java和Go在循环变量命名上的差异

在Go代码中来分别运用这两个命名方案并做比对

```go

for index := 0; index < len(s); index++ {
    value := s[index]
    ...
}

// vs

for i := 0; i < len(s); i++ {
    v := s[i]
    ...
}
```

### 小结
Go语言命名惯例深受C语言的影响，这与Go语言之父有着深厚的C语言背景不无关系。Go语言追求简单一致且利用上下文辅助名字信息传达的命名惯例，如果你刚从其他语言转向Go，这可能会让你感到不适应，但这就是Go语言文化的一部分，也许等你编写的Go代码达到一定的量，你就能理解这种命名惯例的好处了。

----


# 第三部分　声明、类型、语句与控制结构

本部分将详述在Go基础语法层面有哪些高质量Go代码的惯用法和有效实践，内容涵盖变量声明、无类型常量的作用、枚举常量的定义、零值可用类型的意义、高频使用类型字符串/切片/map的实现原理及惯用法、Go包导入路径的真正含义以及对语句和控制结构的深入理解等。

## 第8条　使用一致的变量声明形式

Go语言常见的变量声明形式：
```go
var a int32
var s string = "hello"
var i = 13
n := 17
var (
    crlf       = []byte("\r\n")
    colonSpace = []byte(": ")
)
```

如果让Go语言的设计者重新设计一次变量声明语法，相信他们很大可能不会再给予Gopher这么大的变量声明灵活性，但目前这一切都无法改变。对于以面向工程著称且以解决规模化问题为目标的Go语言，Gopher在变量声明形式的选择上应尽量保持项目范围内一致。

Go语言有两类变量。
包级变量（package variable）：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。
局部变量（local variable）：函数或方法体内声明的变量，仅在函数或方法体内可见。

### 8.1　包级变量的声明形式

包级变量只能使用带有var关键字的变量声明形式

1. 声明并同时显式初始化

如果不接受默认类型，而是要显式为包级变量a和f指定类型，那么有以下两种声明方式：
```go
// 第一种
var a int32 = 17
var f float32 = 3.14

// 第二种
var a = int32(17)
var f = float32(3.14)
```

从声明一致性的角度出发，Go语言官方更推荐后者，这样就统一了接受默认类型和显式指定类型两种声明形式。尤其是在将这些变量放在一个var块中声明时，我们更青睐这样的形式：

```go
var (
    a = 17
    f = float32(3.14)
)
```

2. 声明但延迟初始化
虽然没有显式初始化，但Go语言会让这些变量拥有初始的“零值”。如果是自定义的类型，保证其零值可用是非常必要的，这一点将在后文中详细说明。

3. 声明聚类与就近原则

Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中；或者将延迟初始化的变量声明放在一个var块，而将声明并显式初始化的变量放在另一个var块中。笔者称之为“声明聚类”。

是否应当将包级变量的声明全部集中放在源文件头部呢？使用静态编程语言的开发人员都知道，变量声明最佳实践中还有一条：就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。

我们看到在request.go的Cookie方法中使用了ErrNoCookie这个变量，而这个包级变量被就近安排在临近该方法定义的位置进行声明。之所以这么做，可能考虑到的一点是在这个源文件中，仅Cookie方法用到了变量ErrNoCookie。如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合。

### 8.2　局部变量的声明形式
与包级变量相比，局部变量多了一种短变量声明形式，这也是局部变量采用最多的一种声明形式。

1. 对于延迟初始化的局部变量声明，采用带有var关键字的声明形式

另一种常见的采用带var关键字声明形式的变量是error类型的变量err（将error类型变量实例命名为err也是Go的一个惯用法），尤其是当defer后接的闭包函数需要使用err判断函数/方法退出状态时。

```go
func Foo() {
    var err error
    defer func() {
        if err != nil {
            ...
        }
    }()

    err = Bar()
    ...
}
```
2. 对于声明且显式初始化的局部变量，建议使用短变量声明形式
对于不接受默认类型的变量，依然可以使用短变量声明形式，只是在“:=”右侧要进行显式转型
```go
a := int32(17)
f := float32(3.14)
s := []byte("hello, gopher!")
```
3. 尽量在分支控制时应用短变量声明形式
在编写Go代码时，我们很少单独声明在分支控制语句中使用的变量，而是通过短变量声明形式将其与if、for等融合在一起
这样的应用方式体现出“就近原则”，让变量的作用域最小化了。

由于良好的函数/方法设计讲究的是“单一职责”，因此每个函数/方法规模都不大，很少需要应用var块来聚类声明局部变量。当然，如果你在声明局部变量时遇到适合聚类的应用场景，你也应该毫不犹豫地使用var块来声明多个局部变量。

```go
// $GOROOT/src/net/dial.go
func (r *Resolver) resolveAddrList(ctx context.Context, op, network,
                            addr string, hint Addr) (addrList, error) {
    ...
    var (
        tcp      *TCPAddr
        udp      *UDPAddr
        ip       *IPAddr
        wildcard bool
    )
    ...
}
```

### 小结
使用一致的变量声明是Go语言的一个最佳实践，我们用图8-1来对变量声明形式做个形象的小结。


## 第9条　使用无类型常量简化代码

```go
// $GOROOT/src/io/io.go
const (
    SeekStart   = 0
    SeekCurrent = 1
    SeekEnd     = 2
)
```

### 9.2　有类型常量带来的烦恼