# 一部分 熟知Go语言的一切

## 3条 理解Go语言的设计哲学

### 3.1　追求简单，少即是多
正如Go语言之父Rob Pike所说：“Go语言实际上是复杂的，但只是让大家感觉很简单。”这句话背后的深意就是“简单”选择的背后是Go语言自身实现层面的复杂性，而这种复杂性被Go语言的设计者“隐藏”起来了。比如并发是复杂的，但我们通过一个简单的关键字“go”就可以实现。这种简单其实是Go开发团队缜密设计和持续付出的结果。

### 3.2　偏好组合，正交解耦
Go语言本质上就不属于经典OO语言范畴。针对这种情况，很多人会问：那Go语言是如何将程序的各个部分有机地耦合在一起的呢？就像上面引述的Douglas McIlroy那句话中的浇水软管那样，Go语言遵从的设计哲学也是组合。
Go采用了组合的方式，也是唯一的方式。

Go语言提供的最为直观的组合的语法元素是类型嵌入（type embedding）。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。这种方式有些类似经典OO语言中的继承机制，但在原理上与其完全不同，这是一种Go设计者们精心设计的语法糖。被嵌入的类型和新类型之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典OO语言中的那种父类、子类的关系以及向上、向下转型（type casting）。在通过新类型实例调用方法时，方法的匹配取决于方法名字，而不是类型。这种组合方式，笔者称之为“垂直组合”，即通过类型嵌入，快速让一个新类型复用其他类型已经实现的能力，实现功能的垂直扩展。


```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}
    shared  []interface{}
    Mutex
    pad     [128]byte
}
```
我们在poolLocal这个结构体类型中嵌入了类型Mutex，被嵌入的Mutex类型的方法集合会被提升到外面的类型（poolLocal）中。比如，这里的poolLocal将拥有Mutex类型的Lock和Unlock方法。但在实际调用时，方法调用会被传给poolLocal中的Mutex实例。

我们在标准库中还经常看到如下的interface类型嵌入的代码：

```go

// $GOROOT/src/io/io.go
type ReadWriter interface {
    Reader
    Writer
}
```

通过在interface的定义中嵌入interface类型来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为Go语言的一种惯用法。

interface是Go语言中真正的“魔法”，是Go语言的一个创新设计，它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的interface实现会不经意间满足依赖抽象、里氏替换、接口隔离等设计原则，这在其他语言中是需要很刻意的设计谋划才能实现的，但在Go interface看来，一切却是自然而然的。

通过interface将程序各个部分组合在一起的方法，笔者称之为“水平组合”。水平组合的模式有很多，一种常见的方法是通过接受interface类型参数的普通函数进行组合，例如下面的代码。

```go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```

函数ReadAll通过io.Reader这个接口将io.Reader的实现与ReadAll所在的包以低耦合的方式水平组合在一起了。类似的水平组合模式还有wrapper、middleware等

此外，Go语言内置的并发能力也可以通过组合的方式实现对计算能力的串联，比如通过goroutine+channel的组合实现类似Unix Pipe的能力。

综上，组合原则的应用塑造了Go程序的骨架结构。类型嵌入为类型提供垂直扩展能力，interface是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。组合也让遵循简单原则的Go语言在表现力上丝毫不逊色于复杂的主流编程语言。

### 3.3　原生并发，轻量高效
将面向多核、原生内置并发支持作为新语言的设计原则之一

Go语言原生支持并发的设计哲学体现在以下几点。
（1）Go语言采用轻量级协程并发模型，使得Go应用在面向多核硬件时更具可扩展性

提到并发执行与调度，我们首先想到的就是操作系统对进程、线程的调度。操作系统调度器会将系统中的多个线程按照一定算法调度到物理CPU上运行。传统编程语言（如C、C++等）的并发实现实际上就是基于操作系统调度的，即程序负责创建线程（一般通过pthread等函数库调用实现），操作系统负责调度。这种传统支持并发的方式主要有两大不足：复杂和难于扩展。

复杂主要体现在以下方面。
创建容易，退出难：使用C语言的开发人员都知道，创建一个线程时（比如利用pthread库）虽然参数也不少，但还可以接受。而一旦涉及线程的退出，就要考虑线程是不是分离的（detached）？是否需要父线程去通知并等待子线程退出（join）？是否需要在线程中设置取消点（cancel point）以保证进行join操作时能顺利退出？
并发单元间通信困难，易错：多个线程之间的通信虽然有多种机制可选，但用起来相当复杂；并且一旦涉及共享内存（shared memory），就会用到各种锁（lock），死锁便成为家常便饭。
线程栈大小（thread stack size）的设定：是直接使用默认的，还是设置得大一些或小一些呢？难于扩展主要体现在以下方面。

虽然线程的代价比进程小了很多，但我们依然不能大量创建线程，因为不仅每个线程占用的资源不小，操作系统调度切换线程的代价也不小。
对于很多网络服务程序，由于不能大量创建线程，就要在少量线程里做网络的多路复用，即使用epoll/kqueue/IoCompletionPort这套机制。即便有了libevent、libev这样的第三方库的帮忙，写起这样的程序也是很不容易的，存在大量回调（callback），会给程序员带来不小的心智负担。

为了解决这些问题，Go果断放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程或者说是类协程（coroutine），Go将之称为goroutine。goroutine占用的资源非常少，Go运行时默认为每个goroutine分配的栈空间仅2KB。goroutine调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，在一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是Go的运行时代码也不例外。

不过，一个Go程序对于操作系统来说只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠Go自己完成，实现Go程序内goroutine之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些goroutine按照一定算法放到CPU上执行的程序就称为goroutine调度器（goroutine scheduler）。

（2）Go语言为开发者提供的支持并发的语法元素和机制

我们先来看看那些设计并诞生于单核年代的编程语言（如C、C++、Java）在语法元素和机制层面是如何支持并发的。执行单元：线程。
创建和销毁的方式：调用库函数或调用对象方法。并发线程间的通信：多基于操作系统提供的IPC机制，比如共享内存、Socket、Pipe等，当然也会使用有并发保护的全局变量。
与上述传统语言相比，Go提供了语言层面内置的并发语法元素和机制。执行单元：goroutine

创建和销毁方式：go+函数调用；函数退出即goroutine退出。并发goroutine的通信：通过语言内置的channel传递消息或实现同步，并通过select实现多路channel的并发控制。对比来看，Go对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。

(3）并发原则对Go开发者在程序结构设计层面的影响

由于goroutine的开销很小（相对线程），Go官方鼓励大家使用goroutine来充分利用多核资源。但并不是有了goroutine就一定能充分利用多核资源，或者说即便使用Go也不一定能写出好的并发程序。

Rob Pike认为：并发是有关结构的，它是一种将一个程序分解成多个小片段并且每个小片段都可以独立执行的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作。并行是有关执行的，它表示同时进行一些计算任务。以上观点的重点是，并发是一种程序结构设计的方法，它使并行成为可能。

并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的。
除此之外，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计层面对程序进行拆解组合，再映射到程序执行层面：goroutine各自执行特定的工作，通过channel+select将goroutine组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让Go语言更适应现代计算环境。


### 3.4　面向工程，“自带电池”

软件工程指引着Go语言的设计。——Rob Pike（2012）

要想理解这条设计哲学，我们依然需要回到三位Go语言之父在设计Go语言时的初衷：面向真实世界中Google内部大规模软件开发存在的各种问题，为这些问题提供答案。主要的问题包括：

程序构建慢；
失控的依赖管理；
开发人员使用编程语言的不同子集（比如C++支持多范式，这样有些人用OO，有些人用泛型）；
代码可理解性差（代码可读性差、文档差等）；
功能重复实现；
升级更新消耗大；
实现自动化工具难度高；
版本问题；
跨语言构建问题。

很多编程语言的设计者或拥趸认为这些问题并不是编程语言应该解决的，但Go语言的设计者并不这么看，他们以更高、更广阔的视角审视软件开发领域尤其是大规模软件开发过程中遇到的各种问题，并在Go语言最初设计阶段就将解决工程问题作为Go的设计原则之一去考虑Go语法、工具链与标准库的设计，这也是Go与那些偏学院派、偏研究性编程语言在设计思路上的一个重大差异。

Go语言取得阶段性成功后，这种思路开始影响后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴Go的一些设计，比如越来越多的语言认可统一代码风格的优越之处，并开始提供官方统一的fmt工具（如Rust的rustfmt），又如Go创新提出的最小版本选择（Minimal Version Selection，MVS）被其他语言的包依赖工具所支持（比如Rust的cargo支持MVS）。

Go设计者将所有工程问题浓缩为一个词：scale（笔者总觉得将scale这个词翻译为任何中文词都无法传神地表达其含义，暂译为“规模”吧）。从Go1开始，Go的设计目标就是帮助开发者更容易、更高效地管理两类规模。

生产规模：用Go构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数量等。
开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等。
Go设计者期望Go可以游刃有余地应对生产规模和开发规模变大带来的各种复杂问题。Go语言的演进方向是优化甚至消除Go语言自身面对规模化问题时应对不好的地方，比如：Go 1.9引入类型别名（type alias）以应对大型代码仓库代码重构，Go 1.11引入go module机制以解决不完善的包依赖问题等。这种设计哲学的落地让Go语言具有广泛的规模适应性：既可以被仅有5人的初创团队用于开发终端工具，也能够满足像Google这样的巨型公司大规模团队开发大规模网络服务程序的需要。

### 小结
简单是Go语言贯穿语言设计和应用的主旨设计哲学。德国建筑大师路德维希·密斯·凡德罗将“少即是多”这一哲学理念应用到建筑设计当中后取得了非凡的成功，而Go语言则是这一哲学在编程语言领域为数不多的践行者。“少”绝不是目的，“多”才是其内涵。Go在语言层面的简单让Go收获了不逊于C++/Java等的表现力的同时，还获得了更好的可读性、更高的开发效率等在软件工程领域更为重要的元素。

“高内聚、低耦合”是软件开发领域亘古不变的管理复杂性的准则。Go在语言设计层面也将这一准则发挥到极致。Go崇尚通过组合的方式将正交的语法元素组织在一起来形成应用程序骨架，接口就是在这一哲学下诞生的语言精华。

不同于C、C++、Java等诞生于20世纪后段的面向单机的编程语言，Go语言是面向未来的。Go设计者对硬件发展趋势做出了敏锐且准确的判断——多核时代是未来主流趋势，于是将并发作为语言的“一等公民”，提供了内置于语言中的简单并发原语——go（goroutine）、channel和select，大幅降低了开发人员在云计算多核时代编写大规模并发网络服务程序时的心智负担。

Go生来就肩负着解决面向软件工程领域问题的使命，我们看到的开箱即用的标准库、语言自带原生工具链以及开放的工具链生态的建立都是这一使命落地的结果，Go在面向工程领域的探索也引领着编程语言未来发展的潮流。

## 第4条　使用Go语言原生编程思维来写Go代码

### 4.1　语言与思维——来自大师的观点
在人类自然语言学界有一个很著名的假说——“萨丕尔-沃夫假说”，这个假说的内容是这样的：“语言影响或决定人类的思维方式。”

在编程语言界，有位大师级人物也有着与“萨丕尔-沃夫假说”异曲同工的观点和认知，他就是首届图灵奖得主、著名计算机科学家艾伦·佩利（Alan J. Perlis），他从另外一个角度提出：“不能影响到你的编程思维方式的编程语言不值得学习和使用。”

### 4.2　现实中的“投影”
简单的编程问题——素数筛。
问题描述：素数是一个自然数，它具有两个截然不同的自然数除数：1和它本身。这里的问题是如何找到小于或等于给定整数n的素数。针对这个问题，我们可以采用埃拉托斯特尼素数筛算法。
算法描述：先用最小的素数2去筛，把2的倍数筛除；下一个未筛除的数就是素数（这里是3）。再用这个素数3去筛，筛除3的倍数……这样不断重复下去，直到筛完为止（算法图示见图4-1）。

（1）C语言版本

```C
// chapter1/sources/sieve.c

#include <stdio.h>

#define LIMIT  50
#define PRIMES 10

void sieve() {
    int c, i,j,numbers[LIMIT], primes[PRIMES];

    for (i=0;i<LIMIT;i++){
        numbers[i]=i+2; /*fill the array with natural numbers*/
    }
    for (i=0;i<LIMIT;i++){
        if (numbers[i]!=-1){
            for (j=2*numbers[i]-2;j<LIMIT;j+=numbers[i])
                numbers[j]=-1; /* 筛除非素数 */
        }
    }
    c = j = 0;
    for (i=0;i<LIMIT&&j<PRIMES;i++) {
        if (numbers[i]!=-1) {
            primes[j++] = numbers[i]; /*transfer the primes to their own array*/
            c++;
        }
    }
    for (i=0;i<c;i++) printf("%d\n",primes[i]);
}
```

（2）Haskell版本

```haskell
// chapter1/sources/sieve.hs

sieve [] = []
sieve (x:xs) = x : sieve (filter (\a -> not $ a `mod` x == 0) xs)

n = 100
main = print $ sieve [2..n]
```

（3）Go语言版本

```go
// chapter1/sources/sieve.go

func Generate(ch chan<- int) {
    for i := 2; ; i++ {
        ch <- i
    }
}

func Filter(in <-chan int, out chan<- int, prime int) {
    for {
        i := <-in
        if i%prime != 0 {
            out <- i
        }
    }
}

func main() {
    ch := make(chan int)
    go Generate(ch)
    for i := 0; i < 10; i++ {
        prime := <-ch
        print(prime, "\n")
        ch1 := make(chan int)
        go Filter(ch, ch1, prime)
        ch = ch1
    }
}
```

https://go.dev/play/p/9U22NfrXeq

对比上述三个语言版本的素数筛算法的实现，我们看到：
C版本的素数筛程序是一个常规实现。它定义了两个数组numbers和primes，“筛”的过程在numbers这个数组中进行（基于纯内存修改），非素数的数组元素被设置为-1，便于后续提取。Haskell版本采用了函数递归的思路，通过“filter操作集合”，用谓词（过滤条件）\a -> not $ a `mod` x == 0筛除素数的倍数，将未筛除的数的集合作为参数传递归递给下去。Go版本程序实现了一个并发素数筛，它采用的是goroutine的并发组合。程序从素数2开始，依次为每个素数建立一个goroutine，用于作为筛除该素数的倍数。ch指向当前最新输出素数所位于的筛子goroutine的源channel。这段代码来自Rob Pike的一次关于并发的分享[1]。Go版本程序的执行过程可以用图4-2立体地展现出来。

### 4.3　Go语言原生编程思维
面对同一个问题，来自不同编程语言的程序员给出了思维方式截然不同的解决方法：C的命令式思维、Haskell的函数式思维和Go的并发思维。结合“萨丕尔—沃夫假说”，我们可以得到一个未经理论证实但又确实对现实有影响的推论：编程语言影响编程思维，或者说每种编程语言都有属于自己的原生编程思维。

Go语言诞生较晚，大多数Gopher（包括笔者在内）的第一语言并不是Go，而是“半路出家”从其他语言（如C、C++、Java、Python等）转过来的。每种语言都有自己的原生编程思维。比如：C语言相信程序员，提供了指针和指针运算，让C程序员天马行空地发挥，接近底层的直接内存操作让C程序拥有很高的性能；C++支持多范式（命令式、OO和泛型），虽不强迫程序员使用某个特定的范式，但推荐使用最新代表现代语言发展特色的泛型等高级范式；Python语言更是形成了Pythonic规则来指导Python程序员写出符合Python思维或惯用法的代码。经验告诉我们，但凡属于某个编程语言的高质量范畴的代码，其必定是在这种编程语言原生思维下编写的代码。

如果用A语言的思维去编写B语言的代码（比如用OO思维写C代码，用命令式的思维写Haskell代码等），那么你写出的代码多半无法被B语言社区所认可，更难以成为高质量代码的典范。并且，如果沿着这样的方向去学习和实践B语言，那么结果只能是南辕北辙，与编写出高质量代码的目标渐行渐远。

我们的目标是编写出高质量的Go代码，这就需要我们在学习语言的同时，不断学习Go语言原生的编程思维，时刻用Go编程思维考虑Go代码的设计和实现，这是通往高质量Go代码的必经之路。


### 小结
人类在通过自然语言交流和表达观点的漫长过程中，逐渐形成了固定的语言表述方法。除此之外，人类还利用肢体动作、眼神、表情、纸笔等辅助行为或工具来帮助语言的精确表达，并且在使用这些辅助行为和工具时形成了固定的使用方法，这些以这门语言为中心的固定的表述方法、辅助行为和工具用法总称为这门语言的惯用法，它们反映的就是该语言的思维方式。

编程语言也类似，以一门编程语言为中心的，以解决工程问题为目标的编程语言用法、辅助库、工具的固定使用方法称为该门编程语言的原生编程思维。

我们学习和使用一门编程语言，目标是用这门语言的原生思维方式编写高质量代码。学习Go，就要用Go的原生编程思维而不是用其他语言的思维方式写Go代码。掌握Go原生编程思维就是我们通往高质量Go编程的学习方向和必经之路，因此本书后面将从语言、标准库、工具链、工程实践等方面来全面介绍Go语言的原生编程思维，帮助大家打好编写高质量Go代码的基础。


---

# 第二部分　项目结构、代码风格与标识符命名

## 第5条　使用得到公认且广泛使用的项目结构

### 1. Go项目结构的最小标准布局

Go语言项目的技术负责人，Russ Cox在一个开源项目的issue中给出了他关于Go项目结构的最小标准布局[1]的想法。他认为Go项目的最小标准布局应该是这样的：

<pre>
// 在Go项目仓库根路径下

- go.mod
- LICENSE
- xx.go
- yy.go
...
</pre>
或
<pre>
- go.mod
- LICENSE
- package1
        - package1.go
- package2
        - package2.go
...
</pre>

pkg、cmd、docs这些目录不应该成为Go项目标准结构的一部分，至少不是必需的。笔者认为Russ Cox给出的最小标准布局与Go一贯崇尚的“简单”哲学是一脉相承的，这个布局很灵活，可以满足各种Go项目的需求。

非官方标准的建议结构布局

### 2. 以构建二进制可执行文件为目的的Go项目结构
一个支持（在cmd下）构建二进制可执行文件的典型Go项目的结构，我们分别来看一下各个重要目录的用途。

cmd目录：存放项目要构建的可执行文件对应的main包的源文件。如果有多个可执行文件需要构建，则将每个可执行文件的main包单独放在一个子目录中，比如图中的app1、app2。cmd目录下的各app的main包将整个项目的依赖连接在一起，并且通常来说，main包应该很简洁。我们会在main包中做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。有一些Go项目将cmd这个名字改为app，但其功用并没有变。

pkg目录：存放项目自身要使用并且同样也是可执行文件对应main包要依赖的库文件。该目录下的包可以被外部项目引用，算是项目导出包的一个聚合。有些项目将pkg这个名字改为lib，但该目录的用途不变。由于Go语言项目自身在1.4版本中去掉了pkg这一层目录，因此有一些项目直接将包平铺到项目根路径下，但笔者认为对于一些规模稍大的项目，过多的包会让项目顶层目录不再简洁，显得很拥挤，因此个人建议对于复杂的Go项目保留pkg目录。

Makefile：这里的Makefile是项目构建工具所用脚本的“代表”，它可以代表任何第三方构建工具所用的脚本。Go并没有内置如make、bazel等级别的项目构建工具，对于一些规模稍大的项目而言，项目构建工具似乎不可缺少。在Go典型项目中，项目构建工具的脚本一般放在项目顶层目录下，比如这里的Makefile；对于构建脚本较多的项目，也可以建立build目录，并将构建脚本的规则属性文件、子构建脚本放入其中。

go.mod和go.sum：Go语言包依赖管理使用的配置文件。Go 1.11版本引入Go module机制，Go 1.16版本中，Go module成为默认的依赖包管理和构建机制。因此对于新的Go项目，建议基于Go module进行包依赖管理。对于没有使用Go module进行包管理的项目（可能主要是一些使用Go 1.11以前版本的Go项目），这里可以换为dep的Gopkg.toml和Gopkg.lock，或者glide的glide.yaml和glide.lock等。

vendor目录（可选）：vendor是Go 1.5版本引入的用于在项目本地缓存特定版本依赖包的机制。在引入Go module机制之前，基于vendor可以实现可重现的构建（reproducible build），保证基于同一源码构建出的可执行程序是等价的。Go module本身就可以实现可重现的构建而不需要vendor，当然Go module机制也保留了vendor目录（通过go mod vendor可以生成vendor下的依赖包；通过go build -mod=vendor可以实现基于vendor的构建），因此这里将vendor目录视为一个可选目录。一般我们仅保留项目根目录下的vendor目录，否则会造成不必要的依赖选择的复杂性。

Go 1.11引入的module是一组同属于一个版本管理单元的包的集合。Go支持在一个项目/仓库中存在多个module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。因此，如果项目结构中存在版本管理的“分歧”，比如app1和app2的发布版本并不总是同步的，那么笔者建议将项目拆分为多个项目（仓库），每个项目单独作为一个module进行版本管理和演进。

### 3. 以只构建库为目的的Go项目结构

库类型项目结构与Go项目的最小标准布局也是兼容的，但比以构建二进制可执行文件为目的的Go项目要简单一些。

去除了cmd和pkg两个子目录：由于仅构建库，没必要保留存放二进制文件main包源文件的cmd目录；由于Go库项目的初衷一般都是对外部（开源或组织内部公开）暴露API，因此也没有必要将其单独聚合到pkg目录下面了。

vendor不再是可选目录：对于库类型项目而言，不推荐在项目中放置vendor目录去缓存库自身的第三方依赖，库项目仅通过go.mod（或其他包依赖管理工具的manifest文件）明确表述出该项目依赖的模块或包以及版本要求即可。

### 4. 关于internal目录

无论是上面哪种类型的Go项目，对于不想暴露给外部引用，仅限项目内部使用的包，在项目结构上可以通过Go 1.4版本中引入的internal包机制来实现。以库项目为例，最简单的方式就是在顶层加入一个internal目录，将不想暴露到外部的包都放在该目录下，比如下面项目结构中的ilib1、ilib2

<pre>
// 带internal的Go库项目结构

$tree -F ./chapter2/sources/GoLibProj
GoLibProj
├── LICENSE
├── Makefile
├── README.md
├── go.mod
├── internal/
│  ├── ilib1/
│  └── ilib2/
├── lib.go
├── lib1/
│  └── lib1.go
└── lib2/
      └── lib2.go
</pre>

这样，根据Go internal机制的作用原理，internal目录下的ilib1、ilib2可以被以GoLibProj目录为根目录的其他目录下的代码（比如lib.go、lib1/lib1.go等）所导入和使用，但是却不可以为GoLibProj目录以外的代码所使用，从而实现选择性地暴露API包。当然internal也可以放在项目结构中的任一目录层级中，关键是项目结构设计人员明确哪些要暴露到外层代码，哪些仅用于同级目录或子目录中。

对于以构建二进制可执行文件类型为目的的项目，我们同样可以将不想暴露给外面的包聚合到项目顶层路径下的internal下，与暴露给外部的包的聚合目录pkg遥相呼应。

### 小结
以上两个针对构建二进制可执行文件类型以及库类型的项目参考结构是Go社区在多年实践后得到公认且使用较为广泛的项目结构，并且它们与Russ Cox提出的Go项目最小标准布局是兼容的，对于稍大型的Go项目来说很有参考价值。

上述参考项目结构与产品设计开发领域的最小可行产品（Minimum Viable Product，MVP）的思路异曲同工，开发者可以在这样一个最小的项目结构核心的基础上根据实际需要进行扩展。


## 第6条　提交前使用gofmt格式化源码

### 6.1　gofmt：Go语言在解决规模化问题上的最佳实践
gofmt的代码风格不是某个人的最爱，而是所有人的最爱。——Rob Pike

