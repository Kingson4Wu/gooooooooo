
◆ 前言

>> 本书特色
本书的特色可以概括为以下几点。
◦  进阶必备：精心总结的编程箴言助你掌握高效Go程序设计之道。
◦  高屋建瓴：Go设计哲学与编程思想先行。
◦  深入浅出：原理深入，例子简明，讲解透彻。
◦  图文并茂：大量图表辅助学习，重点、难点轻松掌控。
如何阅读本书
本书内容共分为十部分，限于篇幅，分为两册出版，即《Go语言精进之路：从新手到高手的编程思想、方法和技巧1》和《Go语言精进之路：从新手到高手的编程思想、方法和技巧2》。其中，第1册包含第一～七部分，第2册包含第八～十部分。
◦  第一部分　熟知Go语言的一切
本部分将带领读者穿越时空，回顾历史，详细了解Go语言的诞生、演进以及发展现状。通过归纳总结Go语言的设计哲学和原生编程思维，让读者站在语言设计者的高度理解Go语言与众不同的设计，认同Go语言的设计理念。
◦  第二部分　项目结构、代码风格与标识符命名
每种编程语言都有自己惯用的代码风格，而遵循语言惯用风格是编写高质量Go代码的必要条件。本部分详细介绍了得到公认且广泛使用的Go项目的结构布局、代码风格标准、标识符命名惯例等。

>> ◦  第三部分　声明、类型、语句与控制结构
本部分详述基础语法层面高质量Go代码的惯用法和有效实践，涵盖无类型常量的作用、定义Go的枚举常量、零值可用类型的意义、切片原理以及高效的原因、Go包导入路径的真正含义等。
◦  第四部分　函数与方法
函数和方法是Go程序的基本组成单元。本部分聚焦于函数与方法的设计和实现，涵盖init函数的使用、跻身“一等公民”行列的函数有何不同、Go方法的本质等。
◦  第五部分　接口
接口是Go语言中的“魔法师”。本部分聚焦于接口，涵盖接口的设计惯例、使用接口类型的注意事项以及接口类型对代码可测试性的影响等。
◦  第六部分　并发编程
Go以其轻量级的并发模型而闻名。本部分详细介绍Go基本执行单元——goroutine的调度原理、Go并发模型以及常见并发模式、Go支持并发的原生类型——channel的惯用模式等内容。
◦  第七部分　错误处理
Go语言十分重视错误处理，它有着相对保守的设计和显式处理错误的惯例。本部分涵盖Go错误处理的哲学以及在这套哲学下一些常见错误处理问题的优秀实践。
◦  第八部分　测试、性能剖析与调试
Go自带强大且为人所称道的工具链。本部分详细介绍Go在单元测试、性能基准测试与性能剖析以及代码调试方面的最佳实践。

>> ◦  第九部分　标准库、反射与cgo
Go拥有功能强大且质量上乘的标准库，在多数情况下仅使用标准库即可实现应用的大部分功能，这大幅降低了学习成本以及代码依赖的管理成本。本部分详细说明高频使用的标准库包（如net/http、strings、bytes、time等）的正确使用方式，以及在使用reflect包、cgo时的注意事项。
◦  第十部分　工具链与工程实践
本部分涵盖在使用Go语言进行大型软件项目开发的过程中，我们很有可能会遇到的一些工程问题的解决方法，包括使用go module进行Go包依赖管理、Go程序容器镜像、Go相关工具使用以及Go语言的避“坑”指南。

>> 书中的源文件可以从https://github.com/bigwhite/GoProgrammingFromBeginnerToMaster下载。



# 一部分 熟知Go语言的一切

## 3条 理解Go语言的设计哲学

### 3.1　追求简单，少即是多
正如Go语言之父Rob Pike所说：“Go语言实际上是复杂的，但只是让大家感觉很简单。”这句话背后的深意就是“简单”选择的背后是Go语言自身实现层面的复杂性，而这种复杂性被Go语言的设计者“隐藏”起来了。比如并发是复杂的，但我们通过一个简单的关键字“go”就可以实现。这种简单其实是Go开发团队缜密设计和持续付出的结果。

### 3.2　偏好组合，正交解耦
Go语言本质上就不属于经典OO语言范畴。针对这种情况，很多人会问：那Go语言是如何将程序的各个部分有机地耦合在一起的呢？就像上面引述的Douglas McIlroy那句话中的浇水软管那样，Go语言遵从的设计哲学也是组合。
Go采用了组合的方式，也是唯一的方式。

Go语言提供的最为直观的组合的语法元素是类型嵌入（type embedding）。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。这种方式有些类似经典OO语言中的继承机制，但在原理上与其完全不同，这是一种Go设计者们精心设计的语法糖。被嵌入的类型和新类型之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典OO语言中的那种父类、子类的关系以及向上、向下转型（type casting）。在通过新类型实例调用方法时，方法的匹配取决于方法名字，而不是类型。这种组合方式，笔者称之为“垂直组合”，即通过类型嵌入，快速让一个新类型复用其他类型已经实现的能力，实现功能的垂直扩展。


```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}
    shared  []interface{}
    Mutex
    pad     [128]byte
}
```
我们在poolLocal这个结构体类型中嵌入了类型Mutex，被嵌入的Mutex类型的方法集合会被提升到外面的类型（poolLocal）中。比如，这里的poolLocal将拥有Mutex类型的Lock和Unlock方法。但在实际调用时，方法调用会被传给poolLocal中的Mutex实例。

我们在标准库中还经常看到如下的interface类型嵌入的代码：

```go

// $GOROOT/src/io/io.go
type ReadWriter interface {
    Reader
    Writer
}
```

通过在interface的定义中嵌入interface类型来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为Go语言的一种惯用法。

interface是Go语言中真正的“魔法”，是Go语言的一个创新设计，它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的interface实现会不经意间满足依赖抽象、里氏替换、接口隔离等设计原则，这在其他语言中是需要很刻意的设计谋划才能实现的，但在Go interface看来，一切却是自然而然的。

通过interface将程序各个部分组合在一起的方法，笔者称之为“水平组合”。水平组合的模式有很多，一种常见的方法是通过接受interface类型参数的普通函数进行组合，例如下面的代码。

```go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```

函数ReadAll通过io.Reader这个接口将io.Reader的实现与ReadAll所在的包以低耦合的方式水平组合在一起了。类似的水平组合模式还有wrapper、middleware等

此外，Go语言内置的并发能力也可以通过组合的方式实现对计算能力的串联，比如通过goroutine+channel的组合实现类似Unix Pipe的能力。

综上，组合原则的应用塑造了Go程序的骨架结构。类型嵌入为类型提供垂直扩展能力，interface是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。组合也让遵循简单原则的Go语言在表现力上丝毫不逊色于复杂的主流编程语言。

### 3.3　原生并发，轻量高效
将面向多核、原生内置并发支持作为新语言的设计原则之一

Go语言原生支持并发的设计哲学体现在以下几点。
（1）Go语言采用轻量级协程并发模型，使得Go应用在面向多核硬件时更具可扩展性

提到并发执行与调度，我们首先想到的就是操作系统对进程、线程的调度。操作系统调度器会将系统中的多个线程按照一定算法调度到物理CPU上运行。传统编程语言（如C、C++等）的并发实现实际上就是基于操作系统调度的，即程序负责创建线程（一般通过pthread等函数库调用实现），操作系统负责调度。这种传统支持并发的方式主要有两大不足：复杂和难于扩展。

复杂主要体现在以下方面。
创建容易，退出难：使用C语言的开发人员都知道，创建一个线程时（比如利用pthread库）虽然参数也不少，但还可以接受。而一旦涉及线程的退出，就要考虑线程是不是分离的（detached）？是否需要父线程去通知并等待子线程退出（join）？是否需要在线程中设置取消点（cancel point）以保证进行join操作时能顺利退出？
并发单元间通信困难，易错：多个线程之间的通信虽然有多种机制可选，但用起来相当复杂；并且一旦涉及共享内存（shared memory），就会用到各种锁（lock），死锁便成为家常便饭。
线程栈大小（thread stack size）的设定：是直接使用默认的，还是设置得大一些或小一些呢？难于扩展主要体现在以下方面。

虽然线程的代价比进程小了很多，但我们依然不能大量创建线程，因为不仅每个线程占用的资源不小，操作系统调度切换线程的代价也不小。
对于很多网络服务程序，由于不能大量创建线程，就要在少量线程里做网络的多路复用，即使用epoll/kqueue/IoCompletionPort这套机制。即便有了libevent、libev这样的第三方库的帮忙，写起这样的程序也是很不容易的，存在大量回调（callback），会给程序员带来不小的心智负担。

为了解决这些问题，Go果断放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程或者说是类协程（coroutine），Go将之称为goroutine。goroutine占用的资源非常少，Go运行时默认为每个goroutine分配的栈空间仅2KB。goroutine调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，在一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是Go的运行时代码也不例外。

不过，一个Go程序对于操作系统来说只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠Go自己完成，实现Go程序内goroutine之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些goroutine按照一定算法放到CPU上执行的程序就称为goroutine调度器（goroutine scheduler）。

（2）Go语言为开发者提供的支持并发的语法元素和机制

我们先来看看那些设计并诞生于单核年代的编程语言（如C、C++、Java）在语法元素和机制层面是如何支持并发的。执行单元：线程。
创建和销毁的方式：调用库函数或调用对象方法。并发线程间的通信：多基于操作系统提供的IPC机制，比如共享内存、Socket、Pipe等，当然也会使用有并发保护的全局变量。
与上述传统语言相比，Go提供了语言层面内置的并发语法元素和机制。执行单元：goroutine

创建和销毁方式：go+函数调用；函数退出即goroutine退出。并发goroutine的通信：通过语言内置的channel传递消息或实现同步，并通过select实现多路channel的并发控制。对比来看，Go对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。

(3）并发原则对Go开发者在程序结构设计层面的影响

由于goroutine的开销很小（相对线程），Go官方鼓励大家使用goroutine来充分利用多核资源。但并不是有了goroutine就一定能充分利用多核资源，或者说即便使用Go也不一定能写出好的并发程序。

Rob Pike认为：并发是有关结构的，它是一种将一个程序分解成多个小片段并且每个小片段都可以独立执行的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作。并行是有关执行的，它表示同时进行一些计算任务。以上观点的重点是，并发是一种程序结构设计的方法，它使并行成为可能。

并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的。
除此之外，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计层面对程序进行拆解组合，再映射到程序执行层面：goroutine各自执行特定的工作，通过channel+select将goroutine组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让Go语言更适应现代计算环境。


### 3.4　面向工程，“自带电池”

软件工程指引着Go语言的设计。——Rob Pike（2012）

要想理解这条设计哲学，我们依然需要回到三位Go语言之父在设计Go语言时的初衷：面向真实世界中Google内部大规模软件开发存在的各种问题，为这些问题提供答案。主要的问题包括：

程序构建慢；
失控的依赖管理；
开发人员使用编程语言的不同子集（比如C++支持多范式，这样有些人用OO，有些人用泛型）；
代码可理解性差（代码可读性差、文档差等）；
功能重复实现；
升级更新消耗大；
实现自动化工具难度高；
版本问题；
跨语言构建问题。

很多编程语言的设计者或拥趸认为这些问题并不是编程语言应该解决的，但Go语言的设计者并不这么看，他们以更高、更广阔的视角审视软件开发领域尤其是大规模软件开发过程中遇到的各种问题，并在Go语言最初设计阶段就将解决工程问题作为Go的设计原则之一去考虑Go语法、工具链与标准库的设计，这也是Go与那些偏学院派、偏研究性编程语言在设计思路上的一个重大差异。

Go语言取得阶段性成功后，这种思路开始影响后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴Go的一些设计，比如越来越多的语言认可统一代码风格的优越之处，并开始提供官方统一的fmt工具（如Rust的rustfmt），又如Go创新提出的最小版本选择（Minimal Version Selection，MVS）被其他语言的包依赖工具所支持（比如Rust的cargo支持MVS）。

Go设计者将所有工程问题浓缩为一个词：scale（笔者总觉得将scale这个词翻译为任何中文词都无法传神地表达其含义，暂译为“规模”吧）。从Go1开始，Go的设计目标就是帮助开发者更容易、更高效地管理两类规模。

生产规模：用Go构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数量等。
开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等。
Go设计者期望Go可以游刃有余地应对生产规模和开发规模变大带来的各种复杂问题。Go语言的演进方向是优化甚至消除Go语言自身面对规模化问题时应对不好的地方，比如：Go 1.9引入类型别名（type alias）以应对大型代码仓库代码重构，Go 1.11引入go module机制以解决不完善的包依赖问题等。这种设计哲学的落地让Go语言具有广泛的规模适应性：既可以被仅有5人的初创团队用于开发终端工具，也能够满足像Google这样的巨型公司大规模团队开发大规模网络服务程序的需要。

### 小结
简单是Go语言贯穿语言设计和应用的主旨设计哲学。德国建筑大师路德维希·密斯·凡德罗将“少即是多”这一哲学理念应用到建筑设计当中后取得了非凡的成功，而Go语言则是这一哲学在编程语言领域为数不多的践行者。“少”绝不是目的，“多”才是其内涵。Go在语言层面的简单让Go收获了不逊于C++/Java等的表现力的同时，还获得了更好的可读性、更高的开发效率等在软件工程领域更为重要的元素。

“高内聚、低耦合”是软件开发领域亘古不变的管理复杂性的准则。Go在语言设计层面也将这一准则发挥到极致。Go崇尚通过组合的方式将正交的语法元素组织在一起来形成应用程序骨架，接口就是在这一哲学下诞生的语言精华。

不同于C、C++、Java等诞生于20世纪后段的面向单机的编程语言，Go语言是面向未来的。Go设计者对硬件发展趋势做出了敏锐且准确的判断——多核时代是未来主流趋势，于是将并发作为语言的“一等公民”，提供了内置于语言中的简单并发原语——go（goroutine）、channel和select，大幅降低了开发人员在云计算多核时代编写大规模并发网络服务程序时的心智负担。

Go生来就肩负着解决面向软件工程领域问题的使命，我们看到的开箱即用的标准库、语言自带原生工具链以及开放的工具链生态的建立都是这一使命落地的结果，Go在面向工程领域的探索也引领着编程语言未来发展的潮流。

## 第4条　使用Go语言原生编程思维来写Go代码

### 4.1　语言与思维——来自大师的观点
在人类自然语言学界有一个很著名的假说——“萨丕尔-沃夫假说”，这个假说的内容是这样的：“语言影响或决定人类的思维方式。”

在编程语言界，有位大师级人物也有着与“萨丕尔-沃夫假说”异曲同工的观点和认知，他就是首届图灵奖得主、著名计算机科学家艾伦·佩利（Alan J. Perlis），他从另外一个角度提出：“不能影响到你的编程思维方式的编程语言不值得学习和使用。”

### 4.2　现实中的“投影”
简单的编程问题——素数筛。
问题描述：素数是一个自然数，它具有两个截然不同的自然数除数：1和它本身。这里的问题是如何找到小于或等于给定整数n的素数。针对这个问题，我们可以采用埃拉托斯特尼素数筛算法。
算法描述：先用最小的素数2去筛，把2的倍数筛除；下一个未筛除的数就是素数（这里是3）。再用这个素数3去筛，筛除3的倍数……这样不断重复下去，直到筛完为止（算法图示见图4-1）。

（1）C语言版本

```C
// chapter1/sources/sieve.c

#include <stdio.h>

#define LIMIT  50
#define PRIMES 10

void sieve() {
    int c, i,j,numbers[LIMIT], primes[PRIMES];

    for (i=0;i<LIMIT;i++){
        numbers[i]=i+2; /*fill the array with natural numbers*/
    }
    for (i=0;i<LIMIT;i++){
        if (numbers[i]!=-1){
            for (j=2*numbers[i]-2;j<LIMIT;j+=numbers[i])
                numbers[j]=-1; /* 筛除非素数 */
        }
    }
    c = j = 0;
    for (i=0;i<LIMIT&&j<PRIMES;i++) {
        if (numbers[i]!=-1) {
            primes[j++] = numbers[i]; /*transfer the primes to their own array*/
            c++;
        }
    }
    for (i=0;i<c;i++) printf("%d\n",primes[i]);
}
```

（2）Haskell版本

```haskell
// chapter1/sources/sieve.hs

sieve [] = []
sieve (x:xs) = x : sieve (filter (\a -> not $ a `mod` x == 0) xs)

n = 100
main = print $ sieve [2..n]
```

（3）Go语言版本

```go
// chapter1/sources/sieve.go

func Generate(ch chan<- int) {
    for i := 2; ; i++ {
        ch <- i
    }
}

func Filter(in <-chan int, out chan<- int, prime int) {
    for {
        i := <-in
        if i%prime != 0 {
            out <- i
        }
    }
}

func main() {
    ch := make(chan int)
    go Generate(ch)
    for i := 0; i < 10; i++ {
        prime := <-ch
        print(prime, "\n")
        ch1 := make(chan int)
        go Filter(ch, ch1, prime)
        ch = ch1
    }
}
```

https://go.dev/play/p/9U22NfrXeq

对比上述三个语言版本的素数筛算法的实现，我们看到：
C版本的素数筛程序是一个常规实现。它定义了两个数组numbers和primes，“筛”的过程在numbers这个数组中进行（基于纯内存修改），非素数的数组元素被设置为-1，便于后续提取。Haskell版本采用了函数递归的思路，通过“filter操作集合”，用谓词（过滤条件）\a -> not $ a `mod` x == 0筛除素数的倍数，将未筛除的数的集合作为参数传递归递给下去。Go版本程序实现了一个并发素数筛，它采用的是goroutine的并发组合。程序从素数2开始，依次为每个素数建立一个goroutine，用于作为筛除该素数的倍数。ch指向当前最新输出素数所位于的筛子goroutine的源channel。这段代码来自Rob Pike的一次关于并发的分享[1]。Go版本程序的执行过程可以用图4-2立体地展现出来。

### 4.3　Go语言原生编程思维
面对同一个问题，来自不同编程语言的程序员给出了思维方式截然不同的解决方法：C的命令式思维、Haskell的函数式思维和Go的并发思维。结合“萨丕尔—沃夫假说”，我们可以得到一个未经理论证实但又确实对现实有影响的推论：编程语言影响编程思维，或者说每种编程语言都有属于自己的原生编程思维。

Go语言诞生较晚，大多数Gopher（包括笔者在内）的第一语言并不是Go，而是“半路出家”从其他语言（如C、C++、Java、Python等）转过来的。每种语言都有自己的原生编程思维。比如：C语言相信程序员，提供了指针和指针运算，让C程序员天马行空地发挥，接近底层的直接内存操作让C程序拥有很高的性能；C++支持多范式（命令式、OO和泛型），虽不强迫程序员使用某个特定的范式，但推荐使用最新代表现代语言发展特色的泛型等高级范式；Python语言更是形成了Pythonic规则来指导Python程序员写出符合Python思维或惯用法的代码。经验告诉我们，但凡属于某个编程语言的高质量范畴的代码，其必定是在这种编程语言原生思维下编写的代码。

如果用A语言的思维去编写B语言的代码（比如用OO思维写C代码，用命令式的思维写Haskell代码等），那么你写出的代码多半无法被B语言社区所认可，更难以成为高质量代码的典范。并且，如果沿着这样的方向去学习和实践B语言，那么结果只能是南辕北辙，与编写出高质量代码的目标渐行渐远。

我们的目标是编写出高质量的Go代码，这就需要我们在学习语言的同时，不断学习Go语言原生的编程思维，时刻用Go编程思维考虑Go代码的设计和实现，这是通往高质量Go代码的必经之路。


### 小结
人类在通过自然语言交流和表达观点的漫长过程中，逐渐形成了固定的语言表述方法。除此之外，人类还利用肢体动作、眼神、表情、纸笔等辅助行为或工具来帮助语言的精确表达，并且在使用这些辅助行为和工具时形成了固定的使用方法，这些以这门语言为中心的固定的表述方法、辅助行为和工具用法总称为这门语言的惯用法，它们反映的就是该语言的思维方式。

编程语言也类似，以一门编程语言为中心的，以解决工程问题为目标的编程语言用法、辅助库、工具的固定使用方法称为该门编程语言的原生编程思维。

我们学习和使用一门编程语言，目标是用这门语言的原生思维方式编写高质量代码。学习Go，就要用Go的原生编程思维而不是用其他语言的思维方式写Go代码。掌握Go原生编程思维就是我们通往高质量Go编程的学习方向和必经之路，因此本书后面将从语言、标准库、工具链、工程实践等方面来全面介绍Go语言的原生编程思维，帮助大家打好编写高质量Go代码的基础。


---

# 第二部分　项目结构、代码风格与标识符命名

## 第5条　使用得到公认且广泛使用的项目结构

### 1. Go项目结构的最小标准布局

Go语言项目的技术负责人，Russ Cox在一个开源项目的issue中给出了他关于Go项目结构的最小标准布局[1]的想法。他认为Go项目的最小标准布局应该是这样的：

<pre>
// 在Go项目仓库根路径下

- go.mod
- LICENSE
- xx.go
- yy.go
...
</pre>
或
<pre>
- go.mod
- LICENSE
- package1
        - package1.go
- package2
        - package2.go
...
</pre>

pkg、cmd、docs这些目录不应该成为Go项目标准结构的一部分，至少不是必需的。笔者认为Russ Cox给出的最小标准布局与Go一贯崇尚的“简单”哲学是一脉相承的，这个布局很灵活，可以满足各种Go项目的需求。

非官方标准的建议结构布局

### 2. 以构建二进制可执行文件为目的的Go项目结构
一个支持（在cmd下）构建二进制可执行文件的典型Go项目的结构，我们分别来看一下各个重要目录的用途。

cmd目录：存放项目要构建的可执行文件对应的main包的源文件。如果有多个可执行文件需要构建，则将每个可执行文件的main包单独放在一个子目录中，比如图中的app1、app2。cmd目录下的各app的main包将整个项目的依赖连接在一起，并且通常来说，main包应该很简洁。我们会在main包中做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。有一些Go项目将cmd这个名字改为app，但其功用并没有变。

pkg目录：存放项目自身要使用并且同样也是可执行文件对应main包要依赖的库文件。该目录下的包可以被外部项目引用，算是项目导出包的一个聚合。有些项目将pkg这个名字改为lib，但该目录的用途不变。由于Go语言项目自身在1.4版本中去掉了pkg这一层目录，因此有一些项目直接将包平铺到项目根路径下，但笔者认为对于一些规模稍大的项目，过多的包会让项目顶层目录不再简洁，显得很拥挤，因此个人建议对于复杂的Go项目保留pkg目录。

Makefile：这里的Makefile是项目构建工具所用脚本的“代表”，它可以代表任何第三方构建工具所用的脚本。Go并没有内置如make、bazel等级别的项目构建工具，对于一些规模稍大的项目而言，项目构建工具似乎不可缺少。在Go典型项目中，项目构建工具的脚本一般放在项目顶层目录下，比如这里的Makefile；对于构建脚本较多的项目，也可以建立build目录，并将构建脚本的规则属性文件、子构建脚本放入其中。

go.mod和go.sum：Go语言包依赖管理使用的配置文件。Go 1.11版本引入Go module机制，Go 1.16版本中，Go module成为默认的依赖包管理和构建机制。因此对于新的Go项目，建议基于Go module进行包依赖管理。对于没有使用Go module进行包管理的项目（可能主要是一些使用Go 1.11以前版本的Go项目），这里可以换为dep的Gopkg.toml和Gopkg.lock，或者glide的glide.yaml和glide.lock等。

vendor目录（可选）：vendor是Go 1.5版本引入的用于在项目本地缓存特定版本依赖包的机制。在引入Go module机制之前，基于vendor可以实现可重现的构建（reproducible build），保证基于同一源码构建出的可执行程序是等价的。Go module本身就可以实现可重现的构建而不需要vendor，当然Go module机制也保留了vendor目录（通过go mod vendor可以生成vendor下的依赖包；通过go build -mod=vendor可以实现基于vendor的构建），因此这里将vendor目录视为一个可选目录。一般我们仅保留项目根目录下的vendor目录，否则会造成不必要的依赖选择的复杂性。

Go 1.11引入的module是一组同属于一个版本管理单元的包的集合。Go支持在一个项目/仓库中存在多个module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。因此，如果项目结构中存在版本管理的“分歧”，比如app1和app2的发布版本并不总是同步的，那么笔者建议将项目拆分为多个项目（仓库），每个项目单独作为一个module进行版本管理和演进。

### 3. 以只构建库为目的的Go项目结构

库类型项目结构与Go项目的最小标准布局也是兼容的，但比以构建二进制可执行文件为目的的Go项目要简单一些。

去除了cmd和pkg两个子目录：由于仅构建库，没必要保留存放二进制文件main包源文件的cmd目录；由于Go库项目的初衷一般都是对外部（开源或组织内部公开）暴露API，因此也没有必要将其单独聚合到pkg目录下面了。

vendor不再是可选目录：对于库类型项目而言，不推荐在项目中放置vendor目录去缓存库自身的第三方依赖，库项目仅通过go.mod（或其他包依赖管理工具的manifest文件）明确表述出该项目依赖的模块或包以及版本要求即可。

### 4. 关于internal目录

无论是上面哪种类型的Go项目，对于不想暴露给外部引用，仅限项目内部使用的包，在项目结构上可以通过Go 1.4版本中引入的internal包机制来实现。以库项目为例，最简单的方式就是在顶层加入一个internal目录，将不想暴露到外部的包都放在该目录下，比如下面项目结构中的ilib1、ilib2

<pre>
// 带internal的Go库项目结构

$tree -F ./chapter2/sources/GoLibProj
GoLibProj
├── LICENSE
├── Makefile
├── README.md
├── go.mod
├── internal/
│  ├── ilib1/
│  └── ilib2/
├── lib.go
├── lib1/
│  └── lib1.go
└── lib2/
      └── lib2.go
</pre>

这样，根据Go internal机制的作用原理，internal目录下的ilib1、ilib2可以被以GoLibProj目录为根目录的其他目录下的代码（比如lib.go、lib1/lib1.go等）所导入和使用，但是却不可以为GoLibProj目录以外的代码所使用，从而实现选择性地暴露API包。当然internal也可以放在项目结构中的任一目录层级中，关键是项目结构设计人员明确哪些要暴露到外层代码，哪些仅用于同级目录或子目录中。

对于以构建二进制可执行文件类型为目的的项目，我们同样可以将不想暴露给外面的包聚合到项目顶层路径下的internal下，与暴露给外部的包的聚合目录pkg遥相呼应。

### 小结
以上两个针对构建二进制可执行文件类型以及库类型的项目参考结构是Go社区在多年实践后得到公认且使用较为广泛的项目结构，并且它们与Russ Cox提出的Go项目最小标准布局是兼容的，对于稍大型的Go项目来说很有参考价值。

上述参考项目结构与产品设计开发领域的最小可行产品（Minimum Viable Product，MVP）的思路异曲同工，开发者可以在这样一个最小的项目结构核心的基础上根据实际需要进行扩展。


## 第6条　提交前使用gofmt格式化源码

### 6.1　gofmt：Go语言在解决规模化问题上的最佳实践
gofmt的代码风格不是某个人的最爱，而是所有人的最爱。——Rob Pike

gofmt代码风格已经成为Go开发者的共识，融入Go语言的开发文化当中，以至于多数Go开发者可能说不出gofmt代码风格是什么样的，因为代码会被gofmt自动变成那种风格，大家已经不再关心风格。gofmt是Go语言在解决规模化问题上的一个最佳实践，并成为Go语言吸引其他语言开发者的一大亮点。很多主流语言在效仿Go语言而推出自己的格式化工具

### 6.2　使用gofmt
gofmt最大的特点是没有提供任何关于代码风格设置的命令行选项和参数，这样Go开发人员就无法通过设置命令行特定选项来定制自己喜好的风格。不过gofmt却提供了足够在工程上对代码进行按格式查找、代码重构的命令行选项。

1. 使用gofmt -s选项简化代码
后续版本语法升级、或者简单写法等
2. 使用gofmt -r执行代码“微重构”
代码重构是软件工程过程中的日常操作，Go语言曾经为了支持大规模软件的全局重构加入了类型别名（type alias）语法。gofmt除了具有格式化代码的功能外，对代码重构也具有一定的支撑能力。我们可以通过-r命令行选项对代码进行表达式级别的替换，以达到重构的目的。

```bash
$gofmt -r 'a[3:len(a)] -> a[3:]' -w chapter2/sources/gofmt_demo.go
```
上述命令中的a并不是一个具体的字符，而是代表的一个通配符。出现在'pattern -> replacement'中的小写字母都会被视为通配符

3. 使用gofmt -l按格式要求输出满足条件的文件列表

### 6.3　使用goimports
goimports在gofmt功能的基础上增加了对包导入列表的维护功能，可根据源码的最新变动自动从导入包列表中增删包。

### 6.4　将gofmt/goimports与IDE或编辑器工具集成

## 第7条　使用Go命名惯例对标识符进行命名
计算机科学中只有两件难事：缓存失效和命名。——Phil Karlton，Netscape架构师

Go的设计哲学之一就是追求简单，它在命名上一样秉承着简单的总体原则。但简单并不意味着一味地为标识符选择短小的名字，而是要选择那种可以在标识符所在上下文中保持其用途清晰明确的名字。Go及其标准库的实现是Go命名惯例形成的源头，因此如果要寻找良好命名的示范，Go标准库是一个不错的地方。本条中的示例主要来自Go标准库代码，一些结论来自对标准库代码的分析。

要想做好Go标识符的命名（包括对包的命名），至少要遵循两个原则：简单且一致；利用上下文辅助命名。

### 7.1　简单且一致

对于简单，我们最直观的理解就是“短小”，但这里的简单还包含着清晰明确这一前提。短小意味着能用一个单词命名的，就不要使用单词组合；能用单个字母（在特定上下文中）表达标识符用途的，就不用完整单词。甚至在某种情况下，Go命名惯例选择了简洁命名+注释辅助解释的方式，而不是一个长长的名字。

1. 包对于Go中的包（package），一般建议以小写形式的单个单词命名。

Go语言建议，包名应尽量与包导入路径（import path）的最后一个路径分段保持一致。比如：包导入路径golang.org/x/text/encoding的最后路径分段是encoding，该路径下包名就应该为encoding。

但在实际情况中，包名与导入路径最后分段不同的也有很多。比如：实时分布式消息队列NSQ的官方客户端包的导入路径为github.com/nsqio/go-nsq，但是该路径下面的包名却是nsq。笔者分析这主要是为了用仓库名称强调该实现是针对Go语言的，比如go-nsq的意义是这是一份Go语言实现的NSQ客户端API库，为的是与nsq-java、pynsq、rust-nsq等其他语言的客户端API进行显式区分。

那如果将NSQ的Go客户端API放入github.com/nsqio/go-nsq/nsq下是否更理想呢？显然在导入路径中出现两次“nsq”字样的这种“口吃”现象也是不被Go官方推荐的。

我们在给包命名的时候，不仅要考虑包自身的名字，还要兼顾该包导出的标识符（如变量、常量、类型、函数等）的命名。由于对这些包导出标识符的引用必须以包名为前缀，因此对包导出标识符命名时，在名字中不要再包含包名

<pre>
strings.Reader              [good]
strings.StringReader        [bad]
strings.NewReader           [good]
strings.NewStringReader     [bad]

bytes.Buffer                [good]
bytes.ByteBuffer            [bad]
bytes.NewBuffer             [good]
bytes.NewByteBuffer         [bad]
</pre>


2. 变量、类型、函数和方法
Go语言官方要求标识符命名采用驼峰命名法（CamelCase），以变量名为例，如果变量名由一个以上的词组合构成，那么这些词之间紧密相连，不使用任何连接符（如下划线）。

不过如果缩略词的首字母是大写的，那么其他字母也要保持全部大写，比如HTTP（Hypertext Transfer Protocol）

我们看到了大量单字母的标识符命名，这是Go在命名上的一个惯例。一般来说，Go标识符仍以单个单词作为命名首选。

从Go标准库代码的不完全统计结果来看，不同类别标识符的命名呈现出以下特征：
循环和条件变量多采用单个字母命名（具体见上面的统计数据）；
函数/方法的参数和返回值变量以单个单词或单个字母为主；
由于方法在调用时会绑定类型信息，因此方法的命名以单个单词为主；函
数多以多单词的复合词进行命名；类型多以多单词的复合词进行命名。
除了上述特征，还有一些在命名时常用的惯例。

Go语言中有大量单字母、单个词或缩写命名的简短命名变量。有人可能会认为简短命名变量会降低代码的可读性。Go语言建议通过保持一致性来维持可读性。一致意味着代码中相同或相似的命名所传达的含义是相同或相似的，这样便于代码阅读者或维护者猜测出变量的用途。

变量v、k、i的常用含义


```go
// 循环语句中的变量
for i, v := range s { ... }           // i为下标变量; v为元素值
for k, v := range m { ... }           // k为key变量; v为元素值
for v := range r { // channel ... }   // v为元素值

// if、switch/case分支语句中的变量
if v := mimeTypes[ext]; v != "" { }   // v: 元素值
switch v := ptr.Elem(); v.Kind() {
    ...
}

case v := <-c:                        // v: 元素值

// 反射的结果值
v := reflect.ValueOf(x)

t := time.Now()                            // 时间
t := &Timer{}                              // 定时器
if t := md.typemap[off]; t != nil { }      // 类型

b := make([]byte, n)                       // byte切片
b := new(bytes.Buffer)                     // byte缓存
```

3. 常量
在Go语言中，常量在命名方式上与变量并无较大差别，并不要求全部大写。只是考虑其含义的准确传递，常量多使用多单词组合的方式命名。
对名称本身就是全大写的特定常量使用全大写的名字，比如数学计算中的PI，或是为了与系统错误码、系统信号名称保持一致而用全大写方式命名

4. 接口
在Go语言中，对于接口类型优先以单个单词命名。对于拥有唯一方法（method）或通过多个拥有唯一方法的接口组合而成的接口，Go语言的惯例是用“方法名+er”命名。比如：

```go
// $GOROOT/src/io/io.go

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Reader interface {
    Read(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

Go语言推荐尽量定义小接口，并通过接口组合的方式构建程序 !!!

### 7.2　利用上下文环境，让最短的名字携带足够多的信息

Go在给标识符命名时还有着考虑上下文环境的惯例，即在不影响可读性的前提下，兼顾一致性原则，尽可能地用短小的名字命名标识符。这与其他一些主流语言在命名上的建议有所不同，比如Java建议遵循“见名知义”的命名原则。我们可以对比一下Java和Go在循环变量命名上的差异

在Go代码中来分别运用这两个命名方案并做比对

```go

for index := 0; index < len(s); index++ {
    value := s[index]
    ...
}

// vs

for i := 0; i < len(s); i++ {
    v := s[i]
    ...
}
```

### 小结
Go语言命名惯例深受C语言的影响，这与Go语言之父有着深厚的C语言背景不无关系。Go语言追求简单一致且利用上下文辅助名字信息传达的命名惯例，如果你刚从其他语言转向Go，这可能会让你感到不适应，但这就是Go语言文化的一部分，也许等你编写的Go代码达到一定的量，你就能理解这种命名惯例的好处了。

----


# 第三部分　声明、类型、语句与控制结构

本部分将详述在Go基础语法层面有哪些高质量Go代码的惯用法和有效实践，内容涵盖变量声明、无类型常量的作用、枚举常量的定义、零值可用类型的意义、高频使用类型字符串/切片/map的实现原理及惯用法、Go包导入路径的真正含义以及对语句和控制结构的深入理解等。

## 第8条　使用一致的变量声明形式

Go语言常见的变量声明形式：
```go
var a int32
var s string = "hello"
var i = 13
n := 17
var (
    crlf       = []byte("\r\n")
    colonSpace = []byte(": ")
)
```

如果让Go语言的设计者重新设计一次变量声明语法，相信他们很大可能不会再给予Gopher这么大的变量声明灵活性，但目前这一切都无法改变。对于以面向工程著称且以解决规模化问题为目标的Go语言，Gopher在变量声明形式的选择上应尽量保持项目范围内一致。

Go语言有两类变量。
包级变量（package variable）：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。
局部变量（local variable）：函数或方法体内声明的变量，仅在函数或方法体内可见。

### 8.1　包级变量的声明形式

包级变量只能使用带有var关键字的变量声明形式

1. 声明并同时显式初始化

如果不接受默认类型，而是要显式为包级变量a和f指定类型，那么有以下两种声明方式：
```go
// 第一种
var a int32 = 17
var f float32 = 3.14

// 第二种
var a = int32(17)
var f = float32(3.14)
```

从声明一致性的角度出发，Go语言官方更推荐后者，这样就统一了接受默认类型和显式指定类型两种声明形式。尤其是在将这些变量放在一个var块中声明时，我们更青睐这样的形式：

```go
var (
    a = 17
    f = float32(3.14)
)
```

2. 声明但延迟初始化
虽然没有显式初始化，但Go语言会让这些变量拥有初始的“零值”。如果是自定义的类型，保证其零值可用是非常必要的，这一点将在后文中详细说明。

3. 声明聚类与就近原则

Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中；或者将延迟初始化的变量声明放在一个var块，而将声明并显式初始化的变量放在另一个var块中。笔者称之为“声明聚类”。

是否应当将包级变量的声明全部集中放在源文件头部呢？使用静态编程语言的开发人员都知道，变量声明最佳实践中还有一条：就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。

我们看到在request.go的Cookie方法中使用了ErrNoCookie这个变量，而这个包级变量被就近安排在临近该方法定义的位置进行声明。之所以这么做，可能考虑到的一点是在这个源文件中，仅Cookie方法用到了变量ErrNoCookie。如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合。

### 8.2　局部变量的声明形式
与包级变量相比，局部变量多了一种短变量声明形式，这也是局部变量采用最多的一种声明形式。

1. 对于延迟初始化的局部变量声明，采用带有var关键字的声明形式

另一种常见的采用带var关键字声明形式的变量是error类型的变量err（将error类型变量实例命名为err也是Go的一个惯用法），尤其是当defer后接的闭包函数需要使用err判断函数/方法退出状态时。

```go
func Foo() {
    var err error
    defer func() {
        if err != nil {
            ...
        }
    }()

    err = Bar()
    ...
}
```
2. 对于声明且显式初始化的局部变量，建议使用短变量声明形式
对于不接受默认类型的变量，依然可以使用短变量声明形式，只是在“:=”右侧要进行显式转型
```go
a := int32(17)
f := float32(3.14)
s := []byte("hello, gopher!")
```
3. 尽量在分支控制时应用短变量声明形式
在编写Go代码时，我们很少单独声明在分支控制语句中使用的变量，而是通过短变量声明形式将其与if、for等融合在一起
这样的应用方式体现出“就近原则”，让变量的作用域最小化了。

由于良好的函数/方法设计讲究的是“单一职责”，因此每个函数/方法规模都不大，很少需要应用var块来聚类声明局部变量。当然，如果你在声明局部变量时遇到适合聚类的应用场景，你也应该毫不犹豫地使用var块来声明多个局部变量。

```go
// $GOROOT/src/net/dial.go
func (r *Resolver) resolveAddrList(ctx context.Context, op, network,
                            addr string, hint Addr) (addrList, error) {
    ...
    var (
        tcp      *TCPAddr
        udp      *UDPAddr
        ip       *IPAddr
        wildcard bool
    )
    ...
}
```

### 小结
使用一致的变量声明是Go语言的一个最佳实践，我们用图8-1来对变量声明形式做个形象的小结。


## 第9条　使用无类型常量简化代码

```go
// $GOROOT/src/io/io.go
const (
    SeekStart   = 0
    SeekCurrent = 1
    SeekEnd     = 2
)
```

### 9.2　有类型常量带来的烦恼


>> Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型

>> Go在处理不同类型的变量间的运算时不支持隐式的类型转换

>> 隐式转换带来的便利性不足以抵消其带来的诸多问题


###  9.3 无类型常量消除烦恼，简化代码

>> 9.3　无类型常量消除烦恼，简化代码

>> Go的无类型常量恰恰就拥有像字面值这样的特性，该特性使得无类型常量在参与变量赋值和计算过程时无须显式类型转换，从而达到简化代码的目的：

>> 无类型常量也拥有自己的默认类型：无类型的布尔型常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对应的默认类型分别为bool、int、int32(rune)、float64、complex128和string。

>> 常量的默认类型对于确定无类型变量的类型及接口对应的动态类型是至关重要的

### 小结

+ 所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。


## 第10条 使用iota实现枚举常量

>> Go语言没有提供定义枚举常量的语法。我们通常使用常量语法定义枚举常量

>> Go的const语法提供了“隐式重复前一个非空表达式”的机制

```go
const (    
    Apple, Banana = 11, 22    
    Strawberry, Grape    
    Pear, Watermelon
    )
```
>> 等价于：
```go
 const (    
    Apple, Banana = 11, 22    
    Strawberry, Grape  = 11, 22    
    Pear, Watermelon  = 11, 22
    )
``` 

>> Go在这个机制的基础上又提供了神器iota。

>> iota是Go语言的一个预定义标识符，它表示的是const声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。

>> 位于同一行的iota即便出现多次，其值也是一样的：

```go
 const (    
    _ = iota      // 0    
    Pin1    
    Pin2    
    Pin3    
    _   // 相当于_ = iota，略过了4这个枚举值    
    Pin5    // 5
    )
```
```go
const (   
     _ = iota    
     Blue    
     Black    
     Red    
     Yellow
     )
```
+ 枚举常量多数是无类型常量，如果要严格考虑类型安全，也可以定义有类型枚举常量
```go
// $GOROOT/src/time/time.go
type Weekday intconst (    
    Sunday 
    Weekday = iota    
    Monday    
    Tuesday    
    Wednesday    
    Thursday    
    Friday    
    Saturday
    )
```

## 第11条 尽量定义零值可用的类型

>> 第11条　尽量定义零值可用的类型保持零值可用。——Go谚语[1]


### 11.1 Go类型的零值

+ 当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值

+ Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）。所有整型类型：0浮点类型：0.0布尔类型：false字符串类型：""指针、interface、切片（slice）、channel、map、function：nil

+ Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。


### 11.2 零值可用

+ 在Go标准库和运行时代码中还有很多践行“零值可用”理念的好例子，最典型的莫过于sync.Mutex和bytes.Buffer了。

+ 但是在Go语言中，我们只需这么做：var mu sync.Mutexmu.Lock()mu.Unlock()

+ Go标准库的设计者很贴心地将sync.Mutex结构体的零值设计为可用状态，让Mutex的调用者可以省略对Mutex的初始化而直接使用Mutex。
```go
func main() {    
    var b bytes.Buffer    
    b.Write([]byte("Effective Go"))    
    fmt.Println(b.String()) // 输出：Effective Go
}
```
可以看到，我们无须对bytes.Buffer类型的变量b进行任何显式初始化，即可直接通过b调用Buffer类型的方法进行写入操作。这是因为bytes.Buffer结构体用于存储数据的字段buf支持零值可用策略的切片类型：
```go
// $GOROOT/src/bytes/buffer.go
type Buffer struct {    
    buf      []byte    
    off      int    
    lastRead readOp
}
```
### 小结

+ Go语言零值可用的理念给内置类型、标准库的使用者带来很多便利。不过Go并非所有类型都是零值可用的，并且零值可用也有一定的限制，比如：在append场景下，零值可用的切片类型不能通过下标形式操作数据：

+ 像map这样的原生类型也没有提供对零值可用的支持

+ 另外零值可用的类型要注意尽量避免值复制：

+ 我们可以通过指针方式传递类似Mutex这样的类型：
```go
var mu 
sync.Mutexfoo(&mu) // 正确
```


## 第12条 使用复合字面值作为初值构造器

+ Go语言中的复合类型包括结构体、数组、切片和map。

+ Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。

```go
s := myStruct{"tony", 23}
a := [5]int{13, 14, 15, 16, 17}
sl := []int{23, 24, 25, 26, 27}
m := map[int]string {1:"hello", 2:"gopher", 3:"!"}
```
显然，最初的代码得到了大幅简化。


### 12.1 结构体复合字面值

>> Go推荐使用field:value的复合字面值形式对struct类型变量进行值构造

>> Go标准库中，通过field:value格式的复合字面值进行结构体类型变量初值构造的例子比比皆是


### 12.3 map复合字面值

+ 和结构体、数组/切片相比，map类型变量使用复合字面值作为初值构造器就显得自然许多，因为map类型具有原生的key:value构造形式

>> // Go 1.5及之后版本
```go
m := map[Point]string{    
    {29.935523, 52.891566}:   "Persepolis",    
    {-25.352594, 131.034361}: "Uluru",    
    {37.422455, -122.084306}: "Googleplex",
}
```
>> 对于key或value为指针类型的情况，也可以省略“&T”

### 小结
+ 对于零值不适用的场景，我们要为变量赋予一定的初值。对于复合类型，我们应该首选Go提供的复合字面值作为初值构造器。对于不同复合类型，我们要记住下面几点：使用field:value形式的复合字面值为结构体类型的变量赋初值；在为稀疏元素赋值或让编译器推导数组大小的时候，多使用index:value的形式为数组/切片类型变量赋初值；使用key:value形式的复合字面值为map类型的变量赋初值。（Go 1.5版本后，复合字面值中的key和value类型均可以省略不写。）


## 第13条 了解切片实现原理并高效使用


>> 每当你花费大量时间使用某种特定工具时，深入了解它并了解如何高效地使用它是很值得的。——佚名


### 13.1 切片究竟是什么

+ Go数组是值语义的，这意味着一个数组变量表示的是整个数组，这点与C语言完全不同。在C语言中，数组变量可视为指向数组第一个元素的指针。而在Go语言中传递数组是纯粹的值拷贝，对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗。这时很多人会使用数组指针类型来定义函数参数，然后将数组地址传进函数，这样做的确可以避免性能损耗，但这是C语言的惯用法，在Go语言中，更地道的方式是使用切片。

+ 切片之于数组就像是文件描述符之于文件。在Go语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色；而切片则走向“前台”，为底层的存储（数组）打开了一个访问的“窗口”

+ 因此，我们可以称切片是数组的“描述符”。切片之所以能在函数参数传递时避免较大性能损耗，是因为它是“描述符”的特性，切片这个描述符是固定大小的，无论底层的数组元素类型有多大，切片打开的窗口有多长。

+ 下面是切片在Go运行时（runtime）层面的内部表示：
```go
//$GOROOT/src/runtime/slice.go
type slice struct {    
    array unsafe.Pointer    
    len   int    
    cap   int
}
```

+ 我们看到每个切片包含以下三个字段。
array：指向下层数组某元素的指针，该元素也是切片的起始元素。
len：切片的长度，即切片中当前元素的个数。
cap：切片的最大容量，cap >= len。

在运行时中，每个切片变量都是一个runtime.slice结构体类型的实例

>> 图13-2展示了切片s在运行时层面的内部表示。[插图]图13-2　切片运行时表示（新切片）

>> 图13-3展示了切片s的内部。

图13-3　切片运行时表示（以已有数组为底层存储的切片）

>> 三个切片s1、s2、s3都是数组u的描述符，因此无论通过哪个切片对数组进行的修改操作都会反映到其他切片中。

+ 还可以通过语法s[low: high]基于已有切片创建新的切片，这被称为切片的reslicing，

+ 新创建的切片与原切片同样是共享底层数组的，并且通过新切片对数组的修改也会反映到原切片中。

+ 当切片作为函数参数传递给函数时，实际传递的是切片的内部表示，也就是上面的runtime.slice结构体实例，因此无论切片描述的底层数组有多大，切片作为参数传递带来的性能损耗都是很小且恒定的，甚至小到可以忽略不计，这就是函数在参数中多使用切片而不用数组指针的原因之一。

+ 而另一个原因就是切片可以提供比指针更为强大的功能，比如下标访问、边界溢出校验、动态扩容等。而C程序员最喜爱的指针本身在Go语言中的功能受到了限制，比如不支持指针算术运算等。


### 13.2 切片的高级特性：动态扩容


+ 零值切片也可以通过append预定义函数进行元素赋值操作：
```go
var s []byte // s被赋予零值nil
s = append(s, 1)
```
由于初值为零值，s这个描述符并没有绑定对应的底层数组。而经过append操作后，s显然已经绑定了属于它的底层数组。

+ append会根据切片对底层数组容量的需求对底层数组进行动态调整。

+ append会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新的数组，新数组长度会按一定算法扩展（参见$GOROOT/src/runtime/slice.go中的growslice函数）

+ 新数组建立后，append会把旧数组中的数据复制到新数组中，之后新数组便成为切片的底层数组，旧数组后续会被垃圾回收掉。这样的append操作有时会给Gopher带来一些困惑，比如通过语法u[low: high]形式进行数组切片化而创建的切片，一旦切片cap触碰到数组的上界，再对切片进行append操作，切片就会和原数组解除绑定


### 13.3 尽量使用cap参数创建切片


+ append操作是一件利器，它让切片类型部分满足了“零值可用”的理念。但从append的原理中我们也能看到重新分配底层数组并复制元素的操作代价还是挺大的，尤其是当元素较多的情况下。那么如何减少或避免为过多内存分配和复制付出的代价呢？一种有效的方法是根据切片的使用场景对切片的容量规模进行预估，并在创建新切片时将预估出的切片容量数据以cap参数的形式传递给内置函数make：
s := make([]T, len, cap)

+ 使用带cap参数创建的切片进行append操作的平均性能（9250ns）是不带cap参数的切片（36 484ns）的4倍左右，并且每操作平均仅需一次内存分配。
因此，如果可以预估出切片底层数组需要承载的元素数量，强烈建议在创建切片时带上cap参数。

+ 在可以预估出元素容量的前提下，使用cap参数创建切片可以提升append的平均操作性能，减少或消除因动态扩容带来的性能损耗。


## 第14条 了解map实现原理并高效使用


### 14.1 什么是map

+ map对value的类型没有限制，但是对key的类型有严格要求：key的类型应该严格定义了作为“==”和“!=”两个操作符的操作数时的行为，因此函数、map、切片不能作为map的key类型。

>> map类型不支持“零值可用”，未显式赋初值的map类型变量的零值为nil。对处于零值状态的map变量进行操作将会导致运行时panic：

>> 我们必须对map类型变量进行显式初始化后才能使用它。和切片一样，创建map类型变量有两种方式：一种是使用复合字面值，另一种是使用make这个预声明的内置函数。

+ 和切片一样，map也是引用类型，将map类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对map变量的修改在函数外部也是可见的


### 14.2 map的基本操作

>> 和切片一样，map也可以通过内置函数len获取当前已经存储的数据个数

+ 所谓查找就是判断某个key是否存在于某个map中。我们可以使用“comma ok”惯用法来进行查找：
```go
_, ok := m["key"] if !ok {    
    // "key"不在map中
}
```    

>> 如果key不存在于map中（如“key3”），我们看到v仍然被赋予了一个“合法”值0，这个值是value类型int的零值。在这样的情况下，我们无法判定这个0是“key3”对应的值还是因“key3”不存在而返回的零值。为此我们还需要借助“comma ok”惯用法：
```go
m := map[string]int v, ok := m["key"] if !ok {    
    // "key"不在map中
}
fmt.Println(v)
```
+ 综上，Go语言的一个最佳实践是总是使用“comma ok”惯用法读取map中的值。

>> 借助内置函数delete从map中删除数据

>> delete(m, "key2")

>> 即便要删除的数据在map中不存在，delete也不会导致panic。

>> 通过for range语句对map中的数据进行遍历

>> Go运行时在初始化map迭代器时对起始位置做了随机处理。因此千万不要依赖遍历map所得到的元素次序。

+ 如果你需要一个稳定的遍历次序，那么一个比较通用的做法是使用另一种数据结构来按需要的次序保存key，比如切片
```go
func main() {    
    var sl []int    
    m := map[int]int{        
        1: 11,        
        2: 12,        
        3: 13,    
    }    
    for k, _ := range m {        
        sl = append(sl, k) // 将元素按初始次序保存在切片中    
    }    
    for i := 0; i < 3; i++ {        
        doIteration(sl, m)    
    }
}
```

### 14.3 map的内部实现


>> 和切片的运行时表示相比，map在运行时的表示显然要复杂得多。

>> 简要

>> 描述一下map在运行时层的实现原理（基于Go 1.12版本）

>> 
图14-1　运行时的map类型实现

>> 如果key或value的数据长度大于一定数值，那么运行时不会在bucket中直接存储数据，而是会存储key或value数据的指针。

>> 前面提到过，map会对底层使用的内存进行自动管理。因此，在使用过程中，在插入元素个数超出一定数值后，map势必存在自动扩容的问题（扩充bucket的数量），并重新在bucket间均衡分配数据。

>> 个LoadFactor（负载因子），当count > LoadFactor * 2^B或overflow bucket过多时，运行时会对map进行扩容。目前LoadFactor设置为6.5（loadFactorNum/loadFactorDen）

>> 充当map描述符角色的hmap实例自身是有状态的（hmap.flags）且对状态的读写是没有并发保护的，因此map实例不是并发写安全的，不支持并发读写

>> 。如果对map实例进行并发读写，程序运行时会发生panic。

>> go run map_concurrent_read_and_write.gofatal error: concurrent map iteration and map write

>> 如果仅仅是并发读，则map是没有问题的。

>> Go 1.9版本中引入了支持并发写安全的sync.Map类型，可以用来在并发读写的场景下替换掉map。另外考虑到map可以自动扩容，map中数据元素的value位置可能在这一过程中发生变化，因此Go不允许获取map中value的地址，这个约束是在编译期间就生效的。


### 14.4 尽量使用cap参数创建map


>> 如果可能的话，我们最好对map使用规模做出粗略的估算，并使用cap参数对map实例进行初始化。

+ 使用cap参数的map实例的平均写性能是不使用cap参数的2倍。

### 小结
和切片一样，map是Go语言提供的重要数据类型，也是Gopher日常编码中最常使用的类型之一。通过本条的学习我们掌握了map的基本操作和运行时实现原理，并且我们在日常使用map的场合要把握住下面几个要点：不要依赖map的元素遍历顺序；map不是线程安全的，不支持并发写；不要尝试获取map中元素（value）的地址；尽量使用cap参数创建map，以提升map平均访问性能，减少频繁扩容带来的不必要损耗。


## 第15条 了解string实现原理并高效使用


>> 字符串类型是现代编程语言中最常使用的数据类型之一。在Go语言的先祖之一C语言当中，字符串类型并没有被显式定义，而是以字符串字面值常量或以'\0'结尾的字符类型（char）数组来呈现的：
```C
#define GOAUTHERS "Robert Griesemer, Rob Pike, and Ken Thompson"
const char * s = "hello world"
char s[] = "hello gopher"
```
这给C程序员在使用字符串时带来一些问题，诸如：类型安全性差；字符串操作要时时刻刻考虑结尾的'\0'；字符串数据可变（主要指以字符数组形式定义的字符串类型）；获取字符串长度代价大（O(n)的时间复杂度）；未内置对非ASCII字符（如中文字符）的处理。Go语言修复了C语言的这一“缺陷”，内置了string类型，统一了对字符串的抽象。


### 15.1 Go语言的字符串类型

+ `sl := []byte(s)`

+ 对string进行切片化后，Go编译器会为切片变量重新分配底层存储而不是共用string的底层存储，因此对切片的修改并未对原string的数据产生任何影响。

>> 通过unsafe指针指向string在运行时内部表示结构（具体参考本条后面的讲解）中的数据存储块的地址，然后通过指针修改那块内存中存储的数据。运行这段程序得到下面的结果：
`$go run string_immutable2.gooriginal string: hello0x10d1b9d => hunexpected fault address 0x10d1b9dfatal error: fault[signal SIGBUS: bus error code=0x2 addr=0x10d1b9d pc=0x109b079]`
我们看到，对string的底层的数据存储区仅能进行只读操作，一旦试图修改那块区域的数据，便会得到SIGBUS的运行时错误，对string数据的“篡改攻击”再次以失败告终。

>> Go语言源文件默认采用的Unicode字符集。Unicode字符集是目前市面上最流行的字符集，几乎囊括了所有主流非ASCII字符（包括中文字符）。Go字符串的每个字符都是一个Unicode字符，并且这些Unicode字符是以UTF-8编码格式存储在内存当中的。我们来看一个例子：

>> Go语言源文件默认采用的Unicode字符集。Unicode字符集是目前市面上最流行的字符集，几乎囊括了所有主流非ASCII字符（包括中文字符）。Go字符串的每个字符都是一个Unicode字符，并且这些Unicode字符是以UTF-8编码格式存储在内存当中的。

>> Go语言直接提供了通过反引号构造“所见即所得”的多行字符串的方法：


### 15.2 字符串的内部表示

```go
 // $GOROOT/src/runtime/string.go 
type stringStruct struct {    
    str unsafe.Pointer    
    len int
}
 ```
 我们看到string类型也是一个描述符，它本身并不真正存储数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成。

>> 下面是runtime包中实例化一个字符串对应的函数：
```go
// $GOROOT/src/runtime/string.go 
func rawstring(size int) (s string, b []byte) {    
    p := mallocgc(uintptr(size), nil, false)    
    stringStructOf(&s).str = p    
    stringStructOf(&s).len = size    
    *(*slice)(unsafe.Pointer(&b)) = slice{p, size, size}    
    return
}
```
我们用图15-1来表示函数rawstring调用后的一个string实例的状态。[插图]图15-1　string类型在运行时的表示

>> 我们看到每个字符串类型变量/常量对应一个stringStruct实例，经过rawstring实例化后，stringStruct中的str指针指向真正存储字符串数据的底层内存区域，len字段存储的是字符串的长度（这里是5）；rawstring同时还创建了一个临时slice，该slice的array指针也指向存储字符串数据的底层内存区域。注意，rawstring调用后，新申请的内存区域还未被写入数据，该slice就是供后续运行时层向其中写入数据（"hello"）用的。写完数据后，该slice就可以被回收掉了，这也是图15-1中将slice结构以虚线框表示的原因。

>> 根据string在运行时的表示可以得到这样一个结论：直接将string类型通过函数/方法参数传入也不会有太多的损耗，因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。

>> 直接传入string与传入string指针两者的基准测试结果几乎一模一样，因此Gopher大可放心地直接使用string作为函数/方法参数类型。


### 15.3 字符串的高效构造

>> •  使用fmt.Sprintf；
•  使用strings.Join；
•  使用strings.Builder；
•  使用bytes.Buffer。

+  做了预初始化的strings.Builder连接构建字符串效率最高；
•  带有预初始化的bytes.Buffer和strings.Join这两种方法效率十分接近，分列二三位；
•  未做预初始化的strings.Builder、bytes.Buffer和操作符连接在第三档次；
•  fmt.Sprintf性能最差，排在末尾。

+ 可以得出一些结论：
•  在能预估出最终字符串长度的情况下，使用预初始化的strings.Builder连接构建字符串效率最高；
•  strings.Join连接构建字符串的平均性能最稳定，如果输入的多个字符串是以[]string承载的，那么strings.Join也是不错的选择；
•  使用操作符连接的方式最直观、最自然，在编译器知晓欲连接的字符串个数的情况下，使用此种方式可以得到编译器的优化处理；
•  fmt.Sprintf虽然效率不高，但也不是一无是处，如果是由多种不同类型变量来构建特定格式的字符串，那么这种方式还是最适合的。


### 15.4 字符串相关的高效转换

+ string和[]rune、[]byte可以双向转换

+ 无论是string转slice还是slice转string，转换都是要付出代价的，这些代价的根源在于string是不可变的，运行时要为转换后的类型分配新内存，在string与byte slice互转的过程中都要有一次内存分配操作。

+ 在Go运行时层面，字符串与rune slice、byte slice相互转换对应的函数如下：
```go
// $GOROOT/src/runtime/string.go 
slicebytetostring: 
[]byte -> string
slicerunetostring: 
[]rune -> string
stringtoslicebyte: 
string -> []byte
stringtoslicerune: 
string -> []rune
```

+ 以byte slice为例，看看slicebytetostring和stringtoslicebyte的实现：
```go
// $GOROOT/src/runtime/string.go 
const tmpStringBufSize = 32 
type tmpBuf [tmpStringBufSize]byte

func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil && len(s) <= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
		b = rawbyteslice(len(s))
	}
	copy(b, s)
	return b
}
```
+ 想要更高效地进行转换，唯一的方法就是减少甚至避免额外的内存分配操作

+ 看到运行时实现转换的函数中已经加入了一些避免每种情况都要分配新内存操作的优化（如tmpBuf的复用）。

+ slice类型是不可比较的，而string类型是可比较的，因此在日常Go编码中，我们会经常遇到将slice临时转换为string的情况。

+ Go编译器为这样的场景提供了优化。在运行时中有一个名为slicebytetostringtmp的函数就是协助实现这一优化的：
```go
// $GOROOT/src/runtime/string.go 
func slicebytetostringtmp(b []byte) 
```

+ 该函数的“秘诀”就在于不为string新开辟一块内存，而是直接使用slice的底层存储。当然使用这个函数的前提是：在原slice被修改后，这个string不能再被使用了。因此这样的优化是针对以下几个特定场景的。

+ （1）string(b)用在map类型的key中
```go
b := []byte{'k', 'e', 'y'}
m := make(map[string]string)
m[string(b)] = "value"
m[[3]string{string(b), "key1", "key2"}] = "value1"
```
+ （2）string(b)用在字符串连接语句中
```go
b := []byte{'t', 'o', 'n', 'y'}s := "hello " + string(b) + "!"
```
+ （3）string(b)用在字符串比较中
```go
s := "tom"
b := []byte{'t', 'o', 'n', 'y'}
if s < string(b) {    ...}
```

+ Go编译器对用在for-range循环中的string到[]byte的转换也有优化处理，它不会为[]byte进行额外的内存分配，而是直接使用string的底层数据。
```go
// chapter3/sources/string_for_range_covert_optimize.go 

func convert() {    
    s := "中国欢迎您，北京欢迎您"    
    sl := []byte(s)    
    for _, v := range sl {        
        _ = v    
        }
    }
func convertWithOptimize() {    
    s := "中国欢迎您，北京欢迎您"    
    for _, v := range []byte(s) {        
        _ = v    
    }
}
func main() {    
    fmt.Println(testing.AllocsPerRun(1, convert))    
    fmt.Println(testing.AllocsPerRun(1, convertWithOptimize))
}
```
运行这个例子程序：
`$go run string_for_range_covert_optimize.go10`

>> 从结果我们看到，convertWithOptimize函数将string到[]byte的转换放在for-range循环中，Go编译器对其进行了优化，节省了一次内存分配操作。
在如今强大的硬件算力面前，少数几次string和slice的转换代价可能微不足道。但能充分理解Go编译器对string和slice互转在特定场景下的优化依然是大有裨益的。在性能敏感的领域，这些优化也许能起到大作用。

+ Go语言还在标准库中提供了strings和strconv包，可以辅助Gopher对string类型数据进行更多高级操作。



## 第16条 理解Go语言的包导入


>> Go编译速度快的原因具体体现在以下三方面。
•  Go要求每个源文件在开头处显式地列出所有依赖的包导入，这样Go编译器不必读取和处理整个文件就可以确定其依赖的包列表。
•  Go要求包之间不能存在循环依赖，这样一个包的依赖关系便形成了一张有向无环图。由于无环，包可以被单独编译，也可以并行编译。
•  已编译的Go包对应的目标文件（file_name.o或package_name.a）中不仅记录了该包本身的导出符号信息，还记录了其所依赖包的导出符号信息。这样，Go编译器在编译某包P时，针对P依赖的每个包导入（比如导入包Q），只需读取一个目标文件即可（比如：Q包编译成的目标文件中已经包含Q包的依赖包的导出信息），而无须再读取其他文件中的信息。

>> import "github.com/nsqio/go-nsq"
但在使用该包提供的导出函数时，我们使用的不是go-nsq.xx而是nsq.xxx：
q, _ := nsq.NewConsumer("write_test", "ch", config)


### 16.1 Go程序构建过程

+ Go程序的构建简单来讲也是由编译（compile）和链接（link）两个阶段组成的。

>> 一个非main包在编译后会对应生成一个.a文件，该文件可以理解为Go包的目标文件，该目标文件实际上是通过pack工具（$GOROOT/pkg/tool/darwin_amd64/pack）对.o文件打包后形成的。默认情况下，在编译过程中.a文件生成在临时目录下，除非使用go install安装到$GOPATH/pkg下（Go 1.11版本之前），否则你看不到.a文件。如果是构建可执行程序，那么.a文件会在构建可执行程序的链接阶段起使用。
标准库包的源码文件在$GOROOT/src下面，而对应的.a文件存放在$GOROOT/pkg/darwin_amd64下（以macOS为例；如果是Linux系统，则是linux_amd64）

>> // Go 1.16$tree -FL 1 $GOROOT/pkg/darwin_amd64

>> 在使用第三方包的时候，在第三方包源码存在且对应的.a已安装的情况下，编译器链接的仍是根据第三方包最新源码编译出的.a文件，而不是之前已经安装到$GOPATH/pkg/darwin_amd64下的目标文件。

+ go build命令传入-x -v命令行选项来输出详细的构建日志信息

>> 可以看到app1的构建过程大致分为如下几步：
1）建立临时工作路径，命名为WORK，以后的编译、链接均以$WORK为当前工作目录；
2）编译app1的依赖包pkg1，将目标文件打包后放入$WORK/github.com/bigwhite/effective-go-book/chapter3-demo1/pkg/pkg1.a；
3）编译app1的main包，将目标文件打包后放入$WORK/github.com/bigwhite/effective-go-book/chapter3-demo1/cmd/app1.a；
4）链接器将app1.a、pkg1.a链接成$WORK/github.com/bigwhite/effective-go-book/chapter3-demo1/cmd/app1/_obj/exe/a.out；
5）将a.out改名为app1（这个app1在执行go build命令的目录中）。
我们细致看看链接器进行目标文件链接所执行的命令：
$GOROOT/pkg/tool/darwin_amd64/link -o $WORK/github.com/bigwhite/effective-go-book/chapter3-demo1/cmd/app1/_obj/exe/a.out -L $WORK -L /Users/tonybai/Go/pkg/darwin_amd64 -extld=clang -buildmode=exe -buildid=d116bd4b4731d2f7eac18df2368f87eee7bc7977 $WORK/github.com/bigwhite/effective-go-book/chapter3-demo1/cmd/app1.a
为了方便查看，将这行命令中的一些不必要的信息去掉，简化后的命令是这样的：
link -o a.out -L $WORK -L $GOPATH/pkg/darwin_amd64 -buildmode=exe app1.a

+ 所谓的使用第三方包源码，实际上是链接了以该最新包源码编译的、存放在临时目录下的包的.a文件而已。
+ 默认情况下对于标准库中的包，编译器直接链接的是$GOROOT/pkg/darwin_amd64下的.a文件。

>> 那么如何让编译器能够“感知”到标准库中的最新更新呢？以fmt.a为例，有两种方法。
1）删除$GOROOT/pkg/darwin_amd64下的fmt.a，然后重新执行go install fmt。

>> 2）使用go build的-a命令行选项。
go build -a可以让编译器将Go源文件（比如例子中的main.go）的所有直接和间接的依赖包（包括标准库）都重新编译一遍，并将最新的.a作为链接器的输入。


### 16.2 究竟是路径名还是包名

+ 编译器在编译过程中必然要使用的是编译单元（一个包）所依赖的包的源码。而编译器要找到依赖包的源码文件，就需要知道依赖包的源码路径。这个路径由两部分组成：基础搜索路径和包导入路径。

>> 基础搜索路径是一个全局的设置，下面是其规则描述。
1）所有包（无论是标准库包还是第三方包）的源码基础搜索路径都包括$GOROOT/src。
2）在上述基础搜索路径的基础上，不同版本的Go包含的其他基础搜索路径有不同。
•  Go 1.11版本之前，包的源码基础搜索路径还包括$GOPATH/src。
•  Go 1.11～Go 1.12版本，包的源码基础搜索路径有三种模式：
◦  经典gopath模式下（GO111MODULE=off）：$GOPATH/src。
◦  module-aware模式下（GO111MODULE=on）：$GOPATH/pkg/mod。
◦  auto模式下（GO111MODULE=auto）：在$GOPATH/src路径下，与gopath模式相同；在$GOPATH/src路径外且包含go.mod，与module-aware模式相同。
•  Go 1.13版本，包的源码基础搜索路径有两种模式：
◦  经典gopath模式下（GO111MODULE=off）：$GOPATH/src。
◦  module-aware模式下（GO111MODULE=on/auto）：$GOPATH/pkg/mod。
•  未来的Go版本将只有module-aware模式，即只在module缓存的目录下搜索包的源码。

>> 而搜索路径的第二部分就是位于每个包源码文件头部的包导入路径。基础搜索路径与包导入路径结合在一起，Go编译器便可确定一个包的所有依赖包的源码路径的集合，这个集合构成了Go编译器的源码搜索路径空间。

>> 源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段也不是包名。

>> 不过Go语言有一个惯用法，那就是包导入路径的最后一段目录名最好与包名一致

+ 关于包导入，Go语言还有一个惯用法：当包名与包导入路径中的最后一个目录名不同时，最好用下面的语法将包名显式放入包导入语句。以上面的app2为例：
// app2/main.gopackage mainimport (    mypkg2 "github.com/bigwhite/effective-go-book/chapter3-demo1/pkg/pkg2"

>> 显然，这种惯用法让代码可读性更好


### 16.3 包名冲突问题

+ 用为包导入路径下的包显式指定包名的方法

### 小结
在本条中，我们通过实验进一步理解了Go语言的包导入，Gopher应牢记以下几个结论：
•  Go编译器在编译过程中必然要使用的是编译单元（一个包）所依赖的包的源码；
•  Go源码文件头部的包导入语句中import后面的部分是一个路径，路径的最后一个分段是目录名，而不是包名；
•  Go编译器的包源码搜索路径由基本搜索路径和包导入路径组成，两者结合在一起后，编译器便可确定一个包的所有依赖包的源码路径的集合，这个集合构成了Go编译器的源码搜索路径空间；
•  同一源码文件的依赖包在同一源码搜索路径空间下的包名冲突问题可以由显式指定包名的方式解决。


## 第17条 理解Go语言表达式的求值顺序

### 17.1 包级别变量声明语句中的表达式求值顺序

+ 在一个Go包内部，包级别变量声明语句的表达式求值顺序是由初始化依赖（initialization dependencies）规则决定的。

+ 该规则总结为如下几点。
•  在Go包中，包级别变量的初始化按照变量声明的先后顺序进行。
•  如果某个变量（如变量a）的初始化表达式中直接或间接依赖其他变量（如变量b），那么变量a的初始化顺序排在变量b后面。
•  未初始化的且不含有对应初始化表达式或初始化表达式不依赖任何未初始化变量的变量，我们称之为“ready for initialization”变量。
•  包级别变量的初始化是逐步进行的，每一步就是按照变量声明顺序找到下一个“ready for initialization”变量并对其进行初始化的过程。反复重复这一步骤，直到没有“ready for initialization”变量为止。
•  位于同一包内但不同文件中的变量的声明顺序依赖编译器处理文件的顺序：先处理的文件中的变量的声明顺序先于后处理的文件中的所有变量。

```go
 // chapter3/sources/evaluation_order_1.go 
 var (    
    a = c + b    
    b = f()    
    c = f()    
    d = 3)
func f() int {    
    d++    
    return d
}
func main() {    
    fmt.Println(a, b, c, d)
}
``` 

>> $go run evaluation_order_1.go9 4 5 5


### 17.2 普通求值顺序

+ Go规定表达式操作数中的所有函数、方法以及channel操作按照从左到右的次序进行求值。


### 17.3 赋值语句的求值
```go
>> // chapter3/sources/evaluation_order_6.go 
func example() {    
    n0, n1 := 1, 2    
    n0, n1 = n0+n1, n0    
    fmt.Println(n0, n1)
}
func main() {    
    example()
}
```
运行该样例代码：
`$go run evaluation_order_6.go 3 1`


### 17.4 switch/select语句中的表达式求值

+ switch-case语句中的表达式求值，这类求值属于“惰性求值”范畴

### 小结

•  包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高。
•  表达式操作数中的函数、方法及channel操作按普通求值顺序，即从左到右的次序进行求值。
•  赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按从左到右的顺序对变量进行赋值。
•  重点关注switch-case和select-case语句中的表达式“惰性求值”规则。


## 第18条 理解Go语言代码块与作用域
```go
 func main() {    
    if a := 1; false {    } 
    else if b := 2; false {    } 
    else if c := 3; false {    } 
    else {        println(a, b, c)    }
}
```

>> 这段代码输出“1 2 3”


### 18.1 Go代码块与作用域简介

+ 代码块是代码执行流流转的基本单元，代码执行流总是从一个代码块跳到另一个代码块。

+ Go语言中有两类代码块，一类是我们在代码中直观可见的由一堆大括号包裹的显式代码块，比如函数的函数体、for循环的循环体、if语句的某个分支等：

+ 另一类则是没有大括号包裹的隐式代码块。Go规范定义了如下几种隐式代码块。
•  宇宙（Universe）代码块：所有Go源码都在该隐式代码块中，就相当于所有Go代码的最外层都存在一对大括号。
•  包代码块：每个包都有一个包代码块，其中放置着该包的所有Go源码。
•  文件代码块：每个文件都有一个文件代码块，其中包含着该文件中的所有Go源码。
•  每个if、for和switch语句均被视为位于其自己的隐式代码块中。
•  switch或select语句中的每个子句都被视为一个隐式代码块。


### 18.2 if条件控制语句的代码块

```go
 func Foo() {    
    if a := 1; true {        
        fmt.Println(a)    
    }
}
```
等价变换为：
```go
func Foo() {    
    {        
        a := 1        
        if true {            
            fmt.Println(a)        
        }    
   }
}
```
```go
 package mainfunc main() {    
    if a := 1; false {    } 
    else if b := 2; false {    } 
    else if c := 3; false {    } 
    else {        println(a, b, c)    }
}
```
这是一个if {} else if {} else {} 型控制语句的应用。依照我们的分析思路，可以对这段代码进行等价变换：
```go
func main() {    
    {        
        a := 1        
        if false {        } 
        else {            
            {                
                b := 2                
                if false {                } 
                else {                    
                    {                        
                        c := 3                        
                        if false {                        } 
                        else {                            
                            println(a, b, c)                        
                        }                    
                    }                
                }            
            }        
        }    
    }
}
```
展开后的代码让一切都一目了然了。我们看到a、b、c三个变量都位于不同层次的隐式代码块中，根据这三个变量的作用域范围，在最深层的else显式代码块中使用变量a、b、c都是合法的，a、b、c三个变量的值此时就是它们的初值，于是这个Go quiz的输出结果为1 2 3。


### 18.3 其他控制语句的代码块规则简介


## 第19条 了解Go语言控制语句惯用法及使用注意事项


+  switch的case语句执行完毕后，默认不会像C语言那样继续执行下一个case中的语句，除非显式使用fallthrough关键字，这“填补”了C语言中每个case语句都要以break收尾的“坑”；

+  增加针对channel通信的switch-case语句——select-case。


### 19.1 使用if控制语句时应遵循“快乐路径”原则

+  当出现错误时，快速返回

+  尝试将“正常逻辑”提取出来，放到“快乐路径”中；
•  如果无法做到上一点，很可能是函数内的逻辑过于复杂，可以将深度缩进到if-else语句中的代码析出到一个函数中，再对原函数实施“快乐路径”原则的重构。


### 19.2 for range的避“坑”指南

1. 小心迭代变量的重用

 for range的惯用法是使用短变量声明方式（:=）在for的initStmt中声明迭代变量（iteration variable）。但需要注意的是，这些迭代变量在for range的每次循环中都会被重用，而不是重新声明。

 如果要修正这个问题，可以为闭包函数增加参数并在创建goroutine时将参数与i、v的当时值进行绑定：
```go 
// chapter3/sources/control_structure_idiom_1.go... 
func demo2() {    
    var m = [...]int{1, 2, 3, 4, 5}    
    for i, v := range m {        
        go func(i, v int) {            
            time.Sleep(time.Second * 3)            
            fmt.Println(i, v)        
        }(i, v)    
    }    
    time.Sleep(time.Second * 10)
}
```

2. 注意参与迭代的是range表达式的副本

for range语句中，range后面接受的表达式的类型可以是数组、指向数组的指针、切片、字符串、map和channel（至少需具有读权限）。
```go
 // chapter3/sources/control_structure_idiom_2.go... 
 func arrayRangeExpression() {    
    var a = [5]int{1, 2, 3, 4, 5}    
    var r [5]int    
    fmt.Println("arrayRangeExpression result:")    
    fmt.Println("a = ", a)    
    for i, v := range a {        
        if i == 0 {            
            a[1] = 12            
            a[2] = 13        
        }        
        r[i] = v    
    }    
    fmt.Println("r = ", r)    
    fmt.Println("a = ", a)
}
```
我们期待的输出结果是：
a =  [1 2 3 4 5]r =  [1 12 13 4 5]a =  [1 12 13 4 5]
但实际运行该程序的输出结果却是：
a =  [1 2 3 4 5]r =  [1 2 3 4 5]a =  [1 12 13 4 5]
我们原以为在第一次循环过程，也就是i = 0时，我们对a的修改（a[1] = 12，a[2] = 13）会在第二次、第三次循环中被v取出，但结果却是v取出的依旧是a被修改前的值：2和3。出现这个结果的原因是：参与循环的是range表达式的副本。也就是说在上面这个例子中，真正参与循环的是a的副本，而不是真正的a。

 对range表达式的复制即对一个数组的复制，a'则是Go临时分配的连续字节序列，与a完全不是一块内存区域。

用数组指针作为range表达式
```go
 for i, v := range &a {        
    if i == 0 {            
        a[1] = 12            
        a[2] = 13        
    }        
    r[i] = v    
}
```

>> 我们看到这次r数组的值与最终a被修改后的值一致了。这个例子使用了*[5]int作为range表达式，其副本依旧是一个指向原数组a的指针，因此后续所有循环中均是&a指向的原数组亲自参与的，因此v能从&a指向的原数组中取出a修改后的值。

+ 在Go中，大多数应用数组的场景都可以用切片替代
``` go
 for i, v := range a[:] {        
    if i == 0 {            
        a[1] = 12            
        a[2] = 13        
 }
```

+ 用切片也能满足预期要求

+ 切片副本的结构体中的*T依旧指向原切片对应的底层数组，因此对切片副本的修改也都会反映到底层数组a上

+ 切片与数组还有一个不同点，就是其len在运行时可以被改变，而数组的长度可认为是一个常量，不可改变。

+ range表达式的复制行为还会带来一些性能上的消耗，尤其是当range表达式的类型为数组时，range需要复制整个数组；而当range表达式类型为数组指针或切片时，这个消耗将小得多，因为仅仅需要复制一个指针或一个切片的内部表示（一个结构体）即可。

+ 可以看到，range表达式的类型为切片或数组指针的性能相近，消耗都接近数组类型的1/2。

3. 其他range表达式类型的使用注意事项

>> （1）string

>> 不过for range对于string来说，每次循环的单位是一个rune，而不是一个byte，返回的第一个值为迭代字符码点的第一字节的位置

>> 如果作为range表达式的字符串s中存在非法UTF8字节序列，那么v将返回0xfffd这个特殊值，并且在下一轮循环中，v将仅前进一字节

>> （2）map
当map类型作为range表达式时，我们会得到一个map的内部表示的副本。在前文中我们学习过map的内部表示，map在Go运行时内部表示为一个hmap的描述符结构指针，因此该指针的副本也指向同一个hmap描述符，这样for range对map副本的操作即对源map的操作。

>> （3）channel

>> 对于channel来说，channel在Go运行时内部表示为一个channel描述符的指针（关于channel的内部表示将在后文中详细说明），因此channel的指针副本也指向原channel。

>> 当channel作为range表达式类型时，for range最终以阻塞读的方式阻塞在channel表达式上，即便是带缓冲的channel亦是如此：当channel中无数据时，for range也会阻塞在channel上，直到channel关闭
```go
// chapter3/sources/control_structure_idiom_5.go 
func recvFromUnbufferedChannel() {    
    var c = make(chan int)    
    go func() {        
        time.Sleep(time.Second * 3)        
        c <- 1        
        c <- 2        
        c <- 3        
        close(c)    
    }()    
    for v := range c {        
        fmt.Println(v)   
    }
}
```
该例子的运行结果如下：
123
如果使用一个nil channel作为range表达式，像下面这样：
```go
// chapter3/sources/control_structure_idiom_5.go 
func recvFromNilChannel() {    
    var c chan int    // 程序将一直阻塞在这里    
    for v := range c {        
        fmt.Println(v)    
    }
}
```
程序的编译不会有问题，但for range将永远阻塞在这个nil channel上，直到Go运行时发现程序陷入deadlock状态，并抛出panic：
`$go run control_structure_idiom_5.gofatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive (nil chan)]:main.recvFromNilChannel()`


### 19.3 break跳到哪里去了

```go
>> // chapter3/sources/control_structure_idiom_6.go 
func main() {    
    exit := make(chan interface{})    
    go func() {        
        for {            
            select {            
                case <-time.After(time.Second):                
                    fmt.Println("tick")            
                case <-exit:                
                    fmt.Println("exiting...")                break            
                }        
            }        
            fmt.Println("exit!")    
    }()    
    time.Sleep(3 * time.Second)    
    exit <- struct{}{}    // wait child goroutine exit   
    time.Sleep(3 * time.Second)
}
```

>> $go run control_structure_idiom_6.go ticktickexiting...tickticktick

+ Go break语法的一个“小坑”。和大家习惯的C家族语言中的break不同，Go语言规范中明确规定break语句（不接label的情况下）结束执行并跳出的是同一函数内break语句所在的最内层的for、switch或select的执行。

>> 上面例子中的break实际上跳出了select语句，但并没有跳出外层的for循环，这是程序未按我们预期执行的原因。

>> 要修正这一问题，可以利用Go语言为for提供的一项高级能力：break [label]。
```go
 // chapter3/sources/control_structure_idiom_7.go 
 func main() {    
    exit := make(chan interface{})    
    go func() {    
        loop:        
        for {            
            select {            
                case <-time.After(time.Second):                
                    fmt.Println("tick")            
                case <-exit:                
                    fmt.Println("exiting...")                
                    break loop            
            }        
         }        
        fmt.Println("exit!")    
    }()    
    time.Sleep(3 * time.Second)    
    exit <- struct{}{}    // 等待子goroutine退出    
    time.Sleep(3 * time.Second)
}

``` 

>> 带label的continue和break提升了Go语言的表达能力，可以让程序轻松拥有从深层循环中终止外层循环或跳转到外层循环继续执行的能力，使得Gopher无须为类似的逻辑设计复杂的程序结构或使用goto语句。

```go
 outerLoop:    for i := 0; i < n; i++ {        
    // ...        
    for j := 0; j < m; j++ {            
        // 当不满足某些条件时，直接终止最外层循环的执行           
        break outerLoop            // 当满足某些条件时，直接跳出内层循环，回到外层循环继续执行            
        continue outerLoop        
        }    
  }
```

### 19.4 尽量用case表达式列表替代fallthrough


>> 选择switch-case语句默认是不“fall through”的，需要fall through的时候，可以使用关键字fallthrough显式实现。

>> 不过在实际编码过程中，fallthrough的应用依然不多，而且Go的switch-case语句还提供了case表达式列表来支持多个分支表达式处理逻辑相同的情况：
```go
switch n {
    case 1: fallthroughcase 3: fallthroughcase 5: fallthroughcase 7:    odd()
    case 2: fallthroughcase 4: fallthroughcase 6: fallthroughcase 8:    even()
    default:    unknown()
}
vs.
switch n {
    case 1, 3, 5, 7:    odd()
    case 2, 4, 6, 8:    even()
    default:    unknown()
}
```
+ 通过case接表达式列表的方式要比使用fallthrough更加简洁和易读。

### 小结

•  使用if语句时遵循“快乐路径”原则；
•  小心for range的循环变量重用，明确真实参与循环的是range表达式的副本；
•  明确break和continue执行后的真实“目的地”；
•  使用fallthrough关键字前，考虑能否用更简洁、清晰的case表达式列表替代。

