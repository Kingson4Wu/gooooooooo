

# 第四部分 函数与方法

## 第20条 在init函数中检查包级变量的初始状态

### 20.1 认识init函数

Go语言中有两个特殊的函数：一个是main包中的main函数，它是所有Go可执行程序的入口函数；另一个就是包的init函数。

+ 如果一个包定义了init函数，Go运行时会负责在该包初始化时调用它的init函数。

+ 一个Go包可以拥有多个init函数，每个组成Go包的Go源文件中可以定义多个init函数。在初始化Go包时，Go运行时会按照一定的次序逐一调用该包的init函数。Go运行时不会并发调用init函数，它会等待一个init函数执行完毕并返回后再执行下一个init函数，且每个init函数在整个Go程序生命周期内仅会被执行一次。因此，init函数极其适合做一些包级数据的初始化及初始状态的检查工作。

+ 一般来说，先被传递给Go编译器的源文件中的init函数先被执行，同一个源文件中的多个init函数按声明顺序依次执行。但Go语言的惯例告诉我们：不要依赖init函数的执行次序。


### 20.2 程序初始化顺序

+ init函数为何适合做包级数据的初始化及初始状态检查工作呢？除了init函数是顺序执行并仅被执行一次之外，Go程序初始化顺序也给init函数提供了胜任该工作的前提条件。

>> Go程序由一组包组合而成，程序的初始化就是这些包的初始化。每个Go包都会有自己的依赖包，每个包还包含有常量、变量、init函数等

>> 
图20-1　Go程序初始化顺序

>> •  main包直接依赖pkg1、pkg4两个包；
•  Go运行时会根据包导入的顺序，先去初始化main包的第一个依赖包pkg1；
•  Go运行时遵循“深度优先”原则查看到pkg1依赖pkg2，于是Go运行时去初始化pkg2；
•  pkg2依赖pkg3，Go运行时去初始化pkg3；

>> 在main包中，Go运行时会按照常量→变量→init函数的顺序进行初始化，执行完这些初始化工作后才正式进入程序的入口函数main函数。

>> init函数适合做包级数据的初始化及初始状态检查工作的前提条件是，init函数的执行顺位排在其所在包的包级变量之后。

>> Go运行时按照pkg2→pkg1→pkg3→main的包顺序以及在包内常量→变量→init函数的顺序进行初始化。


### 20.3 使用init函数检查包级变量的初始状态

1. 重置包级变量值
我们先看看标准库flag包的init函数：
```go
// $GOROOT/src/flag/flag.go 
func init() {    CommandLine.Usage = commandLineUsage
}
```

>> CommandLine是flag包的一个导出包级变量，它也是默认情况下（如果你没有新创建一个FlagSet）代表命令行的变量，我们从其初始化表达式即可看出：
var CommandLine = NewFlagSet(os.Args[0], ExitOnError)
CommandLine的Usage字段在NewFlagSet函数中被初始化为FlagSet实例（也就是CommandLine）的方法值defaultUsage。如果一直保持这样，那么使用Flag默认CommandLine的外部用户就无法自定义usage输出了。于是flag包在init函数中，将ComandLine的Usage字段设置为一个包内未导出函数commandLineUsage，后者则直接使用了flag包的另一个导出包变量Usage。这样就通过init函数将CommandLine与包变量Usage关联在一起了。在用户将自定义usage赋值给Usage后，就相当于改变了CommandLine变量的Usage。

>> 下面这个例子来自标准库的context包：
```go
// $GOROOT/src/context/context.go 
// closedchan是一个可重用的处于关闭状态的channel
var closedchan = make(chan struct{})
func init() {    
    close(closedchan)
}
```
context包在cancelCtx的cancel方法中需要一个可复用的、处于关闭状态的channel，于是context包定义了一个未导出包级变量closedchan并对其进行了初始化。但初始化后的closedchan并不满足context包的要求，唯一能检查和更正其状态的地方就是context包的init函数，于是上面的代码在init函数中将closedchan关闭了。

2. 对包级变量进行初始化，保证其后续可用

>> 有些包级变量的初始化过程较为复杂，简单的初始化表达式不能满足要求，而init函数则非常适合完成此项工作。标准库regexp包的init函数就负责完成对内部特殊字节数组的初始化，这个特殊字节数组被包内的special函数使用，用于判断某个字符是否需要转义：

>> //  $GOROOT/src/regexp/regexp.go

>> 标准库net包在init函数中对rfc6724policyTable这个未导出包级变量进行反转排序：
// $GOROOT/src/net/addrselect.go

>> 标准库http包则在init函数中根据环境变量GODEBUG的值对一些包级开关变量进行赋值：
// $GOROOT/src/net/http/h2_bundle.go

3. init函数中的注册模式

>> 对于初学Go的Gopher来说，这是一段神奇的代码，因为在以空别名方式导入lib/pq包后，main函数中似乎并没有使用pq的任何变量、函数或方法。这段代码的奥秘全在pq包的init函数中：
```go
// github.com/lib/pq/conn.go...
func init() {    
    sql.Register("postgres", &Driver{})
}
```

>> 这种在init函数中注册自己的实现的模式降低了Go包对外的直接暴露，尤其是包级变量的暴露，避免了外部通过包级变量对包状态的改动。从database/sql的角度来看，这种注册模式实质是一种工厂设计模式的实现，sql.Open函数就是该模式中的工厂方法，它根据外部传入的驱动名称生产出不同类别的数据库实例句柄。
这种注册模式在标准库的其他包中亦有广泛应用，比如，使用标准库image包获取各种格式的图片的宽和高：
// chapter4/sources/get_image_size.go

>> _ "image/gif"    _ "image/jpeg"    _ "image/png"

4. init函数中检查失败的处理方法

>> init函数是一个无参数、无返回值的函数，它的主要目的是保证其所在包在被正式使用之前的初始状态是有效的。一旦init函数在检查包数据初始状态时遇到失败或错误的情况（尽管极少出现），则说明对包的“质检”亮了红灯，如果让包“出厂”，那么只会导致更为严重的影响。因此，在这种情况下，快速失败是最佳选择。我们一般建议直接调用panic或者通过log.Fatal等函数记录异常日志，然后让程序快速退出。

### 小结
要深入理解init函数，记住本条介绍的几个要点即可。
•  init函数的几个特点：运行时调用、顺序、仅执行一次。
•  Go程序的初始化顺序。
•  init函数是包出厂前的唯一“质检员”。


## 第21条 让自己习惯于函数是“一等公民”

+ Go语言中没有那些典型的面向对象语言的语法，比如类、继承、对象等。Go语言中的方法（method）本质上是函数的一个变种。因此，在Go语言中，函数是唯一一种基于特定输入、实现特定任务并可反馈任务执行结果的代码块。本质上，我们可以说Go程序就是一组函数的集合。


### 21.1 什么是“一等公民”

+ 如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。在动态类型语言中，语言运行时还支持对“一等公民”类型的检查。

>> （1）正常创建

>> （2）在函数内创建

>> （3）作为类型

>> / $GOROOT/src/net/http/server.gotype HandlerFunc func(ResponseWriter, *Request)

>> （4）存储到变量中

>> （5）作为参数传入函数

>> （6）作为返回值从函数返回

>> 函数还可以被放入数组、切片或map等结构中，可以像其他类型变量一样被赋值给interface{}，甚至我们可以建立元素为函数的channel


### 21.2 函数作为“一等公民”的特殊运用

>> Go是类型安全的语言，不允许隐式类型转换

>> 函数是“一等公民”，对整型变量进行的操作也可以用在函数上，即函数也可以被显式类型转换，并且这样的类型转换在特定的领域具有奇妙的作用。最为典型的示例就是http.HandlerFunc这个类型，我们来看一下例子：
```go
// chapter4/sources/function_as_first_class_citizen_2.go 
func greeting(w http.ResponseWriter, r *http.Request) {    
    fmt.Fprintf(w, "Welcome, Gopher!\n")
}
func main() {    
    http.ListenAndServe(":8080", http.HandlerFunc(greeting))
}
```
上述代码是最为常见的一个用Go构建的Web Server的例子。其工作机制很简单，当用户通过浏览器或类似curl这样的命令行工具访问Web Server的8080端口时，会收到“Welcome, Gopher!”这行文字版应答。很多Gopher可能并未真正深入分析过这段代码，这里用到的正是函数作为“一等公民”的特性，我们来看一下。
先来看ListenAndServe的源码：
```go
// $GOROOT/src/net/http/server.go 
func ListenAndServe(addr string, handler Handler) error {    
    server := &Server{
        Addr: addr, Handler: handler
    }    
    return server.ListenAndServe()
}
```
ListenAndServe会将来自客户端的HTTP请求交给其第二个参数handler处理，而这里handler参数的类型http.Handler接口如下：
```go
// $GOROOT/src/net/http/server.go 
type Handler interface {    
    ServeHTTP(ResponseWriter, *Request)
}
```
该接口仅有一个方法ServeHTTP，其原型为func(http.ResponseWriter, *http.Request)。这与我们自己定义的HTTP请求处理函数greeting的原型是一致的。但我们不能直接将greeting作为参数值传入，否则会报下面的错误：
func(http.ResponseWriter, *http.Request) does not implement http.Handler (missing ServeHTTP method)
即函数greeting并未实现接口Handler的方法，无法将其赋值给Handler类型的参数。
在代码中我们也并未直接将greeting传入ListenAndServe，而是将

>> http.HandlerFunc(greeting)作为参数传给了ListenAndServe。我们来看看http.HandlerFunc是什么。
```go
// $GOROOT/src/net/http/server.go 
type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP调用f(w, r
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {    
    f(w, r)
}
```
HandlerFunc其实就是一个基于函数定义的新类型，它的底层类型为func(ResponseWriter, *Request)。该类型有一个方法ServeHTTP，因而实现了Handler接口。也就是说，http.HandlerFunc(greeting)这句代码的真正含义是将函数greeting显式转换为HandlerFunc类型，而后者实现了Handler接口，这样转型后的greeting就满足了ListenAndServe函数第二个参数的要求。
另外，之所以http.HandlerFunc(greeting)这条语句可以通过编译器检查，是因为HandlerFunc的底层类型是func(ResponseWriter, *Request)，与greeting的原型是一致的。这和下面整型变量的转型原理并无二致：
type MyInt intvar x int = 5y := MyInt(x) // MyInt的底层类型为int，类比 HandlerFunc的底层类型为func(ResponseWriter,  *Request)

+ 为了充分理解这种显式类型转换的技巧，我们再来看一个简化后的例子：
```go
// chapter4/sources/function_as_first_class_citizen_3.go 
type BinaryAdder interface {    
    Add(int, int) int
}
type MyAdderFunc func(int, int) int
func (f MyAdderFunc) Add(x, y int) int {    
    return f(x, y)
}
func MyAdd(x, y int) int {    
    return x + y
}
func main() {    
    var i BinaryAdder = MyAdderFunc(MyAdd)    
    fmt.Println(i.Add(5, 6))
}
```
和Web Server那个例子类似，我们想将MyAdd函数赋值给BinaryAdder接口。直接赋值是不行的，我们需要一个底层函数类型与MyAdd一致的自定义类型的显式转换，这个自定义类型就是MyAdderFunc，该类型实现了BinaryAdder接口，这样在经过MyAdderFunc的显式类型转换后，MyAdd被赋值给了BinaryAdder的变量i。这样，通过i调用的Add方法实质上就是MyAdd函数。

2. 函数式编程

>> 虽然Go不推崇函数式编程，但有些时候局部应用函数式编程风格可以写出更优雅、更简洁、更易维护的代码。

>> （1）柯里化函数

>> 柯里化是把接受多个参数的函数变换成接受一个单一参数（原函数的第一个参数）的函数，并返回接受余下的参数和返回结果的新函数的技术
```go
func times(x, y int) int {    
    return x * y
}
func partialTimes(x int) func(int) int {    
    return func(y int) int {        
        return times(x, y)    
    }
}
func main() {    
    timesTwo := partialTimes(2)    
    timesThree := partialTimes(3)    
    timesFour := partialTimes(4)    
    fmt.Println(timesTwo(5))    
    fmt.Println(timesThree(5))    
    fmt.Println(timesFour(5))
}
```
运行这个例子：
`$ go run function_as_first_class_citizen_4.go 1 0 1 5 2 0`

>> 利用了函数的两点性质：在函数中定义，通过返回值返回；闭包。

>> 闭包是在函数内部定义的匿名函数，并且允许该匿名函数访问定义它的外部函数的作用域。

>> 本质上，闭包是将函数内部和函数外部连接起来的桥梁

>> （2）函子

+ 什么是函子呢？具体来说，函子需要满足两个条件：
•  函子本身是一个容器类型，以Go语言为例，这个容器可以是切片、map甚至channel；
•  该容器类型需要实现一个方法，该方法接受一个函数类型参数，并在容器的每个元素上应用那个函数，得到一个新函子，原函子容器内部的元素值不受影响。

>> 我们还是用一个具体的示例来直观看一下：
```go
// chapter4/sources/function_as_first_class_citizen_5.go 
type IntSliceFunctor interface {    
    Fmap(fn func(int) int) IntSliceFunctor
}
type intSliceFunctorImpl struct {    
    ints []int
}
func (isf intSliceFunctorImpl) Fmap(fn func(int) int) IntSliceFunctor {    
    newInts := make([]int, len(isf.ints))    
    for i, elt := range isf.ints {        
        retInt := fn(elt)        
        newInts[i] = retInt    
    }    
    return intSliceFunctorImpl{ints: newInts}
}

func NewIntSliceFunctor(slice []int) IntSliceFunctor {    
    return intSliceFunctorImpl{ints: slice}
}
func main() {    
    // 原切片    
    intSlice := []int{1, 2, 3, 4}    
    fmt.Printf("init a functor from int slice: %#v\n", intSlice)    
    f := NewIntSliceFunctor(intSlice)    
    fmt.Printf("original functor: %+v\n", f)    
    mapperFunc1 := func(i int) int {        
        return i + 10    
    }    
    mapped1 := f.Fmap(mapperFunc1)    
    fmt.Printf("mapped functor1: %+v\n", mapped1)    
    mapperFunc2 := func(i int) int {        
        return i * 3    
    }    
    mapped2 := mapped1.Fmap(mapperFunc2)    
    fmt.Printf("mapped functor2: %+v\n", mapped2)    
    fmt.Printf("original functor: %+v\n", f) 
    // 原函子没有改变    
    fmt.Printf("composite functor: %+v\n", f.Fmap(mapperFunc1).Fmap(mapperFunc2))
}
```
运行这段代码：
```
$ go run function_as_first_class_citizen_5.go 
init a functor from int slice: []int{1, 2, 3, 4}
original functor: {ints:[1 2 3 4]}
mapped functor1: {ints:[11 12 13 14]}
mapped functor2: {ints:[33 36 39 42]}
original functor: {ints:[1 2 3 4]}
composite functor: {ints:[33 36 39 42]}
```
这段代码的具体逻辑如下。
•  定义了一个intSliceFunctorImpl类型，用来作为函子的载体。
•  我们把函子要实现的方法命名为Fmap，intSliceFunctorImpl类型实现了该方法。该方法也是IntSliceFunctor接口的唯一方法。可以看到在这个代码中，真正的函子其

>> 实是IntSliceFunctor，这符合Go的惯用法。
•  我们定义了创建IntSliceFunctor的函数NewIntSliceFunctor。通过该函数以及一个初始切片，我们可以实例化一个函子。
•  我们在main中定义了两个转换函数，并将这两个函数应用到上述函子实例。得到的新函子的内部容器元素值是原容器的元素值经由转换函数转换后得到的。
•  最后，我们还可以对最初的函子实例连续（组合）应用转换函数，这让我们想到了数学课程中的函数组合。
•  无论如何应用转换函数，原函子中容器内的元素值不受影响。
函子非常适合用来对容器集合元素进行批量同构处理，而且代码也比每次都对容器中的元素进行循环处理要优雅、简洁许多。但要想在Go中发挥函子的最大效能，还需要Go对泛型提供支持，否则我们就需要为每一种容器类型都实现一套对应的Functor机制。比如上面的示例仅支持元素类型为int的切片，如果元素类型换为string，或者元素类型依然为int但容器类型换为map，我们还需要分别为之编写新的配套代码。

>> （3）延续传递式

+ 函数式编程有一种被称为延续传递式（Continuation-passing Style，CPS）的编程风格可以充分运用函数作为“一等公民”的特质。
```go
 // chapter4/sources/function_as_first_class_citizen_7.go 
 func Max(n int, m int) int {    
    if n > m {        
        return n    
    } else {        
        return m    
    }
}
func main() {    
    fmt.Printf("%d\n", Max(5, 6))
}
```
我们把Max函数看作上面定义中的A函数在CPS化之前的状态。根据CPS的定义将其转换为CPS风格。
1）去掉Max函数的返回值，并为其添加一个函数类型的参数f（这个f就是定义中的continuation函数）：
`func Max(n int, m int, f func(int))`
2）将返回结果传给continuation函数，即把return语句替换为对f函数的调用：
```go
func Max(n int, m int, f func(int)) {    
    if n > m {        
        f(n)    
    } else {        
        f(m)    
    }
}
```
转换后的完整代码如下：
```go
// chapter4/sources/function_as_first_class_citizen_8.go 
func Max(n int, m int, f func(y int)) {    
    if n > m {        
        f(n)    
    } else {        
        f(m)    
    }
}
func main() {    
    Max(5, 6, func(y int) { 
        fmt.Printf("%d\n", y) 
        }
    )
 }
```

>> 这种CPS风格虽然利用了函数作为“一等公民”的特质，但是其代码理解起来颇为困难，这种风格真的好吗？朋友们的担心是有道理的。这里对CPS风格的讲解其实是一个反例，

>> 目的就是告诉大家，尽管作为“一等公民”的函数给Go带来了强大的表达能力，但是如果选择了不适合的风格或者为了函数式而进行函数式编程，那么就会出现代码难于理解且代码执行效率不高的情况（CPS需要语言支持尾递归优化，但Go目前并不支持）。

### 小结

•  Go函数可以像变量值那样被赋值给变量、作为参数传递、作为返回值返回和在函数内部创建等；
•  函数可以像变量那样被显式类型转换；
•  基于函数特质，了解Go中的几种有用的函数式编程风格，如柯里化、函子等；
•  不要为了符合特定风格而滥用函数特质。


## 第22条 使用defer让函数更简洁、更健壮

### 22.1 defer的运作机制

>> •  在Go中，只有在函数和方法内部才能使用defer；
•  defer关键字后面只能接函数或方法，这些函数被称为deferred函数。defer将它们注册到其所在goroutine用于存放deferred函数的栈数据结构中，这些deferred函数将在执行defer的函数退出前被按后进先出（LIFO）的顺序调度执行（见图22-1）。

>> 
图22-1　deferred函数的存储与调度执行

>> deferred函数是一个在任何情况下都可以为函数进行收尾工作的好场合。


### 22.2 defer的常见用法

1. 拦截panic

>> defer的第二个重要用途就是拦截panic，并按需要对panic进行处理，可以尝试从panic中恢复（这也是Go语言中唯一的从panic中恢复的手段）

>> 下面的代码则通过deferred函数拦截panic并恢复了程序的运行：
```go
// chapter4/sources/deferred_func_3.go 
func bar() {    
    fmt.Println("raise a panic")    
    panic(-1)
}
```
```go 
func foo() {    
    defer func() {        
        if e := recover(); e != nil {            
            fmt.Println("recovered from a panic")        
        }    
    }()    
    bar()
}
func main() {    
    foo()    
    fmt.Println("main exit normally")
}
```

+ deferred函数虽然可以拦截绝大部分的panic，但无法拦截并恢复一些运行时之外的致命问题。比如下面代码中通过C代码“制造”的崩溃，deferred函数便无能为力

```go
// chapter4/sources/deferred_func_4.go 
package main
//#include <stdio.h>//void crash() {
//    int *q = NULL;
//    (*q) = 15000;
//    printf("%d\n", *q);
//}
import "C"
import (    "fmt")
func bar() {    
    C.crash()
}
func foo() {    
    defer func() {        
        if e := recover(); e != nil {            
            fmt.Println("recovered from a panic:", e)        
        }   
    }()    
    bar()
}
func main() {    
    foo()    
    fmt.Println("main exit normally")
}
```
执行这段代码我们就会看到，虽然有deferred函数拦截，但程序仍然崩溃了：
`$ go run deferred_func_4.goSIGILL: illegal instructionPC=0x409a7f4 m=0 sigcode=1goroutine 0 [idle]:runtime: unknown pc 0x409a7f4​​`

2. 修改函数的具名返回值
```go
// chapter4/sources/deferred_func_5.go 
func foo(a, b int) (x, y int) {    
    defer func() {        
        x = x * 5        
        y = y * 10    
    }()    
    x = a + 5    
    y = b + 6    
    return
}
func main() {    
    x, y := foo(1, 2)    
    fmt.Println("x=", x, "y=", y)
}
```
运行这个程序：
`$ go run deferred_func_5.go x= 30 y= 80`

3. 输出调试信息

>> deferred函数被注册及调度执行的时间点使得它十分适合用来输出一些调试信息。
```go
if c.dnsDebugLevel > 1 {        
    defer func() {            
        print("go package net: hostLookupOrder(", hostname, ") = ", ret.String(), "\n")        
    }()    
}
```
4. 还原变量旧值

>> defer还有一种比较小众的用法，这个用法依旧来自Go标准库源码。在syscall包下有这样一段代码
```go
 // $GOROOT/src/syscall/fs_nacl.go
func init() {    
    oldFsinit := fsinit    
    defer func() { 
        fsinit = oldFsinit 
    }()
}    
```


### 22.3 关于defer的几个关键问题

1. 明确哪些函数可以作为deferred函数

+ 对于自定义的函数或方法，defer可以给予无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在deferred函数被调度执行的时候被自动丢弃。

+ Go语言中除了有自定义的函数或方法，还有内置函数。下面是Go语言内置函数的完整列表：
append cap close complex copy delete imag lenmake new panic print println real recover

+ Go编译器给出了一组错误提示！从中我们看到，append、cap、len、make、new等内置函数是不可以直接作为deferred函数的，而close、copy、delete、print、recover等可以。

+ 对于那些不能直接作为deferred函数的内置函数，我们可以使用一个包裹它的匿名函数来间接满足要求。以append为例：
`defer func() {    _ = append(sl, 11)}()`
但这么做有什么实际意义需要开发者自己把握。

2. 把握好defer关键字后表达式的求值时机

+ defer关键字后面的表达式是在将deferred函数注册到deferred函数栈的时候进行求值的。
```go
 // chapter4/sources/deferred_func_7.go 
 func foo1() {    
    for i := 0; i <= 3; i++ {        
        defer fmt.Println(i)    
    }
}
// 3 2 0 1
func foo2() {    
    for i := 0; i <= 3; i++ {        
        defer func(n int) {               
            fmt.Println(n)        
        }(i)    
    }
}
//3 2 1 0
func foo3() {    
    for i := 0; i <= 3; i++ {        
        defer func() {            
            fmt.Println(i)        
        }()    
    }
}
//4 4 4 4
func main() {    
    fmt.Println("foo1 result:")    
    foo1()    
    fmt.Println("\nfoo2 result:")    
    foo2()    
    fmt.Println("\nfoo3 result:")    
    foo3()
}
```
我们逐一分析foo1、foo2和foo3中defer关键字后的表达式的求值时机：
在foo1中，defer后面直接接的是fmt.Println函数，每当defer将fmt.Println注册到deferred函数栈的时候，都会对Println后面的参数进行求值。根据上述代码逻辑，依次压入deferred函数栈的函数是：
fmt.Println(0)fmt.Println(1)fmt.Println(2)fmt.Println(3)
因此，在foo1返回后，deferred函数被调度执行时，上述压入栈的deferred函数将以LIFO次序出栈执行，因此输出的结果为：
3210
在foo2中，defer后面接的是一个带有一个参数的匿名函数。每当defer将匿名函数注册到deferred函数栈的时候，都会对该匿名函数的参数进行求值。根据上述代码逻辑，依次压入deferred函数栈的函数是：
func(0)func(1)func(2)func(3)

>> 因此，在foo2返回后，deferred函数被调度执行时，上述压入栈的deferred函数将以LIFO次序出栈执行，因此输出的结果为：
3210
在foo3中，defer后面接的是一个不带参数的匿名函数。根据上述代码逻辑，依次压入deferred函数栈的函数是：
func()func()func()func()
因此，在foo3返回后，deferred函数被调度执行时，上述压入栈的deferred函数将以LIFO次序出栈执行。匿名函数以闭包的方式访问外围函数的变量i，并通过Println输出i的值，此时i的值为4，因此foo3的输出结果为：
4444

3. 知晓defer带来的性能损耗

+ defer让进行资源释放（如文件描述符、锁）的过程变得优雅很多，也不易出错。但在性能敏感的程序中，defer带来的性能负担也是Gopher必须知晓和权衡的。

+ Go 1.14版本中，defer性能提升巨大，已经和不用defer的性能相差很小了：

### 小结

+ defer让资源释放变得优雅且不易出错，简化了函数实现逻辑，提高了代码可读性，让函数实现变得更加健壮。

### 本条要点：

•  理解defer的运作机制，即deferred函数注册与调度执行；
•  了解defer的常见用法；
•  了解关于defer使用的几个关键问题，避免入“坑”。


## 第23条 理解方法的本质以选择正确的receiver类型


+ Go语言虽然不支持经典的面向对象语法元素，比如类、对象、继承等，但Go语言也有方法。和函数相比，Go语言中的方法在声明形式上仅仅多了一个参数，Go称之为receiver参数。receiver参数是方法与类型之间的纽带。
Go方法的一般声明形式如下：
```go
func (receiver T/*T) MethodName(参数列表) (返回值列表) {    // 方法体
}
```

+ 上面方法声明中的T称为receiver的基类型。通过receiver，上述方法被绑定到类型T上。换句话说，上述方法是类型T的一个方法，我们可以通过类型T或*T的实例调用该方法

+ 方法定义要与类型定义放在同一个包内。由此我们可以推出：不能为原生类型（如int、float64、map等）添加方法，只能为自定义类型定义方法

+ 同理，可以推出：不能横跨Go包为其他包内的自定义类型定义方法。

+ receiver参数的基类型本身不能是指针类型或接口类型


### 23.1 方法的本质

```go
type T struct {    
    a int
}
func (t T) Get() int {    
    return t.a
}
func (t *T) Set(a int) int {    
    t.a = a    
    return t.a
}
```
>> 转换为下面的普通函数：
```go
func Get(t T) int {    
    return t.a
}
func Set(t *T, a int) int {    
    t.a = a    
    return t.a
}
```
+ 这种转换后的函数就是方法的原型。只不过在Go语言中，这种等价转换是由Go编译器在编译和生成代码时自动完成的。Go语言规范中提供了一个新概念，可以让我们更充分地理解上面的等价转换。
Go方法的一般使用方式如下：
```go
var t T
t.Get()
t.Set(1)
```
我们可以用如下方式等价替换上面的方法调用：
```go
var t T
T.Get(t)
(*T).Set(&t, 1)
```
这种直接以类型名T调用方法的表达方式被称为方法表达式（Method Expression）。类型T只能调用T的方法集合（Method Set）中的方法，同理，`*T`只能调用`*T`的方法集合中的方法（关于方法集合

+ 这种通过方法表达式对方法进行调用的方式与我们之前所做的方法到函数的等价转换如出一辙。这就是

+ Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。

+ Go方法自身的类型就是一个普通函数，我们甚至可以将其作为右值赋值给函数类型的变量：
```go
var t T
f1 := (*T).Set 
// f1的类型，也是T类型Set方法的原型：func (t *T, int)int
f2 := T.Get    
// f2的类型，也是T类型Get方法的原型：func (t T)int
f1(&t, 3)
fmt.Println(f2(t))
```

### 23.2 选择正确的receiver类型

+ 方法和函数的等价变换公式：
func (t T) M1() <=> M1(t T)
func (t *T) M2() <=> M2(t *T)

>> （1）当receiver参数的类型为T时，选择值类型的receiver
选择以T作为receiver参数类型时，T的M1方法等价为M1(t T)。Go函数的参数采用的是值复制传递，也就是说M1函数体中的t是T类型实例的一个副本，这样在M1函数的实现中对参数t做任何修改都只会影响副本，而不会影响到原T类型实例。
（2）当receiver参数的类型为*T时，选择指针类型的receiver

>> 选择以*T作为receiver参数类型时，T的M2方法等价为M2(t *T)。我们传递给M2函数的t是T类型实例的地址，这样M2函数体中对参数t做的任何修改都会反映到原T类型实例上。

```go
// chapter4/sources/method_nature_1.go 
type T struct {    
    a int
}
func (t T) M1() {    
    t.a = 10
}
func (t *T) M2() {    
    t.a = 11
}
func main() {    
    var t T 
    // t.a = 0    
    println(t.a)    
    t.M1()    
    println(t.a)    
    t.M2()    
    println(t.a)
}
```
运行该程序：
`$ go run method_nature_1.go  0 0 11`

>> 很多Go初学者还有这样的疑惑：是不是T类型实例只能调用receiver为T类型的方法，不能调用receiver为*T类型的方法呢？答案是否定的。无论是T类型实例还是*T类型实例，都既可以调用receiver为T类型的方法，也可以调用receiver为*T类型的方法。

```go
 // chapter4/sources/method_nature_2.go 
package main
type T struct {    
    a int
}
func (t T) M1() {}
func (t *T) M2() {    
    t.a = 11
}
func main() {    
    var t T    
    t.M1() // ok    
    t.M2() // <=> (&t).M2()    
    var pt = &T{}    
    pt.M1() // <=> (*pt).M1()    
    pt.M2() // ok
}
``` 

+ 实际上这都是Go语法糖，Go编译器在编译和生成代码时为我们自动做了转换。

•  如果要对类型实例进行修改，那么为receiver选择*T类型。
•  如果没有对类型实例修改的需求，那么为receiver选择T类型或*T类型均可；但考虑到Go方法调用时，receiver是以值复制的形式传入方法中的，如果类型的size较大，以值形式传入会导致较大损耗，这时选择*T作为receiver类型会更好些。

+ 关于receiver类型的选择其实还有一个重要因素，那就是类型是否要实现某个接口，这个考量因素将在下一条中详细说明。


### 23.3 基于对Go方法本质的理解巧解难题

>> 下面的这个例子来自笔者博客上的一条读者咨询。该读者咨询的问题代码如下：
// chapter4/sources/method_nature_3.go
```go
type field struct {
	name string
}

func (p *field) print() {
	fmt.Println(p.name)
}
func main() {
	data1 := []*field{{"one"}, {"two"}, {"three"}}
	for _, v := range data1 {
		go v.print()
	}
	data2 := []field{{"four"}, {"five"}, {"six"}}
	for _, v := range data2 {
		go v.print()
	}
	time.Sleep(3 * time.Second)
}
```

该示例在我的多核MacBook Pro上运行结果如下（由于goroutine调度顺序不同，结果可能有差异）：
`$ go run method_nature_3.go one two three six six six`
这位读者的问题是：为什么对data2迭代输出的结果是3个“six”，而不是“four”“five” “six”？

好了，我们来分析一下。首先，根据Go方法的本质——一个以方法所绑定类型实例为第一个参数的普通函数，对这个程序做个等价变换（这里我们利用方法表达式），变换后的源码如下：
```go
// chapter4/sources/method_nature_4.go

type field struct {
	name string
}

func (p *field) print() {
	fmt.Println(p.name)
}
func main() {
	data1 := []*field{{"one"}, {"two"}, {"three"}}
	for _, v := range data1 {
		go (*field).print(v)
	}
	data2 := []field{{"four"}, {"five"}, {"six"}}
	for _, v := range data2 {
		go (*field).print(&v)
	}
	time.Sleep(3 * time.Second)
}
```

>> 这里我们把对类型field的方法print的调用替换为方法表达式的形式，替换前后的程序输出结果是一致的。变换后，是不是感觉豁然开朗了？我们可以很清楚地看到使用go关键字启动一个新goroutine时是如何绑定参数的：
•  迭代data1时，由于data1中的元素类型是field指针（*field），因此赋值后v就是元素地址，每次调用print时传入的参数（v）实际上也是各个field元素的地址；
•  迭代data2时，由于data2中的元素类型是field（非指针），需要将其取地址后再传入。这样每次传入的&v实际上是变量v的地址，而不是切片data2中各元素的地址。

在第19条中，我们了解过for range使用时应注意的几个关键问题，其中就包括循环变量复用。这里的v在整个for range过程中只有一个，因此data2迭代完成之后，v是元素“six”的副本。
这样，一旦启动的各个子goroutine在main goroutine执行到Sleep时才被调度执行，那么最后的三个goroutine在打印&v时，打印的也就都是v中存放的值“six”了。而前三个子goroutine各自传入的是元素“one”“two”“three”的地址，打印的就是“one” “two”“three”了。
那么如何修改原程序才能让其按期望输出（“one”“two”“three”“four”“five”“six”）呢？其实只需将field类型print方法的receiver类型由*field改为field即可。

```go
// chapter4/sources/method_nature_5.go... 
type field struct {    
    name string
}
func (p field) print() {    
    fmt.Println(p.name)
}
```
修改后程序的输出结果为（因goroutine调度顺序不同，输出顺序可能会有不同）：
one two three four five six

### 小结

+ Go语言未提供对经典面向对象机制的语法支持，但实现了类型的方法，方法与类型间通过方法名左侧的receiver建立关联。为类型的方法选择合适的receiver类型是Gopher为类型定义方法的重要环节。

•  Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。
•  Go语法糖使得我们在通过类型实例调用类型方法时无须考虑实例类型与receiver参数类型是否一致，编译器会为我们做自动转换。
•  在选择receiver参数类型时要看是否要对类型实例进行修改。如有修改需求，则选择*T；如无修改需求，T类型receiver传值的性能损耗也是考量因素之一。


## 第24条 方法集合决定接口实现

### 24.1　方法集合

+ Go语言的一个创新是，自定义类型与接口之间的实现关系是松耦合的：如果某个自定义类型T的方法集合是某个接口类型的方法集合的超集，那么就说类型T实现了该接口，并且类型T的变量可以被赋值给该接口类型的变量，即我们说的方法集合决定接口实现。

+ 这里我们实现了一个工具函数，它可以方便地输出一个自定义类型或接口类型的方法集合。
```go
// chapter4/sources/method_set_utils.go

func DumpMethodSet(i interface{}) {
	v := reflect.TypeOf(i)
	elemTyp := v.Elem()
	n := elemTyp.NumMethod()
	if n == 0 {
		fmt.Printf("%s's method set is empty!\n", elemTyp)
		return
	}
	fmt.Printf("%s's method set:\n", elemTyp)
	for j := 0; j < n; j++ {
		fmt.Println("-", elemTyp.Method(j).Name)
	}
	fmt.Printf("\n")
}
```
```go
>> // chapter4/sources/method_set_2.go
type Interface interface {   
	M1()   
	M2()
}
type T struct{}
func (t T) M1()  {}
func (t *T) M2() {}
func main() {   
		 var t T    
		 var pt *T    
		 DumpMethodSet(&t)    
		 DumpMethodSet(&pt)    
		 DumpMethodSet((*Interface)
		 (nil))
}
```

运行上述代码：
```
$ go run method_set_2.go 
method_set_utils.go
main.T's method set:- M1
*main.T's method set:- M1- M2
main.Interface's method set:- M1- M2
```
在上述输出结果中，T、*T和Interface各自的方法集合一目了然。我们看到T类型的方法集合中只包含M1，无法成为Interface类型的方法集合的超集，因此这就是本条开头例子中编译器认为变量t不能赋值给Interface类型变量的原因。

+ 这符合Go语言规范：对于非接口类型的自定义类型T，其方法集合由所有receiver为T类型的方法组成；而类型`*T`的方法集合则包含所有receiver为T和`*T`类型的方法。

+ 到这里，我们完全明确了为receiver选择类型时需要考虑的第三点因素：是否支持将T类型实例赋值给某个接口类型变量。如果需要支持，我们就要实现receiver为T类型的接口类型方法集合中的所有方法。


### 24.2 类型嵌入与方法集合

+ Go的设计哲学之一是偏好组合，Go支持用组合的思想来实现一些面向对象领域经典的机制，比如继承。而具体的方式就是利用类型嵌入（type embedding）。

+ 与接口类型和结构体类型相关的类型嵌入有三种组合：在接口类型中嵌入接口类型、在结构体类型中嵌入接口类型及在结构体类型中嵌入结构体类型。

1. 在接口类型中嵌入接口类型

>> io包中的ReadWriter、ReadWriteCloser等接口类型就是通过嵌入Reader、Writer或Closer三个基本接口类型形成的

2. 在结构体类型中嵌入接口类型

>> 当结构体类型中嵌入多个接口类型且这些接口类型的方法集合存在交集时

>> 嵌入了其他接口类型的结构体类型的实例在调用方法时，Go选择方法的次序。

>> 1）优先选择结构体自身实现的方法。

>> 2）如果结构体自身并未实现，那么将查找结构体中的嵌入接口类型的方法集合中是否有该方法，如果有，则提升（promoted）为结构体的方法。

>> 3）如果结构体嵌入了多个接口类型且这些接口类型的方法集合存在交集，那么Go编译器将报错，除非结构体自己实现了交集中的所有方法。

>> 不过，我们还是要尽量避免在结构体类型中嵌入方法集合有交集的多个接口类型。

>> 结构体类型在嵌入某接口类型的同时，也实现了这个接口。这一特性在单元测试中尤为有用，尤其是在应对下面这样的场景时：
```go
// chapter4/sources/method_set_9.go 
package employee
type Result struct {    
    Count int
}
func (r Result) Int() int { 
    return r.Count 
}
type Rows []struct{}
type Stmt interface {    
    Close() error    
    NumInput() int    
    Exec(stmt string, args ...string) (Result, error)    
    Query(args []string) (Rows, error)
}
// 返回男性员工总数
func MaleCount(s Stmt) (int, error) {    
    result, err := s.Exec("select count(*) from employee_tab where gender=?", "1")    
    if err != nil {        
        return 0, err    
    }    
    return result.Int(), nil
}
```
在这个例子中有一个employee包，该包中的MaleCount方法通过传入的Stmt接口的实现从数据库中获取男性员工的数量。

>> 现在我们要对MaleCount方法编写单元测试代码。对于这种依赖外部数据库操作的方法，惯例是使用伪对象（fake object）来冒充真实的Stmt接口实现。不过现在有一个问题是，Stmt接口类型的方法集合中有4个方法，如果针对每个测试用例所用的伪对象都实现这4个方法，那么这个工作量有点大，而我们需要的仅仅是Exec这一个方法。如何快速建立伪对象呢？在结构体类型中嵌入接口类型便可以帮助我们：
```go
// chapter4/sources/method_set_9_test.go 
package employee
import "testing"
type fakeStmtForMaleCount struct {    
    Stmt
}
func (fakeStmtForMaleCount) Exec(stmt string, args ...string) (Result, error) {    
    return Result{Count: 5}, nil
}
func TestEmployeeMaleCount(t *testing.T) {    
    f := fakeStmtForMaleCount{}    
    c, _ := MaleCount(f)    
    if c != 5 {        
        t.Errorf("want: %d, actual: %d", 5, c)        
        return    
    }
}
```
我们为TestEmployeeMaleCount测试用例建立了一个fakeStmtForMaleCount的伪对象，在该结构体类型中嵌入Stmt接口类型，这样fakeStmtForMaleCount就实现了Stmt接口，我们达到了快速建立伪对象的目的。之后，我们仅需为fakeStmtForMaleCount实现MaleCount所需的Exec方法即可。

3. 在结构体类型中嵌入结构体类型

+ 在结构体类型中嵌入结构体类型为Gopher提供了一种实现“继承”的手段，外部的结构体类型T可以“继承”嵌入的结构体类型的所有方法的实现，并且无论是T类型的变量实例还是*T类型变量实例，都可以调用所有“继承”的方法。
```go
// chapter4/sources/method_set_10.go 
type T1 struct{}
func (T1) T1M1()   { 
    println("T1's M1") 
}
func (T1) T1M2()   { 
    println("T1's M2") 
}
func (*T1) PT1M3() { 
    println("PT1's M3") 
}
type T2 struct{}
func (T2) T2M1()   { 
    println("T2's M1") 
}
func (T2) T2M2()   { 
    println("T2's M2") 
}
func (*T2) PT2M3() { 
    println("PT2's M3") 
}
type T struct {    
    T1    
    *T2
}
func main() {    
    t := T{        
        T1: T1{},        
        T2: &T2{},    
    }    
    println("call method through t:")    
    t.T1M1()    
    t.T1M2()    
    t.PT1M3()    
    t.T2M1()    
    t.T2M2()    
    t.PT2M3()
}    
```

+ 虽然无论通过T类型变量实例还是*T类型变量实例都可以调用所有“继承”的方法（这也是Go语法糖），但是T和*T类型的方法集合是有差别的：
•  T类型的方法集合 = T1的方法集合 + *T2的方法集合；
•  *T类型的方法集合 = *T1的方法集合 + *T2的方法集合。


### 24.3 defined类型的方法集合

+ Go语言支持基于已有的类型创建新类型，比如：
```go
type MyInterface I
type Mystruct T
```
已有的类型（比如上面的I、T）被称为underlying类型，而新类型被称为defined类型。新定义的defined类型与原underlying类型是完全不同的类型

+ Go对于分别基于接口类型和自定义非接口类型创建的defined类型给出了不一致的结果：
•  基于接口类型创建的defined类型与原接口类型的方法集合是一致的，如上面的Interface和Interface1；
•  而基于自定义非接口类型创建的defined类型则并没有“继承”原类型的方法集合，新的defined类型的方法集合是空的。

+ 方法集合决定接口实现。基于自定义非接口类型的defined类型的方法集合为空，这决定了即便原类型实现了某些接口，基于其创建的defined类型也没有“继承”这一隐式关联。新defined类型要想实现那些接口，仍需重新实现接口的所有方法。


### 24.4 类型别名的方法集合

+ 类型别名与原类型几乎是等价的。Go预定义标识符rune、byte就是通过类型别名语法定义的：

```go
// $GOROOT/src/builtin/builtin.go 
type byte = uint8 
type rune = int32
```
+ 类型别名与原类型拥有完全相同的方法集合，无论原类型是接口类型还是非接口类型。

### 小结

+ 通过这一条的学习，我们了解到在考虑方法的receiver类型时，除了考虑是否需要对类型实例进行修改、类型实例值复制导致的性能损耗之外，另一个重要因素是类型是否要实现某个接口类型。而一个类型是否实现某个类型取决于其方法集合。

### 本条要点：
•  方法集合是类型与接口间隐式关系的纽带，只有当类型的方法集合是某接口类型的超集时，我们才说该类型实现了某接口；
•  类型T的方法集合是以T为receiver类型的所有方法的集合，类型*T的方法集合是以*T为receiver类型的所有方法的集合与类型T的方法集合的并集；
•  了解类型嵌入对接口类型和自定义结构体类型的方法集合的影响；
•  基于接口类型创建的defined类型与原类型具有相同的方法集合，而基于自定义非接口类型创建的defined类型的方法集合为空；
•  类型别名与原类型拥有完全相同的方法集合。


## 第25条 了解变长参数函数的妙用

+ 最常用的fmt包、log包中的几个导出函数都是变长参数函数：
```go
// $GOROOT/src/fmt/print.go 
func Println(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)...
// $GOROOT/src/log/log.go 
func Printf(format string, v ...interface{})
func Println(v ...interface{})...
```

+ 并且Go内置的常用于切片类型操作的append函数也是变长参数函数：
```go
// $GOROOT/src/builtin/builtin.go 
func append(slice []Type, elems ...Type) []Type
```

+ 有些时候使用变长参数函数可以简化代码逻辑，使代码更易阅读和理解。


### 25.1 什么是变长参数函数

+ 一个变长参数函数只能有一个“...T”类型形式参数，并且该形式参数应该为函数参数列表中的最后一个形式参数

+ 虽然string类型变量可以直接赋值给interface{}类型变量，但是`[]string`类型变量并不能直接赋值给[]interface{}类型变量。

+ 要消除编译错误，我们仅需将变量s的类型换为[]interface{}，见下面的代码：
```go
// chapter4/sources/variadic_function_2.go... 
func main() {    
    s := []interface{}{"Tony", "John", "Jim"}
}    
```

>> 不过有个例外，那就是Go内置的append函数，它支持通过下面的方式将字符串附加到一个字节切片后面：
```go
// chapter4/sources/variadic_function_3.go 
func main() {    
    b := []byte{}    
    b = append(b, "hello"...)   
    fmt.Println(string(b))
}
```
`$ go run variadic_function_3.go hellostring`

类型本是不满足类型要求的（append本需要`[]byte`...），这算是Go编译器的一个优化，编译器自动将string隐式转换为了[]byte。如果是我们自定义的函数，那么是无论如何都不能支持这样的用法的


### 25.2 模拟函数重载

+ Go语言不允许在同一个作用域下定义名字相同但函数原型不同的函数，如果定义这样的函数

+ 但Go语言并不支持函数重载，Go语言官方常见问答[1]中给出的不支持的理由如下：
其他语言的经验告诉我们，使用具有相同名称但函数签名不同的多种方法有时会很有用，但在实践中也可能会造成混淆和脆弱性。在Go的类型系统中，仅按名称进行匹配并要求类型一致是一个主要的简化决策。

>> 我们在Go语言中怎么模拟重载函数呢？变长参数函数显然是最好的选择。

>> 如果要重载的函数的参数都是相同类型的，仅参数的个数是变化的，那么变长参数函数可以轻松对应；如果参数类型不同且个数可变，那么我们还要结合interface{}类型的特性。

```go
// chapter4/sources/variadic_function_5.go 
func concat(sep string, args ...interface{}) string {    
    var result string    
    for i, v := range args {        
        if i != 0 {            
            result += sep        
        }        
        switch v.(type) {        
            case int, int8, int16, int32, int64,            uint, uint8, uint16, uint32, uint64:            
            result += fmt.Sprintf("%d", v)        
            case string:            
            result += fmt.Sprintf("%s", v)        
            case []int:            
            ints := v.([]int)            
            for i, v := range ints {                
                if i != 0 {                    
                    result += sep                
                }                
                result += fmt.Sprintf("%d", v)            
            }        
            case []string:            
            strs := v.([]string)            
            result += strings.Join(strs, sep)        
            default:            
            fmt.Printf("the argument type [%T] is not supported", v)            
            return ""        
        }    
    }    
    return result
}
func main() {    
    println(concat("-", 1, 2))    
    println(concat("-", "hello", "gopher"))    
    println(concat("-", "hello", 1, uint32(2),        []int{11, 12, 13}, 17,        []string{"robot", "ai", "ml"},        "hacker", 33))
}
```
在上面这个例子中，我们定义了一个concat函数，该函数支持接受任意数量的整型、字符串、整型切片、字符串切片参数，并将输入的参数通过分隔符（sep）连接在一起。看main函数中对concat的调用，是不是有一种调用重载函数的感觉？我们运行一下该例子：
```
$ go run variadic_function_5.go1-2hello-gopherhello-1-2-11-12-13-17-robot-ai-ml-hacker-33
```


### 25.3 模拟实现函数的可选参数与默认参数

+ 如果参数在传入时有隐式要求的固定顺序（这点由调用者保证），我们还可以利用变长参数函数模拟实现函数的可选参数和默认参数。

```go
 // chapter4/sources/variadic_function_6.go 
 type record struct {    
    name    string    
    gender  string    
    age     uint16    
    city    string    
    country string
}
func enroll(args ...interface{} /* name, gender, age, city = "Beijing", country = "China" */) (*record, error) {    
    if len(args) > 5 || len(args) < 3 {        
        return nil, fmt.Errorf("the number of arguments passed is wrong")    
    }    
    r := &record{        
        city:    "Beijing", // 默认值：Beijing        
        country: "China",   // 默认值：China    
    }    
    for i, v := range args {        
        switch i {        
            case 0: // name            
            name, ok := v.(string)            
            if !ok {                
                return nil, fmt.Errorf("name is not passed as string")            
            }            
            r.name = name        
            case 1: // gender            
            gender, ok := v.(string)            
            if !ok {                
                return nil, fmt.Errorf("gender is not passed as string")            
            }            
            r.gender = gender        
            case 2: // age            
            age, ok := v.(int)            
            if !ok {                
                return nil, fmt.Errorf("age is not passed as int")            
            }            
            r.age = uint16(age)        
            case 3: // city            
            city, ok := v.(string)            
            if !ok {                
                return nil, fmt.Errorf("city is not passed as string")            
            }            
            r.city = city        
            case 4: // country            
            country, ok := v.(string)            
            if !ok {                
                return nil, fmt.Errorf("country is not passed as string")            
            }            
            r.country = country       
            default:            
            return nil, fmt.Errorf("unknown argument passed")        
        }    
    }    
    return r, nil
}
func main() {    
    r, _ := enroll("小明", "male", 23)    
    fmt.Printf("%+v\n", *r)    
    r, _ = enroll("小红", "female", 13, "Hangzhou")
    fmt.Printf("%+v\n", *r)    
    r, _ = enroll("Leo Messi", "male", 33, "Barcelona", "Spain")    
    fmt.Printf("%+v\n", *r)    
    r, err := enroll("小吴", 21, "Suzhou")    
    if err != nil {        
        fmt.Println(err)        
        return    
    }
}
```

### 25.4 实现功能选项模式

>> 版本1：通过参数暴露配置选项
一个最简单、直接的实现方法就是通过函数参数暴露配置选项，让调用者自行设置自己所需要的精装房风格和使用的材料

>> 版本2：使用结构体封装配置选项

>> 软件设计中的一个比较重要的原则是封装变化。既然我们无法控制将来要加入的配置选项的个数和内容，但还要尽可能保持提供单一接口，那我们就把配置选项这个变量抽取出来并封装到一个结构体中，这也是目前比较常见的做法。

```go
// chapter4/sources/variadic_function_8.go 
type FinishedHouse struct {    
    style                  int    // 0: Chinese; 1: American; 2: European    
    centralAirConditioning bool   // true或false    
    floorMaterial          string  // "ground-tile"或"wood"    
    wallMaterial           string // "latex" "paper"或"diatom-mud"
}
type Options struct {    
    Style                  int    // 0: Chinese; 1: American; 2: European    
    CentralAirConditioning bool   // true或false    
    FloorMaterial          string // "ground-tile"或"wood"    
    WallMaterial           string // "latex" "paper"或"diatom-mud"
}
func NewFinishedHouse(options *Options) *FinishedHouse {    
    // 如果options为nil，则使用默认的风格和材料    
    var style int = 0    
    var centralAirConditioning = true    
    var floorMaterial = "wood"    
    var wallMaterial = "paper"    
    if options != nil {        
        style = options.Style        
        centralAirConditioning = options.CentralAirConditioning        
        floorMaterial = options.FloorMaterial        
        wallMaterial = options.WallMaterial    
    }    
    h := &FinishedHouse{        
        style:                  style,        
        centralAirConditioning: centralAirConditioning,        
        floorMaterial:          floorMaterial,        
        wallMaterial:           wallMaterial,    
    }    
    return h
}
func main() {    
    fmt.Printf("%+v\n", NewFinishedHouse(nil)) // 使用默认值    
    fmt.Printf("%+v\n", NewFinishedHouse(&Options{        
        Style:                  1,        
        CentralAirConditioning: false,        
        FloorMaterial:          "ground-tile",        
        WallMaterial:           "paper",    
    }))
}

```

+ 版本3：使用功能选项模式

+ Go语言之父Rob Pike早在2014年就在其博文“自引用函数与选项设计”[2]中论述了一种被后人称为“功能选项”（functional option）的模式，这种模式应该是目前进行功能选项设计的最佳实践。

```go
// chapter4/sources/variadic_function_9.go

type FinishedHouse struct {    
	style                  int    // 0: Chinese; 1: American; 2: European   
	 centralAirConditioning bool   // true或false    
	 floorMaterial          string  // "ground-tile"或"wood"    
	 wallMaterial           string // "latex"或"paper"或"diatom-mud"
	 }
type Option func(*FinishedHouse)
func NewFinishedHouse(options ...Option) *FinishedHouse {   
	 h := &FinishedHouse{        // default options        
		style:                  0,        
		centralAirConditioning: true,       
		 floorMaterial:          "wood",        
		 wallMaterial:           "paper",    
		 }    
		 for _, option := range options {        
			option(h)    
			}    
	return h
}
func WithStyle(style int) Option {    
	return func(h *FinishedHouse) {        
		h.style = style    
		}
	}
func WithFloorMaterial(material string) Option {    
	return func(h *FinishedHouse) {        
		h.floorMaterial = material    
	}
}
func WithWallMaterial(material string) Option {    
	return func(h *FinishedHouse) {        
		h.wallMaterial = material    
		}
	}
func WithCentralAirConditioning(centralAirConditioning bool) Option {    
	return func(h *FinishedHouse) {        
		h.centralAirConditioning = centralAirConditioning    
	}
}
func main() {    
	fmt.Printf("%+v\n", NewFinishedHouse()) // 使用默认选项    
	fmt.Printf("%+v\n", NewFinishedHouse(WithStyle(1),        
	WithFloorMaterial("ground-tile"),        
	WithCentralAirConditioning(false)))
}
```
+ 我们看到在该方案中，FinishedHouse的配置选项不是通过存储在结构体中的配置参数传入的，而是通过对FinishedHouse值本身进行操作的函数调用（利用函数的“一等公民”特质）实现的，并且通过使用变长参数函数，我们可以随意扩展传入的配置选项的个数。

+ 在设计和实现类似NewFinishedHouse这样带有配置选项的函数或方法时，功能选项模式让我们可以收获如下好处：
•  更漂亮的、不随时间变化的公共API；
•  参数可读性更好；
•  配置选项高度可扩展；
•  提供使用默认选项的最简单方式；
•  使用更安全（不会像版本2那样在创建函数被调用后，调用者仍然可以修改options）。

### 小结
在这一条中我们了解了我们日常使用最多却经常忽视的一类函数——变长参数函数，学习了它的原理以及如何通过它在特定场合简化代码逻辑。

>> 本条要点：
•  了解变长参数函数的特点和约束；
•  变长参数函数可以在有限情况下模拟函数重载、可选参数和默认参数，但要谨慎使用，不要造成混淆；
•  利用变长参数函数实现功能选项模式。


# 第五部分　接口

## 第26条 了解接口类型变量的内部表示


+ 如果要从Go语言中挑选出一个语言特性放入其他语言，我会选择接口。
——Russ Cox，Go核心团队技术负责人
从语言设计角度来看，对于笔者来说，Go的接口和并发是最令人兴奋的。接口是Go这门静态类型语言中唯一“动静兼备”的语言特性。

+ 接口类型变量在程序运行时可以被赋值为不同的动态类型变量，从而支持运行时多态。


### 26.1　nil error值!= nil
```go
 // chapter5/sources/interface-internal-1.go 
type MyError struct {    
    error
}
var ErrBad = MyError{    
    error: errors.New("bad error"),
}
func bad() bool {    
    return false
}
func returnsError() error {    
    var p *MyError = nil    
    if bad() {        
        p = &ErrBad    
    }    
    return p
}
func main() {    
    e := returnsError()    
    if e != nil {        
        fmt.Printf("error: %+v\n", e)        
        return    
    }    
    fmt.Println("ok")
}
``` 

+ 初学者的思路大致是这样的：p为nil，returnsError返回p，那么main函数中的e就等于nil，于是程序输出ok后退出。但真实的运行结果是什么样的呢？我们来看一下：
`$go run interface-internal-1.go error: <nil>`

+ 疑惑出现了：明明returnsError函数返回的p值为nil，为何却满足了if e != nil的条件进入错误处理分支呢？要想弄清楚这个问题，非了解接口类型变量的内部表示不可。


### 26.2 接口类型变量的内部表示

+ 接口类型“动静兼备”的特性决定了它的变量的内部表示绝不像静态类型（如int、float64）变量那样简单。我们可以在$GOROOT/src/runtime/runtime2.go中找到接口类型变量在运行时的表示：
```go
// $GOROOT/src/runtime/runtime2.go 
type iface struct {    
    tab  *itab    
    data unsafe.Pointer
}
type eface struct {    
    _type *_type    
    data  unsafe.Pointer
}
```

+ 我们看到在运行时层面，接口类型变量有两种内部表示——eface和iface，这两种表示分别用于不同接口类型的变量。
•  eface：用于表示没有方法的空接口（empty interface）类型变量，即interface{}类型的变量。
•  iface：用于表示其余拥有方法的接口（interface）类型变量。
这两种结构的共同点是都有两个指针字段，并且第二个指针字段的功用相同，都指向当前赋值给该接口类型变量的动态类型变量的值。

+ 不同点在于eface所表示的空接口类型并无方法列表，因此其第一个指针字段指向一个_type类型结构，该结构为该接口类型变量的动态类型的信息：
```go
// $GOROOT/src/runtime/type.go 
type _type struct {    
    size       uintptr    
    ptrdata    uintptr    
    hash       uint32    
    tflag      tflag    align      uint8    
    fieldalign uint8    
    kind       uint8    
    alg        *typeAlg    
    gcdata    *byte    
    str       nameOff    
    ptrToThis typeOff
}
```
而iface除了要存储动态类型信息之外，还要存储接口本身的信息（接口的类型信息、方法列表信息等）以及动态类型所实现的方法的信息，因此iface的第一个字段指向一个itab类型结构：
```go
// $GOROOT/src/runtime/runtime2.go 
type itab struct {    
    inter *interfacetype    
    _type *_type    
    hash  uint32    
    _     [4]byte    
    fun   [1]uintptr
}
```
上面itab结构中的第一个字段inter指向的interfacetype结构存储着该接口类型自身的信息。interfacetype类型定义如下，该interfacetype结构由类型信息（typ）、包路径名（pkgpath）和接口方法集合切片（mhdr）组成。
```go
// $GOROOT/src/runtime/type.go 
type interfacetype struct {    
    typ     _type    
    pkgpath name    
    mhdr    []imethod
}
```
itab结构中的字段_type则存储着该接口类型变量的动态类型的信息，字段fun则是动态类型已实现的接口方法的调用地址数组。
下面我们结合例子用图片来直观展现eface和iface的结构。

>> 首先看一个用eface表示空接口类型变量的例子：
```go
type T struct {    
    n int    s string
}
func main() {   
    var t = T {        
        n: 17,        
        s: "hello, interface",    
    }    
    var ei interface{} = t // Go运行时使用eface结构表示ei
}
```
该例子对应于图26-1。

>> 
图26-1　空接口类型变量ei的内部表示
下面是用iface表示非空接口类型变量的例子：
```go
type T struct {    
    n int    
    s string
}
func (T) M1() {}
func (T) M2() {}
type NonEmptyInterface interface {    
    M1()    
    M2()
}
func main() {    
    var t = T{        
        n: 18,        
        s: "hello, interface",    
    }    
    var i NonEmptyInterface = t
}
```
和eface比起来，iface的表示稍复杂些，该例子对应于图26-2。

图26-2　非空接口类型变量i的内部表示

>> 由图26-1和图26-2可以看出，每个接口类型变量在运行时的表示都是由两部分组成的，这两种接口类型可以分别简记为eface(_type, data)和iface(tab, data)。虽然eface和iface的第一个字段有所差别，但tab和_type可统一看作动态类型的类型信息。Go语言中每种类型都有唯一的_type信息，无论是内置原生类型，还是自定义类型。Go运行时会为程序内的全部类型建立只读的共享_type信息表，因此拥有相同动态类型的同类接口类型变量的_type/tab信息是相同的。而接口类型变量的data部分则指向一个动态分配的内存空间，该内存空间存储的是赋值给接口类型变量的动态类型变量的值。未显式初始化的接口类型变量的值为nil，即该变量的_type/tab和data都为nil。这样，我们要判断两个接口类型变量是否相同，只需判断_type/tab是否相同以及data指针所指向的内存空间所存储的数据值是否相同（注意：不是data指针的值）。
肉眼辨别接口类型变量是否相等有些困难，我们可以引入一些帮助函数（helper function）。借助这些帮助函数，我们可以清晰地输出接口类型变量的内部表示，这样两个变量是否相等就一目了然了。

>> eface和iface是runtime包中的非导出结构体定义，我们不能直接在包外使用，也就无法直接访问两个结构体中的数据。不过Go语言提供了println预定义函数，可以用来输出eface或iface的两个指针字段的值。println在编译阶段会由编译器根据要输出的参数的类型将println替换为特定的函数，这些函数都定义在$GOROOT/src/runtime/print.go文件中，而针对eface和iface类型的打印函数实现如下：
```go
// $GOROOT/src/runtime/print.go 
func printeface(e eface) {    
    print("(", e._type, ",", e.data, ")")
}
func printiface(i iface) {    
    print("(", i.tab, ",", i.data, ")")
}
```
我们看到printeface和printiface会输出各自的两个指针字段的值。在下面的例子中，我们就使用println输出各类接口类型变量的内部表示信息，并结合输出结果解析接口类型变量的等值比较。

>> （1）nil接口变量
未赋初始值的接口类型变量的值为nil，这类变量即为nil接口变量，下面是这类变量的内部表示输出：
```go
// chapter5/sources/interface-internal-2.go 
func printNilInterface() {    
    // nil接口变量    
    var i interface{} // 空接口类型    
    var err error     // 非空接口类型    
    println(i)    
    println(err)    
    println("i = nil:", i == nil)    
    println("err = nil:", err == nil)    
    println("i = err:", i == err)    
    println("")
}
// 输出结果
(0x0,0x0)
(0x0,0x0)
i = nil: true
err = nil: true
i = err: true
```
我们看到，无论是空接口类型变量还是非空接口类型变量，一旦变量值为nil，那么它们内部表示均为(0x0,0x0)，即类型信息和数据信息均为空。因此上面的变量i和err等值判断为true。

>> （2）空接口类型变量
下面是空接口类型变量的内部表示输出的例子：
```go
// chapter5/sources/interface-internal-2.go 
func printEmptyInterface() {    
    var eif1 interface{}  // 空接口类型    
    var eif2 interface{}  // 空接口类型    
    var n, m int = 17, 18    
    eif1 = n    
    eif2 = m    
    println("eif1:", eif1)    
    println("eif2:", eif2)    
    println("eif1 = eif2:", eif1 == eif2)    
    eif2 = 17    
    println("eif1:", eif1)    
    println("eif2:", eif2)    
    println("eif1 = eif2:", eif1 == eif2)    
    eif2 = int64(17)    
    println("eif1:", eif1)    
    println("eif2:", eif2)    
    println("eif1 = eif2:", eif1 == eif2)    
    println("")
}
// 输出结果
eif1: (0x10ac580,0xc00007ef48)
eif2: (0x10ac580,0xc00007ef40)
eif1 = eif2: false
eif1: (0x10ac580,0xc00007ef48)
eif2: (0x10ac580,0x10eb3d0)
eif1 = eif2: true
eif1: (0x10ac580,0xc00007ef48)
eif2: (0x10ac640,0x10eb3d8)
eif1 = eif2: false
```
从输出结果可以看到：对于空接口类型变量，只有在_type和data所指数据内容一致（注意：不是数据指针的值一致）的情况下，两个空接口类型变量之间才能画等号。
Go在创建eface时一般会为data重新分配内存空间，将动态类型变量的值复制到这块内存空间，并将data指针指向这块内存空间。因此我们在多数情况下看到的data指针值是不同的。但Go对于data的分配是有优化的，也不是每次都分配新内存空间，就像上面的eif2的0x10eb3d0和0x10eb3d8两个data指针值，显然是直接指向了一块事先创建好的静态数据区。

>> （3）非空接口类型变量
下面是非空接口类型变量的内部表示输出的例子：
```go
// chapter5/sources/interface-internal-2.go 
func printNonEmptyInterface() {    
    var err1 error // 非空接口类型    
    var err2 error // 非空接口类型    
    err1 = (*T)(nil)    
    println("err1:", err1)    
    println("err1 = nil:", err1 == nil)    
    err1 = T(5)    
    err2 = T(6)    
    println("err1:", err1)    
    println("err2:", err2)    
    println("err1 = err2:", err1 == err2)    
    err2 = fmt.Errorf("%d\n", 5)    
    println("err1:", err1)    
    println("err2:", err2)    
    println("err1 = err2:", err1 == err2)    
    println("")
}
// 输出结果
err1: (0x10ed120,0x0)
err1 = nil: false
err1: (0x10ed1a0,0x10eb310)
err2: (0x10ed1a0,0x10eb318)
err1 = err2: false
err1: (0x10ed1a0,0x10eb310)
err2: (0x10ed0c0,0xc000010050)
err1 = err2: false
```
与空接口类型变量一样，只有在tab和data所指数据内容一致的情况下，两个非空接口类型变量之间才能画等号。注意err1下面的赋值情况：
err1 = (*T)(nil)
针对这种赋值，println输出的err1是(0x10ed120, 0x0)，即非空接口类型变量的类型信息并不为空，数据指针为空，因此它与nil(0x0,0x0)之间不能画等号。
我们回到26.1节最后的那个问题。从returnsError返回的error接口类型变量e的数据指针虽然为空，但其类型信息（iface.tab）并不为空（而是*MyError对应的类型信息），因此与nil(0x0,0x0)自然不相等，这就是那个问题的答案。

>> （4）空接口类型变量与非空接口类型变量的等值比较
下面是非空接口类型变量和空接口类型变量之间进行比较的例子：
```go
// chapter5/sources/interface-internal-2.go 
func printEmptyInterfaceAndNonEmptyInterface() {    
    var eif interface{} = T(5)    
    var err error = T(5)    
    println("eif:", eif)    
    println("err:", err)    p
    rintln("eif = err:", eif == err)    
    err = T(6)    
    println("eif:", eif)    
    println("err:", err)    
    println("eif = err:", eif == err)
}
// 输出结果
eif: (0x10b3b00,0x10eb4d0)
err: (0x10ed380,0x10eb4d8)
eif = err: true
eif: (0x10b3b00,0x10eb4d0)
err: (0x10ed380,0x10eb4e0)
eif = err: false
```
空接口类型变量和非空接口类型变量内部表示的结构有所不同（第一个字段：_type vs. tab），似乎一定不能相等。但Go在进行等值比较时，类型比较使用的是eface的_type和iface的tab._type，因此就像我们在这个例子中看到的那样，当eif和err都被赋值为T(5)时，两者之间是可以画等号的。


### 26.3 输出接口类型变量内部表示的详细信息

>> 26.3　输出接口类型变量内部表示的详细信息

>> eface和iface以及组成它们的itab和_type都是runtime包下的非导出结构体，我们无法在外部直接引用它们。不过组成eface、iface的类型都是基本数据类型，我们完全可以通过复制代码的方式将它们拿到runtime包外面来。由于runtime中的eface、iface或其组成类型可能随着Go版本的变化而变化，因此这个方法不具备跨版本兼容性：基于Go 1.13版本复制的代码，可能仅适用于使用Go 1.13版本编译。这里就以Go 1.13版本为例来讲解这个方法，相关代码如下。
```
// chapter5/sources/dumpinterface.goconst ptrSize = unsafe.Sizeof(uintptr(0))...type _type struct {    size       uintptr    ptrdata    uintptr    hash       uint32    tflag      tflag    align      uint8    fieldalign uint8    kind       uint8    alg        *typeAlg    gcdata     *byte    str        nameOff    ptrToThis  typeOff}type itab struct {    inter *interfacetype    _type *_type    hash  uint32    _     [4]byte    fun   [1]uintptr}type eface struct {    _type *_type    data  unsafe.Pointer}type iface struct {    tab  *itab    data unsafe.Pointer}// 仅适用于Go 1.13.x版本func dumpEface(i interface{}) {    ptrToEface := (*eface)(unsafe.Pointer(&i))    fmt.Printf("eface: %+v\n", *ptrToEface)    if ptrToEface._type != nil {        // 输出_type        fmt.Printf("\t _type: %+v\n", *(ptrToEface._type))    }    if ptrToEface.data != nil {        // 输出data        switch i.(type) {        case int:            dumpInt(ptrToEface.data)        case float64:            dumpFloat64(ptrToEface.data)        case T:            dumpT(ptrToEface.data)        // 其他case        default:            fmt.Printf("\t data: unsupported type\n")        }    }    fmt.Printf("\n")}func dumpItabOfIface(ptrToIface unsafe.Pointer) {    p := (*iface)(ptrToIface)    fmt.Printf("iface: %+v\n", *p)    if p.tab != nil {        // 输出itab        fmt.Printf("\t itab: %+v\n", *(p.tab))        // 输出itab中的inter        fmt.Printf("\t\t inter: %+v\n", *(p.tab.inter))        // 输出itab中的_type        fmt.Printf("\t\t _type: %+v\n", *(p.tab._type))        // 输出tab中的dump        funPtr := unsafe.Pointer(&(p.tab.fun))        fmt.Printf("\t\t fun: [")        for i := 0; i < len((*(p.tab.inter)).mhdr); i++ {            tp := (*uintptr)(unsafe.Pointer(uintptr(funPtr) + uintptr(i)*ptrSize))            fmt.Printf("0x%x(%d),", *tp, *tp)        }        fmt.Printf("]\n")    }}func dumpDataOfIface(i interface{}) {    ptrToEface := (*eface)(unsafe.Pointer(&i))    if ptrToEface.data != nil {        // 输出data        switch i.(type) {        case int:            dumpInt(ptrToEface.data)        case float64:            dumpFloat64(ptrToEface.data)        case T:            dumpT(ptrToEface.data)        // 其他case        default:            fmt.Printf("\t data: unsupported type\n")        }    }    fmt.Printf("\n")}func dumpT(dataOfIface unsafe.Pointer) {    var p *T = (*T)(dataOfIface)    fmt.Printf("\t data: %+v\n", *p)}...
```
鉴于篇幅有限，这里省略了部分代码。dumpinterface.go中提供了以下3个主要函数。
•  dumpEface：用于输出空接口类型变量的内部表示信息。
•  dumpItabOfIface：用于输出非空接口类型变量的tab字段信息。

>> •  dumpDataOfIface：用于输出非空接口类型变量的data字段信息。
我们利用这3个函数来输出前面printEmptyInterfaceAndNonEmptyInterface函数中的接口类型变量的信息，代码如下。
```
// chapter5/sources/interface-internal-3.gotype T intfunc (t T) Error() string {    return "bad error"}func main() {    var eif interface{} = T(5)    var err error = T(5)    println("eif:", eif)    println("err:", err)    println("eif = err:", eif == err)    dumpEface(eif)    dumpItabOfIface(unsafe.Pointer(&err))    dumpDataOfIface(err)}
运行上述代码：
$go run interface-internal-3.go dumpinterface.goeif: (0x10b4300,0x10ec430)err: (0x10ee300,0x10ec438)eif = err: trueeface: {_type:0x10b4300 data:0x10ec430}    _type: {size:8 ptrdata:0 hash:1156555957 tflag:7 align:8 fieldalign:8 kind:2 alg:0x1179ad0 gcdata:0x10eb038 str:7042 ptrToThis:103712}    data: bad erroriface: {tab:0x10ee300 data:0x10ec438}    itab: {inter:0x10b7340 _type:0x10b4300 hash:1156555957 _:[0 0 0 0] fun:[17414384]}        inter: {typ:{size:16 ptrdata:16 hash:235953867 tflag:7 align:8 fieldalign:8 kind:20 alg:0x1179b00 gcdata:0x10eb039 str:5450 ptrToThis:47552} pkgpath:{bytes:<nil>} mhdr:[{name:4168 ityp:69920}]}        _type: {size:8 ptrdata:0 hash:1156555957 tflag:7 align:8 fieldalign:8 kind:2 alg:0x1179ad0 gcdata:0x10eb038 str:7042 ptrToThis:103712}        fun: [0x109b8f0(17414384),]    data: bad error
```
>> 从输出结果中我们看到，eif的_type（0x10b4300）与err的tab._type（0x10b4300）是一致的，data指针所指内容（"bad error"）也是一致的，因此eif == err表达式的结果为true。
上述实现可能仅适用于Go 1.13版本，并且在输出data内容时没有列出全部类型的实现，读者可根据自己的需要实现其余数据类型。


###  26.4 接口类型的装箱原理

>> 在Go语言中，将任意类型赋值给一个接口类型变量都是装箱操作。

>> 接口类型的装箱实则就是创建一个eface或iface的过程

>> 由此我们也可以看出，经过装箱后，箱内的数据（存放在新分配的内存空间中）与原变量便无瓜葛了，除非是指针类型。

>> 那么convT2E和convT2I函数的类型信息从何而来？这些都依赖Go编译器的工作。编译器知道每个要转换为接口类型变量（toType）的动态类型变量的类型（fromType），会根据这一类型选择适当的convT2X函数（见下面代码中的convFuncName），并在生成代码时使用选出的convT2X函数参与装箱操作

+ 装箱是一个有性能损耗的操作，因此Go在不断对装箱操作进行优化，包括对常见类型（如整型、字符串、切片等）提供一系列快速转换函数：
```go
// $GOROOT/src/cmd/compile/internal/gc/builtin/runtime.go
// 实现在 $GOROOT/src/runtime/iface.go中
func convT16(val any) unsafe.Pointer     // val必须是一个uint-16相关类型的参数
func convT32(val any) unsafe.Pointer     // val必须是一个unit-32相关类型的参数
func convT64(val any) unsafe.Pointer     // val必须是一个unit-64相关类型的参数
func convTstring(val any) unsafe.Pointer // val必须是一个字符串类型的参数
func convTslice(val any) unsafe.Pointer  // val必须是一个切片类型的参数
```
这些函数去除了typedmemmove操作，增加了零值快速返回等。
同时Go建立了staticbytes区域，对byte大小的值进行装箱操作时不再分配新内存[3]，而是利用staticbytes区域的内存空间，如bool类型等。

### 小结
本条从Go FAQ中的一个例子出发，解释了nil接口变量不等于nil的原因，并和大家一起深入探究了Go接口类型的两种内部表示，了解了接口类型变量的装箱过程。
本条要点：
•  接口类型变量在运行时表示为eface和iface，eface用于表示空接口类型变量，iface用于表示非空接口类型变量；
•  当且仅当两个接口类型变量的类型信息（eface._type/iface.tab._type）相同，且数据指针（eface.data/iface.data）所指数据相同时，两个接口类型才是相等的；
•  通过println可以输出接口类型变量的两部分指针变量的值；
•  可通过复制runtime包eface和iface相关类型源码，自定义输出eface/iface详尽信息的函数；
•  接口类型变量的装箱操作由Go编译器和运行时共同完成。


## 第27条 尽量定义小接口

+ 尽量定义小接口接口越大，抽象程度越低。——Rob Pike，Go语言之父

+ 接口越大，抽象程度越低。
——Rob Pike，Go语言之父


### 27.1 Go推荐定义小接口


>> •  契约的自动遵守：Go语言中接口与其实现者之间的关系是隐式的，无须像其他语言（如Java）那样要求实现者显式放置implements声明；实现者仅需实现接口方法集中的全部方法，便算是自动遵守了契约，实现了该接口。
•  小契约：契约繁了便束缚了手脚，降低了灵活性，抑制了表现力。Go选择使用小契约，表现在代码上便是尽量定义小接口。

>> 契约的自动遵守：Go语言中接口与其实现者之间的关系是隐式的，无须像其他语言（如Java）那样要求实现者显式放置implements声明；实现者仅需实现接口方法集中的全部方法，便算是自动遵守了契约，实现了该接口。

>> 接口的方法数量为1～3个，这种小接口的Go最佳实践已被Go程序员和各个社区项目广泛采用

>> 无论是标准库还是社区项目，都遵循了“尽量定义小接口”的建议，方法数量在1～3个范围内的接口占了绝大多数。


### 27.2 小接口的优势

1. 接口越小，抽象程度越高，被接纳度越高

>> 接口越小（接口方法少），抽象程度越高，对应的事物集合越大，即被事物接纳的程度越高。而这种情况的极限恰是无方法的空接口interface{}，空接口的这个抽象对应的事物集合空间包含了Go语言世界的所有事物。

2. 易于实现和测试

3. 契约职责单一，易于复用组合

>> Go的设计原则推崇通过组合的方式构建程序。Go开发人员一般会首先尝试通过嵌入其他已有接口类型的方式来构建新接口类型，就像通过嵌入io.Reader和io.Writer构建io.ReadWriter那样。


### 27.3 定义小接口可以遵循的一些点

1. 抽象出接口

初期不要在意接口的大小，因为对问题域的理解是循序渐进的，期望在第一版代码中直接定义出小接口可能并不现实。标准库中的io.Reader和io.Writer也不是在Go刚诞生时就有的，而是在发现对网络、文件、其他字节数据处理的实现十分相似之后才抽象出来的。此外，越偏向业务层，抽象难度越高

2. 将大接口拆分为小接口

3. 接口的单一契约职责

### 小结
本条介绍了Go在接口定义上的一个惯例，即“尽量定义小接口”，并给出了小接口的优点以及定义小接口的思路。

### 本条要点：
•  接口是将对象的行为进行抽象而形成的契约；
•  Go青睐定义小接口，即方法数量为1～3个、通常为1个的接口（这种最佳实践被Go社区项目广泛采纳）；
•  小接口抽象程度高，被接纳度高，易于实现和测试，易于复用组合；
•  先抽象出接口，再拆分为小接口，另外接口的契约职责应尽可能保持单一。

>> [1]接口方法数量统计工具：https://github.com/bigwhite/itfmc。


### 第28条 尽量避免使用空接口作为函数参数类型

+ 空接口不提供任何信息。
——Rob Pike，Go语言之父

+ Go编译器通过解析该接口定义得到接口的名字信息及方法信息，在为此接口类型参数赋值时，编译器就会根据这些信息对实参进行检查。这时，如果函数或方法的参数类型为空接口interface{}，会发生什么呢？这恰好就应了本条开头引用的Rob Pike的那句话：“空接口不提供任何信息。”这里“提供”一词的对象不是开发者，而是编译器。在函数或方法参数中使用空接口类型，意味着你没有为编译器提供关于传入实参数据的任何信息，因此，你将失去静态类型语言类型安全检查的保护屏障，你需要自己检查类似的错误，并且直到运行时才能发现此类错误。

>> 因此，建议广大Gopher尽可能抽象出带有一定行为契约的接口，并将其作为函数参数类型，尽量不要使用可以逃过编译器类型安全检查的空接口类型（interface{}）。
在这方面，Go标准库做出了表率。全面搜索标准库后，你可以发现以interface{}为参数类型的方法和函数少之又少。使用interface{}作为参数类型的函数或方法主要有两类：
•  容器算法类，比如sort包、sync.Map包以及container下的heap、list和ring包等；
•  格式化/日志类，比如fmt包、log包等。
这些函数或方法的共同特点是它们面对的都是未知类型的数据，因此使用interface{}也可以理解为Go语言尚未支持泛型的一个权宜之计。

+ 最后，总结一下，本条的主要内容如下：
•  仅在处理未知类型数据时使用空接口类型；
•  在其他情况下，尽可能将你需要的行为抽象成带有方法的接口，并使用这样的非空接口类型作为函数或方法的参数。


### 第29条 使用接口作为程序水平组合的连接点

+ “偏好组合，正交解耦”是Go语言的重要设计哲学之一。如果说“追求简单”聚焦的是为Go程序提供各种小而精的零件，那么组合关注的就是如何将这些零件关联到一起，搭建出程序的静态骨架。


### 29.1 一切皆组合

+ Go语言中主要有两种组合方式。
•  垂直组合（类型组合）：Go语言主要通过类型嵌入机制实现垂直组合，进而实现方法实现的复用、接口定义重用等。
•  水平组合：通常Go程序以接口类型变量作为程序水平组合的连接点。接口是水平组合的关键，它就好比程序肌体上的关节，给予连接关节的两个部分或多个部分各自自由活动的能力，而整体又实现了某种功能。


### 29.2 垂直组合回顾

+ Go语言通过类型的垂直组合而不是继承让单一类型承载更多的功能。由于不是继承，所以也就没有“父子类型”的概念，也没有向上、向下转型（type casting）；被嵌入的类型也不知道将其嵌入的外部类型的存在。调用方法时，方法的匹配取决于方法名称，而不是类型。

+ Go语言通过类型嵌入实现垂直组合。组合方式莫过于以下3种。
（1）通过嵌入接口构建接口

+ 通过在接口定义中嵌入其他接口类型实现接口行为聚合，组成大接口。这种方式在标准库中尤为常见，比如下面io包中的例子：
```go
// $GOROOT/src/io/io.go 
type ReadWriter interface {    
    Reader    Writer
}
```
+ （2）通过嵌入接口构建结构体
通过嵌入接口类型的方式构建结构体类型，就像下面的示例代码：
```go
type MyReader struct {    
    io.Reader // 底层的reader    
    N int64   // 剩余最大字节数
}
```
嵌入io.Reader的MyReader类型自然实现了io.Reader接口。另外前面提到过，在结构体中嵌入接口可以用于快速构建满足某一接口的结构体类型，以满足某单元测试的需要，而我们仅需实现少数需要的接口方法即可，尤其是在将这样的结构体类型变量赋值给大接口时。
（3）通过嵌入结构体构建新结构体

>> 下面是通过嵌入Mutex结构体类型构建poolLocal结构体类型的示例：
```go
// $GOROOT/src/sync/pool.go 
type poolLocal struct {    
    private interface{}    
    shared  []interface{}    
    Mutex    
    pad     [128]byte
}
```

>> 这样嵌入Mutex的poolLocal“继承”了Mutex的Lock和Unlock实现，但实质上在结构体中嵌入接口类型名和在结构体中嵌入其他结构体都是“委派模式”（delegate）的一种应用。对新结构体类型的方法调用可能会被“委派”给该结构体内部嵌入的结构体的实例。比如上面的poolLocal结构体，对于外部来说它拥有Lock和Unlock方法，但当Lock/Unlock方法被调用时，方法调用实际被传给了poolLocal中的Mutex实例。


### 29.3 以接口为连接点的水平组合

>> 以接口为连接点的水平组合方式可以将各个垂直组合出的类型耦合在一起，从而编织出程序静态骨架。而通过接口进行水平组合的一种常见模式是使用接受接口类型参数的函数或方法。以下是以接口为连接点的水平组合的几种惯用形式。
1. 基本形式
水平组合的基本形式是接受接口类型参数的函数或方法，代码如下。
func YourFuncName(param YourInterfaceType)

>> 水平组合的基本形式如图29-1所示，从中可以看到，函数/方法参数中的接口类型作为连接点，将位于多个包中的多个类型“编织”到一起，共同形成一幅程序“骨架”。同时接口类型与其实现者之间隐式的关系在不经意间满足了依赖抽象、里氏替换原则、接口隔离等代码设计原则，这在其他语言中是需要刻意设计和谋划的，但对Go接口来看，这一切却是自然而然的。

>> 
图29-1　以接口为连接点的水平组合的基本形式
这一水平组合的基本形式在标准库中也有着广泛的应用，例如：
```go
// $GOROOT/src/io/ioutil/ioutil.go 
func readAll(r io.Reader, capacity int64) (b []byte, err error)
// $GOROOT/src/io/io.go 
func Copy(dst Writer, src Reader) (written int64, err error)
```

2. 包裹函数
包裹函数（wrapper function）的形式是这样的：它接受接口类型参数，并返回与其参数类型相同的返回值。其代码如下：
```go
func YourWrapperFunc(param YourInterfaceType) YourInterfaceType
```
通过包裹函数可以实现对输入数据的过滤、装饰、变换等操作，并将结果再次返回给调用者。
下面是Go标准库中一个典型的包裹函数io.LimitReader：
```go
// $GOROOT/src/io/io.go 
func LimitReader(r Reader, n int64) Reader { 
    return &LimitedReader{r, n} 
}
type LimitedReader struct {    
    R Reader    N int64
}
func (l *LimitedReader) Read(p []byte) (n int, err error) {    ...}
```
我们看到LimitReader的一个输入参数为io.Reader接口类型，返回值类型依然为io.Reader。

+ 由于包裹函数的返回值类型与参数类型相同，因此我们可以将多个接受同一接口类型参数的包裹函数组合成一条链来调用，其形式如下：
YourWrapperFunc1(YourWrapperFunc2(YourWrapperFunc3(...)))

3. 适配器函数类型

>> 适配器函数类型（adapter function type）是一个辅助水平组合实现的“工具”类型。强调一下，它是一个类型。它可以将一个满足特定函数签名的普通函数显式转换成自身类型的实例，转换后的实例同时也是某个单方法接口类型的实现者。最典型的适配器函数类型莫过于第21条提到过的http.HandlerFunc了。
```go
// $GOROOT/src/net/http/server.go
type Handler interface {    
	ServeHTTP(ResponseWriter, *Request)
	}
type HandlerFunc func(ResponseWriter, *Request)
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {    
	f(w, r)
}// chapter5/sources/horizontal-composition-3.go
func greetings(w http.ResponseWriter, r *http.Request) {    
	fmt.Fprintf(w, "Welcome!")
}
func main() {    
	http.ListenAndServe(":8080", http.HandlerFunc(greetings))
}
```
可以看到，在上述例子中通过http.HandlerFunc这个适配器函数类型，可以将普通函数greetings快速转换为实现了http.Handler接口的类型。转换后，我们便可以将其实例用作实参，实现基于接口的组合了。

4. 中间件
“中间件”（middleware）这个词的含义可大可小，在Go Web编程中，它常常指的是一个实现了http.Handler接口的http.HandlerFunc类型实例。实质上，这里的中间件就是包裹函数和适配器函数类型结合的产物。
```go
// chapter5/sources/horizontal-composition-4.go 
func validateAuth(s string) error {    
    if s != "123456" {        
        return fmt.Errorf("%s", "bad auth token")    
    }    
    return nil
}
func greetings(w http.ResponseWriter, r *http.Request) {    
    fmt.Fprintf(w, "Welcome!")
}
func logHandler(h http.Handler) http.Handler {    
    return http.HandlerFunc(
        func(w http.ResponseWriter, r *http.Request) {        
            t := time.Now()        
            log.Printf("[%s] %q %v\n", r.Method, r.URL.String(), t)        
            h.ServeHTTP(w, r)    
        })
}
func authHandler(h http.Handler) http.Handler {    
    return http.HandlerFunc(
        func(w http.ResponseWriter, r *http.Request) {        
            err := validateAuth(r.Header.Get("auth"))        
            if err != nil {            
                http.Error(w, "bad auth param", http.StatusUnauthorized)            
                return        
            }        
            h.ServeHTTP(w, r)    
        })
}
func main() {    
    http.ListenAndServe(":8080", logHandler(
        authHandler(
            http.HandlerFunc(greetings))))
}
```
运行这个示例，并用curl工具命令对其进行测试：
`$ go run horizontal-composition-4.go$curl http://localhost:8080bad auth param$curl -H "auth:123456" localhost:8080/Welcome!`

+ 我们看到所谓中间件（如logHandler、authHandler）本质上就是一个包裹函数（支持链式调用），但其内部利用了适配器函数类型（http.HandlerFunc）将一个普通函数（如例子中的几个匿名函数）转换为实现了http.Handler的类型的实例，并将其作为返回值返回。

### 小结
本条针对接口在面向组合编程中的作用展开，回顾了垂直组合的几种情况以及以接口类型参数为连接点的水平组合的几种常见形式。
本条要点：
•  深入理解Go的组合设计哲学；
•  垂直组合可实现方法实现和接口定义的重用；
•  掌握使用接口作为程序水平组合的连接点的几种形式。


## 第30条 使用接口提高代码的可测试性

+ Go语言有一个惯例是让单元测试代码时刻伴随着你编写的Go代码。阅读过Go自身实现及标准库代码的Gopher都清楚，每个标准库的Go包都包含对应的测试代码。

+ 为一段代码编写测试代码的前提是这段代码具有可测试性。如果代码不可测或可测试性较低，那么无论是为其编写测试代码，还是运行编写后的测试，都需要开发人员较多的额外付出，这将打击开发人员编写测试代码的积极性，从而降低测试代码比例或完全不编写测试代码，这种情况是我们所不愿意见到的。

+ 单元测试是自包含和自运行的，运行时一般不会依赖外部资源（如外部数据库、外部邮件服务器等），并具备跨环境的可重复性（比如：既可以在开发人员的本地运行，也可以在持续集成环境中运行）。因此，一旦被测代码耦合了对外部资源的依赖，被测代码的可测试性就不高，也会让开发人员有了“这段代码无法测试”的理由。为了提高代码的可测试性，我们就要降低代码耦合，管理被测代码对外部资源的依赖。而这也是接口可以发挥其魔力的地方。本条我们就来看看如何使用接口来提高代码的可测试性。



### 30.1　实现一个附加免责声明的电子邮件发送函数

### 30.2 使用接口来降低耦合

>> 接口本是契约，天然具有降低耦合的作用。下面我们就用接口对v1版SendMailWithDisclaimer实现进行改造，将其对github.com/jordan-wright/email的依赖去除，将发送邮件的行为抽象成接口MailSender，并暴露给SendMailWithDisclaimer的用户。
```go
// chapter5/sources/send_mail_with_disclaimer/v2/mail.go
// 考虑到篇幅，这里省略一些代码...
type MailSender interface {    
    Send(subject, from string, to []string, content string, mailserver string, a smtp.Auth) error
}
func SendMailWithDisclaimer(sender MailSender, subject, from string,    to []string, content string, mailserver string, a smtp.Auth) error {    
    return sender.Send(subject, from, to, attachDisclaimer(content), mailserver, a)
}
```
现在如果要对SendMailWithDisclaimer进行测试，我们完全可以构造出一个或多个fake MailSender（根据不同单元测试用例的需求定制），

>> 下面是一个例子：
```go
// chapter5/sources/send_mail_with_disclaimer/v2/mail_test.go
package mail_test
import (    
    "net/smtp"    
    "testing"    
    mail "github.com/bigwhite/mail"
)
type FakeEmailSender struct {    
    subject string    
    from    string    
    to      []string    
    content string
}
func (s *FakeEmailSender) Send(subject, from string,    to []string, content string, mailserver string, a smtp.Auth) error {    
    s.subject = subject    
    s.from = from    
    s.to = to    
    s.content = content    
    return nil
}
func TestSendMailWithDisclaimer(t *testing.T) {    
    s := &FakeEmailSender{}    
    err := mail.SendMailWithDisclaimer(
        s, "gopher mail test v2",        "YOUR_MAILBOX",        []string{"DEST_MAILBOX"},        "hello, gopher",        "smtp.163.com:25",        smtp.PlainAuth("", "YOUR_EMAIL_ACCOUNT", "YOUR_EMAIL_PASSWD!", "smtp.163.com"))    
        if err != nil {        
            t.Fatalf("want: nil, actual: %s\n", err)        
            return    
        }    
        want := "hello, gopher" + "\n\n" + mail.DISCLAIMER    
        if s.content != want {        
            t.Fatalf("want: %s, actual: %s\n", want, s.content)    
        }
}
```
和v1版中的测试用例不同，v2版的测试用例不再对外部有任何依赖，是具备跨环境可重复性的。在这个用例中，我们对经过mail.SendMailWithDisclaimer处理后的content字段进行了验证，验证其是否包含免责声明，这也是在v1版中无法进行测试验证的。

>> 如果依然要使用github.com/jordan-wright/email包中Email实例作为邮件发送者，那么由于Email类型并不是上面MailSender接口的实现者，我们需要在业务代码中做一些适配工作，比如下面的代码：
```go
// chapter5/sources/send_mail_with_disclaimer/v2/example_test.go 
package mail_test
import (    
    "fmt"    
    "net/smtp"    
    mail "github.com/bigwhite/mail"    
    email "github.com/jordan-wright/email"
)
type EmailSenderAdapter struct {    
    e *email.Email
}
func (adapter *EmailSenderAdapter) Send(subject, from string,    to []string, content string, mailserver string, a smtp.Auth) error {    
    adapter.e.Subject = subject    
    adapter.e.From = from    
    adapter.e.To = to    
    adapter.e.Text = []byte(content)    
    return adapter.e.Send(mailserver, a)
}
func ExampleSendMailWithDisclaimer() {    
    adapter := &EmailSenderAdapter{        
        e: email.NewEmail(),    
    }    
    err := mail.SendMailWithDisclaimer(adapter, "gopher mail test v2",        "YOUR_MAILBOX",        []string{"DEST_MAILBOX"},        "hello, gopher",        "smtp.163.com:25",        smtp.PlainAuth("", "YOUR_EMAIL_ACCOUNT", "YOUR_EMAIL_PASSWD!", "smtp.163.com"))    
    if err != nil {        
        fmt.Printf("SendMail error: %s\n", err)        
        return    
    }    
    fmt.Println("SendMail ok")    // OutPut:    // SendMail ok
}
```
我们使用一个适配器对github.com/jordan-wright/email包中的Email实例进行了包装，使其成为接口MailSender的实现者，从而顺利传递给SendMailWithDisclaimer承担发送邮件的责任。

+ 接口MailSender将SendMailWithDisclaimer与具体的Email发送实现之间的耦合解开。通过上述例子我们也可以看出接口在测试过程中成为fake对象或mock对象的注入点。通过这种方式，我们可以通过灵活定制接口实现者以控制实现行为，继而实现对被测代码的代码逻辑的测试覆盖。小结代码的可测试性已经成为判定Go代码是否优秀的一条重要标准。适当抽取接口，让接口成为好代码与单元测试之间的桥梁是Go语言的一种最佳实践。
