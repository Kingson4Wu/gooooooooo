+ Go 1.18 泛型全面讲解：一篇讲清泛型的全部:<https://segmentfault.com/a/1190000041634906>

泛型能实现的功能通过接口+反射也基本能实现。但是使用过反射的人都知道反射机制有很多问题：

用起来麻烦
失去了编译时的类型检查，不仔细写容易出错
性能不太理想
而在泛型适用的时候，它能解决上面这些问题。但这也不意味着泛型是万金油，泛型有着自己的适用场景，当你疑惑是不是该用泛型的话，请记住下面这条经验：

如果你经常要分别为不同的类型写完全相同逻辑的代码，那么使用泛型将是最合适的选择


Go还引入了非常多全新的概念：

类型形参 (Type parameter)
类型实参(Type argument)
类型形参列表( Type parameter list)
类型约束(Type constraint)
实例化(Instantiations)
泛型类型(Generic type)
泛型接收器(Generic receiver)
泛型函数(Generic function)

---

+ Go：为什么泛型使你的程序变慢：<https://mp.weixin.qq.com/s/yuaDFN5kGF9GSApV5q-YzA>
+ 知乎热议：Go 有了泛型性能会不会提升一个档次？:<https://mp.weixin.qq.com/s/EY4iR5Qo2Ci6b0Jl8ERMgQ>
    - 选择正确的数据类型会对性能产生很大影响。但是，我认为我们可以说，那些表示担心泛型会拖慢软件速度的读者可以冷静下来。从好的方面来说，我看到泛型解决方案允许我们更轻松地交换数据类型，从而提高性能。

---

+ Go 1.18新特性解读（万字长文）:<https://mp.weixin.qq.com/s/8CyoGLuepuCI4Hj1Ev0GcQ>

Go泛型是Go诞生以来最复杂、最难读和理解的语法特性，当然泛型的复杂性不仅仅对Go语言生效，对其他具有泛型语法特性的编程语言来说，泛型也都是最复杂的语法。

同样也是因为泛型的复杂性，Go团队在Go 1.18的发布说明文档中保留了在将来的版本中因修复Go泛型bug而对Go 1.18版本编译的程序带来破坏的权力。当然Go团队也承诺将尽可能地减少任何此类破坏，但不能保证此类破坏为零。

另外，Go 1.18的泛型实现并非完全版，有很多使用上的约束。这些约束很大可能将在后续的Go版本中逐步取消掉。并且Go 1.18中的实现与Type Parameter Proposal的design文档有一定差异，Go官方建议以Go语言的规范[2]为准。

