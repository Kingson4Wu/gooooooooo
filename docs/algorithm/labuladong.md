labuladong



# 第二章 动态规划系列

+ 解题基本步骤
    1. 找到“状态”和“选择”
    2. 明确dp数组/函数的定义
    3. 寻找状态之间的关系

## 2.1 最长递增子序列    


## 高楼扔鸡蛋问题

+ https://blog.csdn.net/Ostkakah/article/details/119004570
```java
int maxOperationCount(int eggSize, int Count)//count代表层数并非代表总高度
{
	int i, res = M;
	if(eggSize == 1) return Count;//只剩最后一个鸡蛋,我们就直接线性遍历,所以最坏的情况为全部遍历一遍。
	if(Count == 0) return 0;//高度为0时，就不需要再向下执行了。
	for(i = 1; i <= Count; i++){//为了保证找到对应的步数，我们必须遍历开始时不同的扔鸡蛋的位置
		res = Min(res,
			Max(
				maxOperationCount(eggSize - 1, i - 1),//碎了，鸡蛋数减一，所以我们只要求楼层在自己的基础上高度减一的层数对应的测试步数。 
				maxOperationCount(eggSize, Count - i)//没碎,楼层数为此层之上,所以我们只要求i到Count的层数对应的测试步数。
				)
			) + 1;//每步要加一;  
	}
	return res;
}
int Max(int a, int b)
{
	return (a >= b) ? a : b;
}
int Min(int a,int b)
{
	return (a >= b) ? b : a;
}
```

+ 为了能够列出所有的情况，我们需要进行一个循环，将当前的楼层数全部循环一遍，找出每层鸡蛋会碎的情况和鸡蛋不会碎的情况，因此选择就分为 鸡蛋会碎和鸡蛋不会碎 ，因为要求最坏情况，所以我们要在每层的最多步数中找最小的值，最终就可以求出答案。

### 双蛋问题
+ https://zhuanlan.zhihu.com/p/260378938 !!!
最常见的问法是 N = 100，K = 2，也是就所谓的双蛋问题。跟只有 1 蛋相比，2 个鸡蛋可谓是富足，这个时候就没必要如履薄冰地线性搜索了，步子可以大一点。比如说：

等间隔丢
第一个鸡蛋可以每隔 10 层丢一次：10、20、30...100，如果碎了第二个鸡蛋再从前面的 9 层线性搜索。比如说第一个蛋在 10 层碎了，那么第二个蛋就在 [1,9] 之间试，也就是：

第一个鸡蛋尝试：10 20 30 40 50 60 70 80 90 100（最多尝试 10 次） 第二个鸡蛋最多尝试 9 次

因此，总的来说，最好的情况是第一个蛋在第 10 层就碎了，总次数是 10 次，最坏的情况是第一个蛋在第 100 层碎，总的次数就是 19 次。最好和最坏的情况相差比较大，这是因为第一个蛋每次都是等间隔丢，所以第二个蛋丢的时候，无论如何最坏都要尝试 9 次。

不等间隔丢
使用等间隔丢的方法，如果间距取得比较大，当第一个蛋碎的时候，第二个蛋要试的次数就比较大；当间距取比较小的时候，当 F 的位置越靠后，第一个蛋要试的次数就越大。

有没有办法让两个蛋丢的次数均衡一下呢，试试刚开始的时候间距取大一些，越往后间距逐渐缩小。即：第一次的间隔 为 n，如果没碎第二次的间隔为 n...，一直到最后一层间隔为 1。使用高斯公式可以知道  ，则  ，向上取整 n 等于 14，也就是：

第一个鸡蛋尝试：14 27 39 50 60 89 77 84 90 95 99 100（最多尝试12次） 第二个鸡蛋最多尝试的区间是 [1,13]，一共是13次

因此，总的来说，最好的情况是 12 次，最坏的情况是 14次。相对于等间距的 10 - 19 次要平均一些了，最坏情况的次数也更少。

###  N 层楼和  K个鸡蛋
+ 给定  N 层楼和  K个鸡蛋，要求找到扔下鸡蛋不碎的最高楼层（临界楼层 F ），那么最少尝试几次一定能找到这个临界楼层？我们可以定义问题如下：给定输入 N 、 K ，输出为最少尝试次数 Y
+ 假设在第 i 楼尝试，会存在两种情况（碎和不碎）： - 如果碎了，需要在低楼层 [1, i-1] 搜索，问题规模缩小为：y1=dp(i-1, k-1)  - 如果没碎，需要在高楼层 [i-1, N] 搜索，问题规模缩小为： y2=dp(N-i, k)

+ 提示：  1,10层 2 个鸡蛋 和  11,20层 2个鸡蛋，两个问题是等价的，都是 y=dp(10, 2) ，问题的关键是楼层数量和鸡蛋个数，而不是楼层编号，很好理解，对吧。
+ 因此，对于在第  i楼的尝试，最坏情况下的尝试次数max(y1,y2)  。而 i 可以在 [1, N] 中选择一个，根据题意，我们要找出这  种选择里最少的尝试次数

+ 检查重叠子问题：
这个问题是存在重叠子问题的，例如前面说的 [1,10] 层 2 个鸡蛋 和 [11,20] 层 2个鸡蛋，两个问题是等价的，问题的关键是楼层数量和鸡蛋个数，而不是楼层编号。假如我们曾经计算过函数值  ，那么下一次遇到 N = 10,K = 2 的问题，就可以直接返回前者的答案。

为此，我们需要使用“备忘录”把前者的答案记忆起来。用程序实现无非是基于数组或者基于散列表，这里使用二维数组

+ base case
当楼层数 N 等于 0 时，显然不需要扔鸡蛋；当鸡蛋数 K 为 1 时，显然只能线性扫描所有楼层：

def dp(K, N):
    if K == 1: return N
    if N == 0: return 0

```
def superEggDrop(K: int, N: int):

    memo = dict()
    def dp(K, N) -> int:
        # base case
        if K == 1: return N
        if N == 0: return 0
        # 避免重复计算
        if (K, N) in memo:
            return memo[(K, N)]

        res = float('INF')
        # 穷举所有可能的选择
        for i in range(1, N + 1):
            res = min(res, 
                      max(
                            dp(K, N - i), 
                            dp(K - 1, i - 1)
                         ) + 1
                  )
        # 记入备忘录
        memo[(K, N)] = res
        return res

    return dp(K, N)
```

+ 用二分搜索优化(替代线性搜索)也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，还是穷举

```
// 把线性搜索改成二分搜索
// for (int m = 1; dp[K][m] < N; m++)
int lo = 1, hi = N;
while (lo < hi) {
    int mid = (lo + hi) / 2;
    if (... < N) {
        lo = ...
    } else {
        hi = ...
    }

    for (int k = 1; k <= K; k++)
        // 状态转移方程
}
```

+ 重新定义状态转移
    - dp 数组的定义，确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定 F 的最高楼层数

## 戳气球问题
+ 好复杂的样子，先没仔细看
+ https://zhuanlan.zhihu.com/p/144384951

+ 「全排列」问题，我们前文 回溯算法框架套路详解 中有全排列算法的详解和代码，其实只要稍微改一下逻辑即可，伪码思路如下：

```
int res = Integer.MIN_VALUE;
/* 输入一组气球，返回戳破它们获得的最大分数 */
int maxCoins(int[] nums) {
    backtrack(nums, 0); 
    return res;
}
/* 回溯算法的伪码解法 */
void backtrack(int[] nums, int socre) {
    if (nums 为空) {
        res = max(res, score);
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        int point = nums[i-1] * nums[i] * nums[i+1];
        int temp = nums[i];
        // 做选择
        在 nums 中删除元素 nums[i]
        // 递归回溯
        backtrack(nums, score + point);
        // 撤销选择
        将 temp 还原到 nums[i]
    }
}
```
+ 回溯算法就是这么简单粗暴，但是相应的，算法的效率非常低。这个解法等同于全排列，所以时间复杂度是阶乘级别

### 动态规划
+ 在一排气球 points 中，请你戳破气球 0 和气球 n+1 之间的所有气球（不包括 0 和 n+1），使得最终只剩下气球 0 和气球 n+1 两个气球，最多能够得到多少分？
+ dp[i][j] = x 表示，戳破气球 i 和气球 j 之间（开区间，不包括 i 和 j）的所有气球，可以获得的最高分数为 x
+ 题目要求的结果就是 dp[0][n+1] 的值，而 base case 就是 dp[i][j] = 0，其中 0 <= i <= n+1, j <= i+1，因为这种情况下，开区间 (i, j) 中间根本没有气球可以戳
+ dp[i][j] = dp[i][k] + dp[k][j] 
         + points[i]*points[k]*points[j]

```
int maxCoins(int[] nums) {
    int n = nums.length;
    // 添加两侧的虚拟气球
    int[] points = new int[n + 2];
    points[0] = points[n + 1] = 1;
    for (int i = 1; i <= n; i++) {
        points[i] = nums[i - 1];
    }
    // base case 已经都被初始化为 0
    int[][] dp = new int[n + 2][n + 2];
    // 开始状态转移
    // i 应该从下往上
    for (int i = n; i >= 0; i--) {
        // j 应该从左往右
        for (int j = i + 1; j < n + 2; j++) {
            // 最后戳破的气球是哪个？
            for (int k = i + 1; k < j; k++) {
                // 择优做选择
                dp[i][j] = Math.max(
                    dp[i][j], 
                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]
                );
            }
        }
    }
    return dp[0][n + 1];
}
```

## 0-1 背包问题
+ https://www.cnblogs.com/labuladong/p/13927944.html
+ 给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少

+ 第一步要明确两点，「状态」和「选择」。

先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。所以状态有两个，就是「背包的容量」和「可选择的物品」。

再说选择，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛


+ 第二步要明确 dp 数组的定义。
    - dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]
    - 如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6
    - 为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种套路都被扒得清清楚楚了。
    - 根据这个定义，我们想求的最终答案就是 dp[N][W]。base case 就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

 ```
for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i-1][w], //不把物品 i 装进背包
            dp[i-1][w - wt[i-1]] + val[i-1] // 把物品 i 装进背包,
        )
return dp[N][W]
 ```   

 ```
int knapsack(int W, int N, vector<int>& wt, vector<int>& val) {
    // base case 已初始化
    vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i-1] < 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], 
                               dp[i - 1][w]);
            }
        }
    }
    
    return dp[N][W];
}

 ```

 ## 子集背包问题 
+ https://www.cnblogs.com/labuladong/p/13927956.html
+ 416.分割等和子集
+ 给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少
+ 把问题转化为背包问题：

给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满

+ 第一步要明确两点，「状态」和「选择」。

这个前文 经典动态规划：背包问题 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

第二步要明确 dp 数组的定义。

按照背包问题的套路，可以给出如下定义：

dp[i][j] = x 表示，对于前 i 个物品，当前背包的容量为 j 时，若 x 为 true，则说明可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满。
比如说，如果 dp[4][9] = true，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。

（因为sum是总户数的一半，所以恰好将背包装满时，不可能包含所有的物品！！！）

根据这个定义，我们想求的最终答案就是 dp[N][sum/2]，base case 就是 dp[..][0] = true 和 dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。

第三步，根据「选择」，思考状态转移的逻辑。

```C++
bool canPartition(vector<int>& nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合
    if (sum % 2 != 0) return false;
    int n = nums.size();
    sum = sum / 2;
    vector<vector<bool>> 
        dp(n + 1, vector<bool>(sum + 1, false));
    // base case
    for (int i = 0; i <= n; i++)
        dp[i][0] = true;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {
               // 背包容量不足，不能装入第 i 个物品
                dp[i][j] = dp[i - 1][j]; 
            } else {
                // 装入或不装入背包
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j-nums[i-1]];
            }
        }
    }
    return dp[n][sum];
}

```


+ 进行状态压缩
注意到 dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的，之前的数据都不会再使用了。

所以，我们可以进行状态压缩，将二维 dp 数组压缩为一维，节约空间复杂度


+ 唯一需要注意的是 j 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。
状态压缩部分没看懂，为什么要反向遍历？？？！！！


## 完全背包问题
 + https://www.cnblogs.com/labuladong/p/13927918.html
 + 518.零钱兑换II
 + 有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？
 + 前面讲过的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「完全背包问题」

 + 第一步要明确两点，「状态」和「选择」。
状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。

+ 第二步要明确 dp 数组的定义。

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 dp 数组。

dp[i][j] 的定义如下：

若只使用前 i 个物品，当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包。

换句话说，翻译回我们题目的意思就是：

若只使用 coins 中的前 i 个硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法。

base case 为 dp[0][..] = 0， dp[..][0] = 1。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。

最终想得到的答案就是 dp[N][amount]，其中 N 为 coins 数组的大小。

```
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= amount; j++) {
        if (j - coins[i-1] >= 0)
            dp[i][j] = dp[i - 1][j] 
                     + dp[i][j-coins[i-1]];
return dp[N][W]

```

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = amount int[n + 1][amount + 1];
    // base case
    for (int i = 0; i <= n; i++) 
        dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++)
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] 
                         + dp[i][j - coins[i-1]];
            else 
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}
```
+ 我们通过观察可以发现，dp 数组的转移只和 dp[i][..] 和 dp[i-1][..] 有关，所以可以压缩状态，进一步降低算法的空间复杂度

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[] dp = new int[amount + 1];
    dp[0] = 1; // base case
    for (int i = 0; i < n; i++)
        for (int j = 1; j <= amount; j++)
            if (j - coins[i] >= 0)
                dp[j] = dp[j] + dp[j-coins[i]];
    
    return dp[amount];
}

```
+ 这个解法和之前的思路完全相同，将二维 dp 数组压缩为一维，时间复杂度 O(N*amount)，空间复杂度 O(amount)。
