+ Go 刷 LeetCode 系列：动态规划（4）分割等和子集（0,1背包问题）


---

### 做题总结
0. 空间换时间 （最小值栈，结构体保存最小值）
1. 递归：（1）自顶向下的递归，（2）自底向上的递归
2. 使用数组代替hashmap的思想（利用数组的下标）, 空间换取时间
2. 使用hashmap存， k:value, v: index (https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/)
3. 移位，与或等运算 （n & (n-1) 每次消除一个1.直到n＝0，就能算出多少个1）；与特殊的值与，特别是题目上有提示多少位的整数
4. 边界注意：负数；是否为空；第一个，最后一个；长度是1；不等于0有，总和有可能由正到负再到正再到负，只有算到最后一个叶子才知道；删除的是头或者尾
6. 字母的ASCII码是数字且固定
8. 递归改成迭代，使用栈 !!!!!
9. 结果反转；涉及反转的可以考虑使用辅助栈
10. 数学计算；善用数学公式推导
12. 链表遍历：两个指针，快慢指针;两个指针速度相差1，环形情况一定会相遇（在环形区域）（linked-list-cycle）
因为快慢指针总会到一个圈里不停循环，极端情况下，快指针在圈内循环多几次，总能追上慢指针
13. 动态规划：保存已经计算过的结果，供后续使用
16. 最大值队列（辅助栈，双端队列）
17. 遇到出现次数的题，考虑原地hash的骚操作，利用转负数保留原来的值同时记录状态。出现双数（两次）的，考虑交替正负赋值
nowcoder/NC30 缺失的第一个正整数.go
20. 旋转数组
三次翻转 ！！！！
21. 最长无重复子数组
滑动窗口（双指针）+ hash表！！！！

---


### 图

#### 有向图
+ 入度表 indegrees（key为目标顶点, value为源顶点数值）
+ 邻接表 adjacency (key为源顶点, value为目标顶点列表）
+ DFS，递归！
+ 课程表（拓扑排序：入度表BFS法 / DFS法，清晰图解）: https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/

##### DFS
+ TODO
##### BFS
+ TODO

### 堆
+ 堆的结构可以分为大顶堆和小顶堆，是一个完全二叉树
+ 底层数组结构
+ 大顶堆：`arr(i)>arr(2*i+1) && arr(i)>arr(2*i+2)`；小顶堆：`arr(i)<arr(2*i+1) && arr(i)<arr(2*i+2)`
+ 根找左右：左：`(i+1)*2 - 1`，右：`(i+1)*2` ;
+ 左找根右：根：`(i+1)/2 - 1`，右：`i+1`
+ 右照根左：根：`i/2 - 1`, 左：`i-1`

+ 1 初始化堆，比如小堆：加入堆最后一个结点后，与根节点对比，比根节点小则交换，并继续，否则结束完成（自底向上）
+ 2 调整堆（拿出堆中第一个元素后，即根最后一个结点交换后），将根节点和左右两个元素比较，与较小的那个交换，并继续，若都比自己大，或者已经是叶子结点，则结束完成（自上往下）

### 快速排序
+ 高低下标的值交替被替换，最后得到中间下标，把参照值设置回去
+ topk，结果无序排序的时候可以用

### 动态规划
+ 总结公式：
+ 兑换零钱（一）
+ 打家劫舍（一）
此转移方程为dp[i]=max(dp[i−1],nums[i−1]+dp[i−2])
+ 打家劫舍（二）
这一问在第一问的基础上添加了房屋首尾相连的条件，所以首尾两个数字之间我们最多只能选取一个。

∙ \bullet∙ 既然这样我们就可以将整个数组进行分割，分为 [0,n-2] 与 [1,n-1] 两个部分，分别求解它们的最大值然后再选择两个之间的较大值作为最终结果，其余情况与第一问相同。
————————————————
版权声明：本文为CSDN博主「桃陉」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_46308081/article/details/119087704

### 链表
+ 链表的问题基本都挺容易想，但是写起来比价麻烦，需要许多中间变量，所以做之前要先画图整理清楚，否则写的时候很容易乱



----

+ 蓄水池抽样算法（Reservoir Sampling）:<https://www.jianshu.com/p/7a9ea6ece2af>