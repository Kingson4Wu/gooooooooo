package nowcoder

func solve3(n int, m int, a []int) []int {
	// write code here

	m = m % n

	if m <= n/2 {
		for i := n - 1 - m; i >= 0; i-- {
			a[i], a[i+m] = a[i+m], a[i]
		}
	} else {
		for i := 0; i < m; i++ {
			a[i], a[(i+m)%n] = a[(i+m)%n], a[i]
		}
	}

	return a
}

/**
自己总结的规律，算了，错了很多次！！！！

方法：三次翻转（推荐使用）
思路：

循环右移相当于从第m个位置开始，左右两部分视作整体翻转。即abcdefg右移3位efgabcd可以看成AB翻转成BA（这里小写字母看成数组元素，大写字母看成整体）。既然是翻转我们就可以用到reverse函数。

具体做法:

step 1：因为m可能大于n，因此需要对n取余，因为每次长度为n的旋转数组相当于没有变化。
step 2：第一次将整个数组翻转，得到数组的逆序，它已经满足了右移的整体出现在了左边。
step 3：第二次就将左边的m个元素单独翻转，因为它虽然移到了左边，但是逆序了。
step 4：第三次就将右边的n−m个元素单独翻转，因此这部分也逆序了。

public class Solution {
    public int[] solve (int n, int m, int[] a) {
        //取余，因为每次长度为n的旋转数组相当于没有变化
        m = m % n;
        //第一次逆转全部数组元素
        reverse(a, 0, n - 1);
        //第二次只逆转开头m个
        reverse(a, 0, m - 1);
        //第三次只逆转结尾m个
        reverse(a, m, n - 1);
        return a;
    }
    //反转函数
    public void reverse(int[] nums, int start, int end){
        while(start < end){
            swap(nums, start++, end--);
        }
    }
    //交换函数
    public void swap(int[] nums, int a, int b){
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}

*/

/**
100,99,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]

[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,1]
[100,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,1]
*/

/**

一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M >=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

数据范围：0 < n \le 1000<n≤100，0 \le m \le 10000≤m≤1000
进阶：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)
示例1
输入：
6,2,[1,2,3,4,5,6]
复制
返回值：
[5,6,1,2,3,4]
复制
示例2
输入：
4,0,[1,2,3,4]
复制
返回值：
[1,2,3,4]

*/
